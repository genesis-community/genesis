package Genesis::Env::SecretsStore;
use strict;
use warnings;

### Class Methods {{{

# new -  abstract builder for creating a secrets store for an environment {{{
sub new {
	bug("Abstract Method: Expecting %s class to define concrete '%' method", ref($_[0]), 'new');
	# Input expected:
	#   environment: environment object
	#   options:     key-value pairings to configure secrets store
	#
	# Output expected:
	#   New derived SecretsStore object.
}

# }}}
# }}}

### Abstract Instance Methods - must be defined in derived classes {{{

# Informational
# default_mount - returns the default mount point for this class of secrets store {{{
sub default_mount {
	bug("Abstract Method: Expecting %s class to define concrete '%' method", ref($_[0]), 'default_mount');
	# Input expected:
	#   No arguments
	#
	# Output expected:
	#   String for the default mount point for secrets if user doesn't override.
}

# }}}
# mount - returns the mount point for this secrets store {{{
sub mount {
	bug("Abstract Method: Expecting %s class to define concrete '%' method", ref($_[0]), 'mount');
	# Input expected:
	#   No arguments
	#
	# Output expected:
	#   String for the mount point for this secrets store.
}

# }}}
# default_slug - the default subpath for the environment based on its name and type {{{
sub default_slug {
	bug("Abstract Method: Expecting %s class to define concrete '%' method", ref($_[0]), 'default_slug');
	# Input expected:
	#   No arguments
	#
	# Output expected:
	#   String for the default subpath point for this secrets store.
}

# }}}
# slug - the subpath for the given environment {{{
sub slug {
	bug("Abstract Method: Expecting %s class to define concrete '%' method", ref($_[0]), 'slug');
	# Input expected:
	#   No arguments
	#
	# Output expected:
	#   String for the subpath for this secrets store based on the environment.
}

# }}}
# label - descriptive string for the secret store for this environment {{{
sub label {
	bug("Abstract Method: Expecting %s class to define concrete '%' method", ref($_[0]), 'label');
	# Input expected:
	#   No arguments
	#
	# Output expected:
	#   String for the describing the secret store for this environment.
}

# }}}

# Basic Access
# list - returns an array of existing secrets, given an optional filter {{{
sub list {
	bug("Abstract Method: Expecting %s class to define concrete '%' method", ref($_[0]), 'list');
	# Input expected:
	#   filter: either a string, regular expression or a hash that describes a
	#           filter on the name or type or feature of the secrets.  String
	#           matches a path prefix, regular expressions are applied to path
	#           (or keys if included
	#   keys:   returns keys if set to true, false (default) will only return
	#           secrets paths that match the filter.
	#
	# Output expected:
	#   List of matching secret paths under the base path for the secret store for this environment.
}

# }}}
# get - get the secrets under the given path (and optional key) {{{
sub get {
	bug("Abstract Method: Expecting %s class to define concrete '%' method", ref($_[0]), 'get');
	# Input expected:
	#   path:         store secret path to return the values for
	#   list of keys: a subset of keys to return values for.  (optional - all keys
	#                 returned if not set)
	#
	# Output expected:
	#   Single value if a single path and key are specified, a hash ref if just a
	#   path is specified, or if more than one key is specified.
	#   undef if path not exist, or for each specified key that does not exist.
}

# }}}
# set - write the secret value for the given path, and optional type {{{
sub set {
	bug("Abstract Method: Expecting %s class to define concrete '%' method", ref($_[0]), 'set');
	# Input expected:
	#   path:   store secret path to set values for
	#   values: The value to store at the given secret path.  If this is a scalar,
	#           it will be stored under the `value` key.  If it is a hash, each
	#           specified key will be set to each specified value for that key.
	#           It will not remove any existing keys.
	#
	# Output expected:
	#   values set if successful, raises error otherwise
}

# }}}

# Connectivity

# authenticate - authenticate to the remote store service {{{
sub authenticate {
	bug("Abstract Method: Expecting %s class to define concrete '%' method", ref($_[0]), 'authenticate');
	# Input expected:
	#   No Arguments
	#
	# Output expected:
	#   Self if authenticated, raises error otherwise.
}

# }}}
# is_authenticated - determine if already authenticated to the remote store service {{
sub is_authenticated {
	bug("Abstract Method: Expecting %s class to define concrete '%' method", ref($_[0]), 'is_authenticated');
	# Input expected:
	#   No Arguements
	#
	# Output expected:
	#   1 if authenticated, undef if not.
}

# }}}
# is_available - determine if remote store service is reachable and targetable {{{
sub is_available {
	bug("Abstract Method: Expecting %s class to define concrete '%' method", ref($_[0]), 'is_available');
	# Input expected:
	#   No arguments
	#
	# Output expected:
	#   1 if reachable, undef if not.
}

# }}}
# generate - generate secrets based on the environment {{{
sub generate {
	bug("Abstract Method: Expecting %s class to define concrete '%' method", ref($_[0]), 'generate');
	# Input expected:
	#   options: determine how/what options are generates
	#     filter:  filter for which secrets to add 
	#     verbose: 1 is full output, 0 is progress-line style
	#
	# Output expected:
	#   List of matching secret paths under the base path for the secret store for this environment.
	# # TODO process_kit_secret_plans(
	#	my $processing_opts = {
	#				level=>$opts{verbose}?'full':'line'
	#			};
	#			$self,
	#			sub{$self->_secret_processing_updates_callback('add',$processing_opts,@_)},
}

# }}}
# validate - validate secrets based on the environment {{{
sub validate {
	bug("Abstract Method: Expecting %s class to define concrete '%' method", ref($_[0]), 'validate');
	# Input expected:
	#   filter: either a string, regular expression or a hash that describes a filter on the name or type or feature of the secrets
	#
	# Output expected:
	#   List of matching secret paths under the base path for the secret store for this environment.
	#		my $action = $opts{validate} ? 'validate' : 'check';
	#			my $processing_opts = {
	#				no_prompt => $opts{'no-prompt'},
	#				level=>$opts{verbose}?'full':'line'
	#			};
	#			#TODO: validate_kit_secrets(
	#			$self,
	#		sub{$self->_secret_processing_updates_callback($action,$processing_opts,@_)},
	#   
}
sub rotate {
	bug("Abstract Method: Expecting %s class to define concrete '%' method", ref($_[0]), 'set');
	# Input expected:
	#   filter: either a string, regular expression or a hash that describes a filter on the name or type or feature of the secrets
	#
	# Output expected:
	#   List of matching secret paths under the base path for the secret store for this environment.
}
sub remove {
	bug("Abstract Method: Expecting %s class to define concrete '%' method", ref($_[0]), 'set');
	# Input expected:
	#   filter: either a string, regular expression or a hash that describes a filter on the name or type or feature of the secrets
	#
	# Output expected:
	#   List of matching secret paths under the base path for the secret store for this environment.
}
sub remove_all {
	bug("Abstract Method: Expecting %s class to define concrete '%' method", ref($_[0]), 'set');
	# Input expected:
	#   filter: either a string, regular expression or a hash that describes a filter on the name or type or feature of the secrets
	#
	# Output expected:
	#   List of matching secret paths under the base path for the secret store for this environment.
}

### Instance Methods {{{

# path_separator - string used to separate secrets components
sub path_separator {
	'/'
}

# }}}
# key_separator - string used to separate the secrets path from the key {{{
sub key_separator {
	':'
}

# }}}
# base - the base secrets path for this environment {{{
sub base {
	my $self = shift;
	$self->mount . $self->slug;
}

# }}}
# path - the full path for the secret (and optional key) in this secrets store
sub path {
	my ($self,$secrets_path, $key) = @_;

	join($self->path_separator, $self->base, (ref($secrets_path) eq "ARRAY" ? @{$secrets_path} : $secrets_path)).
	defined($key) ? $self->key_separator . $key : '';
}

# }}}
# }}}



1;
# vim: fdm=marker:foldlevel=1:noet
