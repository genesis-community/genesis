package Genesis::Config;
use strict;
use warnings;

use Genesis qw/bail bug debug info struct_lookup struct_set_value in_array load_yaml_file run workdir mkdir_or_fail semver save_to_yaml_file/;
use Genesis::Term qw/bullet decolorize/;

use JSON::PP ();
use Digest::SHA qw/sha1_hex/;
use File::Basename qw/dirname/;
use POSIX qw/strftime/;

### Class Constants {{{

use constant {
	TRUE  => JSON::PP::true,
	FALSE => JSON::PP::false,
};

# }}}

### Class Methods {{{

# new - return a bare config object {{{
sub new {
	my ($class,$path,$autosave) = @_;

	bug('No path to config file was specified - cannot autosave') if $autosave && !$path;

	return bless({
			path => $path,
			persistant_signature => undef,
			autosave => $autosave ? 1 : 0,
			contents => {},
		}, $class);
}

# }}}
# }}}

# Instance Methods {{{
# path - get the path to the configuration file {{{
sub path {
	$_[0]->{path}
}

# }}}
# exists - returns true if the configuration file exists on the filesystem {{{
sub exists {
	return 0 unless $_[0]->{path};
	-f $_[0]->{path}
}

# }}}
# loaded - returns true if the file has been initialized (loaded from or saved to disk) {{{
sub loaded {
	return 1 if defined($_[0]->{persistant_signature});
}

# }}}
# changed - returns true if the local representation differs from the filesystem {{{
sub changed {
	my $self = shift;
	($self->{persistant_signature}||'') ne $self->_signature;
}

# }}}
# get - read a value from the configuration {{{
sub get {
	my ($self,$key,$default,$set_if_missing) = @_;

	# Caching
	$key ||= '';
	return $self->{cache}{$key} if exists($self->{cache}{$key});

	my ($value,$found) = Genesis::struct_lookup($self->_contents,$key,$default);
	if ($set_if_missing && ! defined($found)) {
		$self->set($key,$value);
		$found = $key;
	}
	$self->{cache}{$key} = $value if $found;
	return $value;
}

# }}}
# has - check if a key exists in the configuration {{{
sub has {
	my ($self, $key) = @_;

	bug("Cannot check for key in configuration without a key") unless defined($key);

	return 1 if exists($self->{cache}{$key});
	my (undef,$found) = Genesis::struct_lookup($self->_contents,$key);
	return $found;
}

# }}}
# set - write a value to the configuration {{{
sub set {
	my ($self, $key, $value, $save) = @_;
	# TODO: Validate key and value against schema

	bug("Cannot set a key in the configuration without a key") unless defined($key);
	bug("Cannot save configuration without a path") if $save && ! $self->{path};

	delete($self->{cache}{$_}) for (grep {$_ =~ /^$key($|[\.\[])/} keys(%{$self->{cache}}));
	struct_set_value($self->_contents,$key,$value);
	$self->save if $self->changed && ($save || $self->{autosave});
	return $self->changed;
}

# }}}
# clear - remove a key from the configuration {{{
sub clear {
	my ($self, $key, $save) = @_;
	# TODO: Delete entire structure if key is undefined, or should that be an error?
	# TODO: Validate key and value against schema

	delete($self->{cache}{$_}) for (grep {$_ =~ /^$key($|[\.\[])/} keys(%{$self->{cache}}));
	struct_set_value($self->_contents,$key,1);
	$self->save if $self->changed && ($save || $self->{autosave});
	return $self->changed;
}

# }}}
# save - save the configuration to the filesystem {{{
sub save {
	my ($self) = @_;

	bug("Cannot save configuration without a path") unless $self->{path};

	my $tmp = workdir();
	my $i=1; while (-f "$tmp/$i.json") {$i++};
	open my $fh, ">", "$tmp/$i.json"
		or bail "Unable to create tempfile for YAML conversion: $!";
	print $fh JSON::PP->new->canonical->encode($self->_contents);
	close $fh;
	my ($out,$rc,$err) = run(
		{stderr => 0},
		'cat "$1" | spruce merge --skip-eval - ; rm "$1"',
		"$tmp/$i.json"
	);
	bail(
		"Failed to convert configuration file to yaml: %s",
		$self->{path}, $err
	) if $rc;
	mkdir_or_fail(dirname($self->{path}));

	my $now = strftime("%Y-%m-%d at %H:%M:%S UTC", gmtime());
	open my $fh2, ">", $self->{path}
		or bail(
			"Failed to write configuration file to %s: %s",
			$self->{path}, $!
		);
	printf $fh2 "---\n# This file is generated by Genesis - do not edit manually.\n# Last updated by %s on %s\n\n", $ENV{USER}, $now;
	print $fh2 $out."\n";
	close $fh2;
	$self->{persistant_signature} = $self->_signature;
}

# }}}
# replace - replace the configuration with a new hash {{{
sub replace {
	my ($self, $prev_config) = @_;
	my $autosave = $prev_config->{'autosave'};
	$prev_config->{autosave} = 0;
	$self->{path} = $prev_config->path;
	$self->{persistant_signature} = $prev_config->{persistant_signature};
	$self->{loaded} = 1;
	my $ok = $self->save;
	$self->{autosave} = $autosave;
	return $ok;
}
	

# }}}
# validate - validate the configuration against a schema {{{
sub validate {
	my ($self, $schema) = @_;
	$self->{schema} = $schema;
	my @errors = ();

	# Ensure all required keys are present, and all defaults are set
	for my $key (keys %$schema) {
		if (exists($schema->{$key}{envvar}) and exists($ENV{$schema->{$key}{envvar}})) {
			# Environment variables take precedence over configuration values.
			$self->set($key, $ENV{$schema->{$key}{envvar}});
		} elsif (exists($schema->{$key}{default}) and ! exists($self->_contents->{$key})) {
			$self->set($key, $schema->{$key}{default});
		} elsif ($schema->{$key}{required} and ! exists($self->_contents->{$key})) {
			push @errors, "#R{$key}: missing required key";
			next;
		}
	}

	for my $key (sort keys %{$self->_contents}) {
		if (! exists($schema->{$key})) {
			push @errors, "#R{$key}: unknown configuration key: expected one of ".join(', ', keys %$schema);
			next;
		}
		my $value = $self->get($key);
		my @key_errors = $self->_validate_key($key, $schema->{$key});
		push @errors, @key_errors if @key_errors;
	}

	if (@errors) {
		bail("Configuration validation failed for #C{%s}:%s",
			$self->{path},
			join('', map {"\n[[".bullet('', inline => 1, indent => 0).">>$_"} @errors));
	}

	return 1;
}
# }}}
# }}}

### Instance Private Methods {{{

# _contents - the contents of the configuration object {{{
sub _contents {
	my ($self) = @_;
	$self->_load() unless ($self->loaded) || (! $self->exists && exists($self->{contents}));
	return $self->{contents}
}

# }}}
# _load - load the contents of the configuration file from disk {{{
sub _load {
	my ($self, $path) = @_;

	$path ||= $self->{path};
	bug("Cannot load configuration without a path") unless $path;

	if ($self->exists) {
		($self->{contents}, my $rc, my $err) = load_yaml_file($path);
		debug "Loaded ".$self->{path}." - rc:$rc";
		bail("Failed to load %s: %s", $path, $err) if ($rc || ! $self->{contents});
		$self->{persistant_signature} = $self->_signature;
	} else {
		$self->{contents} = {};
		$self->{save} if $self->{autosave} && $self->{path};
	}
}

# }}}
# _signature - generate a signature for the current in-memory contents {{{
sub _signature {
	sha1_hex(JSON::PP->new->canonical->encode($_[0]->{contents}))
}
# }}}
# _validate_key - validate a value against a schema {{{
sub _validate_key {
	my ($self, $key, $schema) = @_;
	my @errors = ();
	my $type = $schema->{type} or bug "Schema for $key has no type";
	my $value = $self->get($key);

	if ($type =~ m/\|\|/) {
		# Allows for multiple types - check that at least one is valid
		my @types = split(/\|\|/, $type);
		my $valid = 0;
		for my $t (@types) {
			if ($self->_validate_key($key, {type => $t})) {
				$valid = 1;
				last;
			}
		}
		if (! $valid) {
			push @errors, "#R{$key}: expected one of ".join(', ', @types);
		}
	} elsif ($type eq 'hash') {
		if (ref($value) ne 'HASH') {
			push @errors, "#R{$key}: expected a hash";
		} else {
			# Ensure all required keys are present, and all defaults are set
			for my $subkey (keys %{$schema->{schema}}) {
				my $subschema = $schema->{schema}{$subkey};
				if (exists($subschema->{envvar}) && exists($ENV{$subschema->{envvar}})) {
					# Environment variables take precedence over configuration values.
					$self->set("$key.$subkey", $ENV{$subschema->{envvar}});
				} elsif (exists($subschema->{default}) and ! exists($value->{$subkey})) {
					$self->set("$key.$subkey", $subschema->{default});
				} elsif ($subschema->{required} and ! exists($value->{$subkey})) {
					push @errors, "#R{$key}: missing required key #ri{$subkey}";
				}
			}
			for my $subkey (sort keys %$value) {
				if (! exists($schema->{schema}{$subkey})) {
					push @errors, "#R{$key.$subkey}: unknown configuration key: expected one of ".join(', ', keys %{$schema->{schema}});
					next;
				}
				my @subkey_errors = $self->_validate_key("$key.$subkey", $schema->{schema}{$subkey});
				push @errors, @subkey_errors if @subkey_errors;
			}
		}

	} elsif ($type eq 'array') {
		my $subtype = $schema->{subtype} or bug "Schema for array $key has no subtype"; # or maybe just validate that its a freeform array?
		if (ref($value) eq '' && $subtype eq 'string' && $schema->{envsplit}) {
			# Split the value into an array based on the environment variable
			$value = [split($schema->{envsplit}, $value)];
			$self->set($key,$value);
		}
		if (ref($value) ne 'ARRAY') {
			push @errors, "#R{$key}: expected an array";
		} else {
			for my $i (0..$#{$value}) {
				my $subschema;
				if ($subtype eq 'hash') {
					bug "Schema for array $key hash value has no schema" unless $schema->{schema};
					$subschema = {schema => $schema->{schema}, type => 'hash'};
				} else {
					$subschema = $schema->{schema}//{};
					$subschema->{type} //= $subtype;
				}
				my @subkey_errors = $self->_validate_key("${key}[$i]", $subschema);
				push @errors, @subkey_errors if @subkey_errors;
			}
		}

	} elsif ($type eq 'boolean') {
		if (! in_array($value, TRUE, FALSE, 1, 0, '', undef, 'true', 'false', 'yes', 'no')) {
			push @errors, "#R{$key}: expected a boolean, not #ri{".($value ? $value : '<null>')."}";
		}
		$self->set($key, $value ? TRUE : FALSE); # Normalize to JSON::PP::true or JSON::PP::false
	} elsif ($type eq 'enum') {
		if (! in_array($value, @{$schema->{values}})) {
			push @errors, "#R{$key}: unknown value: #ri{".($value ? $value : "<null>")."}; expected one of ".join(', ', @{$schema->{values}});
		}
	} elsif ($type eq 'string') {
		if (ref($value) ne '' || !defined($value)) {
			push @errors, "#R{$key}: expected a string, not #ri{".($value ? $value : "<null>")."}";
		}
	} elsif ($type eq 'number') {
		if (ref($value) ne '' || !defined($value) || $value !~ m/^-?\d+(\.\d+)?$/) {
			push @errors, "#R{$key}: expected a number, not #ri{".($value ? $value : "<null>")."}";
		}
	} elsif ($type eq 'integer') {
		if (ref($value) ne '' || !defined($value) || $value !~ m/^-?[1-9]\d*$/) {
			push @errors, "#R{$key}: expected an integer, not #ri{".($value ? $value : "<null>")."}";
		}
	} elsif ($type eq 'semver') {
		if (ref($value) ne '' || !defined($value) || ! semver($value)) {
			push @errors, "#R{$key}: expected a number, not #ri{".($value ? $value : "<null>")."}"
				unless (!defined($value) && $schema->{allow_null});
		}
	} elsif ($type =~ /^"(.*?)"$/) {
		if (ref($value) ne '' || !defined($value) || $value ne $1) {
			push @errors, "#R{$key}: expected #ri{$1}, not #ri{".($value ? $value : "<null>")."}";
		}
	} elsif ($type eq 'null') {
		if (defined($value)) {
			push @errors, "#R{$key}: expected null, not #ri{".($value ? $value : "<null>")."}";
		}
	} elsif ($type eq 'any') {
		# Do nothing
	} else {
		push @errors, "#R{$key}: unknown schema type $type";
	}
	return @errors;
}

sub show_diff {

	# Shows the difference between the current configuration and another
	# configuration, which defaults to the last saved configuration.
	my ($self, $other) = @_;
	$other ||= Genesis::Config->new($self->{path});

	# Use spruce to diff the two configurations
	my $file1 = workdir('genesis-config')."/genesis-config-1.yml";
	my $file2 = workdir('genesis-config')."/genesis-config-2.yml";
	my $diff_file  = workdir('genesis-config')."/spruce-diff.ym";
	save_to_yaml_file($self->_contents, $file1);
	save_to_yaml_file($other->_contents, $file2);
	my ($diff, $rc, $err) = run(
		{stderr => 0},
		'script -qe $3, spruce diff "$1" "$2"',
		$file2, $file1, $diff_file
	);
	if ($diff) {
		$diff = decolorize($diff) if $ENV{NOCOLOR};
		info("Differences between existing and updated configuration:\n%s", $diff);
	} else {
		bug "No differences found between existing and updated configuration -- this is impossible.";
	}
}

# }}}
# TODO: extract the hash schema validation into a separate method {{{
# }}}
1;
# vim: fdm=marker:foldlevel=1:noet
