#!/usr/bin/perl
# vim:ft=perl:noet:ts=4:sts=4:sw=4
use strict;
use warnings;

# non-core modules
use JSON::PP qw/decode_json encode_json/;
# NOTE: if you add more non-core modules, they and all their non-core
# dependencies have to be placed in lib/

use Getopt::Long qw/GetOptionsFromArray :config no_ignore_case/;
use File::Temp qw/tempdir tempfile/;
use File::Basename qw/dirname basename/;
use POSIX qw/strftime/;
use Socket qw/inet_ntoa/;
use Cwd qw/getcwd abs_path/;

# Genesis Libs
use Genesis::Utils;
use Genesis::Run;
use Genesis::IO;

our $VERSION = "(development)";
our $GITHUB_URL = "https://github.com/starkandwayne/genesis";
our $USER_AGENT_STRING = "genesis/$VERSION";

$ENV{HTTPS_PROXY}=$ENV{BOSH_ALL_PROXY} if ($ENV{BOSH_ALL_PROXY});

my $END_HOOKS = [];
sub at_exit {
	my ($fn) = @_;
	push @$END_HOOKS, $fn;
}

END {
	$_->($?) for @$END_HOOKS;
}

sub valid_envs {
	my (%envs, $json);
	foreach (glob "*.yml") {
		eval {
			$json = decode_json(Genesis::Run::get({stderr=>"/dev/null"}, 'spruce json "$1"', $_))
		};
		next if $@;
		next unless $json && $json->{params} && $json->{params}{env};
		(my $label= $_) =~ s/\.yml$//;
		$envs{$label} = {
			file  => $_,
			env   => $json->{params}{env},
			vault => $json->{params}{vault} || join('/',(split('-', $json->{params}{env}))),
			bosh  => $json->{params}{bosh}  || $json->{params}{env}
		}
	}
	return %envs;
}

sub same($$) {
	my ($a,$b) = @_;
	die "Arguments are not arrays" unless ref($a) eq 'ARRAY' && ref($b) eq 'ARRAY';
	return 0 unless scalar(@$a) == scalar(@$b);
	return 0 unless join(',',map {length} @$a) eq join(',',map {length} @$b);
	return 0 unless join("\0", @$a) eq join("\0",@$b);
	return 1;
}

sub online {
	return !envset('OFFLINE');
}

sub vaulted {
	return !!$ENV{GENESIS_TARGET_VAULT};
}

sub controlling_terminal {
	return -t STDOUT;
}

sub mkfile_or_fail {
	my ($file, $mode, $content) = @_;
	unless (defined($content)) {
		$content = $mode;
		$mode = undef;
	}
	debug "creating file $file";
	eval {
		open my $fh, ">", $file;
		print $fh $content;
		close $fh;
	} or die "Error creating file $file: $!\n";
	chmod_or_fail($mode, $file) if defined $mode;
	return $file;
}

# mkdir_or_fail $dir;
sub mkdir_or_fail {
	my ($dir,$mode) = @_;
	unless (-d $dir) {;
		debug "creating directory $dir/";
		Genesis::Run::do_or_die(
			"Unable to create directory $dir",
			'mkdir -p "$1"', $dir
		);
	}
	chmod_or_fail($mode, $dir) if defined $mode;
	return $dir;
}
# chdir_or_fail $dir;
sub chdir_or_fail {
	my ($dir) = @_;
	debug "changing current working directory to $dir/";
	chdir $dir or die "Unable to change directory to $dir/: $!\n";
}

# symlink_or_fail $source $dest;
sub symlink_or_fail {
	my ($source, $dest) = @_;
	-d $source or die "$source does not exist!\n";
	-e $dest and die abs_path($dest)." already exists!";
	symlink($source, $dest) or die "Unable to link $source to $dest: $!\n";
}

# copy_or_fail $from, $to;
sub copy_or_fail {
	my ($from, $to) = @_;
	-f $from or die "$from: $!\n";
	open my $in,  "<", $from or die "Unable to open $from for reading: $!\n";
	open my $out, ">", $to   or die "Unable to open $to for writing: $!\n";
	print $out $_ while (<$in>);
	close $in;
	close $out;
}
# chmod_or_fail 0755, $path; <-- don't quote the mode. make it an octal number.
sub chmod_or_fail {
	my ($mode, $path) = @_;
	-e $path or die "$path: $!\n";
	chmod $mode, $path
		or die "Could not change mode of $path: $!\n";
}

our @DIRSTACK;
sub pushd {
	my ($dir) = @_;
	push @DIRSTACK, Cwd::cwd;
	chdir_or_fail($dir);
}
sub popd {
	@DIRSTACK or die "popd called when we don't have anything on the directory stack; please file a bug\n";
	chdir_or_fail(pop @DIRSTACK);
}

# check we're in a Genesis v2 directory
sub in_repo_dir {
	return  -d ".genesis" && -e ".genesis/config";
}

# get_file $path
sub get_file {
	my ($file) = @_;
	open my $fh, "<", $file
		or die "failed to open '$file' for reading: $!\n";
	my $contents = do { local $/; <$fh> };
	close $fh;
	return $contents;
}

sub boolean_to_yaml {
	return $_[0] ? "true" : "false";
}
sub yaml_bool {
	my ($bool, $default) = @_;
	return ($default || 0) unless defined($bool);
	return $bool;
}

sub vault_slug {
	my ($name) = @_;
	$name =~ s/-/\//g;
	return $name;
}

sub validate_features  {
	my ($kit, $version, $meta, @features) = @_;
	my ($k, $v) = ($kit, $version);
	$k ||= "dev";
	$v = "latest" unless defined $v;
	my $label = defined($meta->{subkits}) ? "subkit" : "feature";
	for my $sk (@features) {
		die "You specified a feature without a name\n" unless $sk;
		die "No subkit '$sk' found in kit $k/$v.\n"
			if $label eq "subkit" && ! -d  kit_file($kit, $version, "subkits/$sk", 0);
	}

	my %requested_features = map { $_ => 1 } @features;
	for my $sk (@{$meta->{"${label}s"}}) {
		if ($sk->{choices}) {
			my $matches = 0;
			my ($min_matches,$max_matches) = (1,1);
			if (defined $sk->{pick}) {
				if ($sk->{pick} =~ /^(?:(\d+)|(\d+)?-(\d+)?)$/) {
					($min_matches,$max_matches) = (defined $1) ? ($1,$1) : ($2, $3);
				} else {
					$! = 2; die "There is a problem with kit $kit/$version: $sk->{type} pick invalid.  Please contact the kit author for a fix";
				}
			}
			my @choices;
			for my $choice (@{$sk->{choices}}) {
				push @choices, $choice->{$label} if defined $choice && defined $choice->{$label};
				if (! defined $choice->{$label}){
					$min_matches = 0;
				} elsif ($requested_features{$choice->{$label}}) {
					$matches++;
				}
			}
			my $choices = join(", ", map { "'$_'" } @choices);
			if ($max_matches && $matches > $max_matches) {
				die "You selected too many ${label}s for your $sk->{type}. Should be only one of $choices\n";
			}
			if ($min_matches && $matches < $min_matches) {
				die "You must select a $label to provide your $sk->{type}. Should be one of $choices\n";
			}
		}
	}
}

sub run_feature_hook {
	my ($kit, $version, @features) = @_;
	my $hook_dir = kit_file($kit, $version, "hooks", 0); # grab subkit hook + any helpers
	my $hook = (grep { -f $_ } ("$hook_dir/feature","$hook_dir/subkit"))[0];
	return @features unless $hook;

	$kit ||= "dev";
	$version = "latest" unless defined $version;
	chmod(0755,$hook) unless -x $hook;

	my @out = Genesis::Run::getlines(
		{onfailure => "Error running $hook for $kit/$version. Contact your kit author for a bugfix."},
		$hook, @features
	);

	return grep {$_ ne ""} map { $_ =~ s/^\s+|\s+$//g; $_ } @out;
}

sub run_param_hook {
	my ($kit, $version, $env_name, $vault_prefix, $params, @features) = @_;
	my $hook_dir = kit_file($kit, $version, "hooks", 0); # grab params hook + any helpers
	my $hook = "$hook_dir/params";
	return $params unless -f $hook;


	$kit ||= "dev";
	$version = "latest" unless defined $version;
	chmod(0755,$hook) unless -x $hook;

	my $dir = workdir;
	DumpJSON "$dir/in", $params;
	my $rc = run(
		{interactive => 1, env => {
			GENESIS_ENVIRONMENT_NAME => $env_name,
			GENESIS_VAULT_PREFIX => $vault_prefix }},
		$hook, "$dir/in", "$dir/out", @features
	);
	die "\nNew environment creation cancelled.\n" if $rc == 130;
	die "\nError running params hook for $kit/$version. Contact your kit author for a bugfix.\n" if $rc;

	# FIXME: get a better error message when json fails to load
	open my $fh, "<", "$dir/out";
	my @json = <$fh>;
	close $fh;
	return decode_json(join("\n",@json));
}

sub new_environment {
	my ($meta, $kit, $version, $env, $vault_prefix, $params, @features) = @_;

	$kit     = "dev"    unless defined $kit;
	$version = "latest" unless defined $version;

	my $file = "$env.yml";
	(my $parent = $file) =~ s/-.*\.yml/.yml/;
	my %existing_info = ensure_org_level_environment_file_exists($parent,$kit,$version,@features);

	open my $fh, ">", $file or die "Couldn't write to $file: $!";
	print $fh "---";
	print $fh "\nkit:\n" if (
		!%existing_info ||
		$existing_info{kit}{name} ne $kit ||
		$existing_info{kit}{version} ne $version ||
		!same($existing_info{kit}{features}||[],\@features)
	);
	if (!%existing_info || $existing_info{kit}{name} ne $kit) {
		print $fh "  name:     $kit\n";
		error "#y{WARNING:} $parent specifies a different kit name ($existing_info{kit}{name})";
	}
	if (!%existing_info || $existing_info{kit}{version} ne $version) {
		print $fh "  version:  $version\n";
		error "#y{WARNING:} $parent specifies a different kit version ($existing_info{kit}{version})";
	}
	if (!%existing_info || !same($existing_info{kit}{features}||[],\@features)) {
		print $fh "  features:\n";
		print $fh "  - (( replace ))\n" if defined($existing_info{kit}{features});
		print $fh "  - $_\n" foreach (@features);
	}
	print $fh <<EOF;

params:
  env:   $env
  vault: $vault_prefix
EOF
	if (defined($ENV{GENESIS_BOSH_ENVIRONMENT})) {
		print $fh <<EOF;
  bosh:  $ENV{GENESIS_BOSH_ENVIRONMENT}
EOF
	}

	for my $param (@$params) {
		print $fh "\n";
		my $indent = "  # ";
		if (defined $param->{comment}) {
			for my $line (split /\n/, $param->{comment}) {
				print $fh "${indent}$line\n";
			}
		}
		if (defined $param->{example}) {
			print $fh "${indent}(e.g. $param->{example})\n";
		}

		$indent = $param->{default} ? "  #" : "  ";

		for my $val (@{$param->{values}}) {
			my $k = (keys(%$val))[0];
			# if the value is a spruce operator, we know it's a string, and don't need fancy encoding of the value
			# this helps us not run into issues resolving the operator
			my $v = $val->{$k};
			if (defined $v && ! ref($v) && $v =~ m/^\(\(.*\)\)$/) {
				print $fh "${indent}$k: $v\n";
				next;
			}
			my $tmpdir = workdir;
			open my $tmpfile, ">", "$tmpdir/value_formatting";
			print $tmpfile encode_json($val);
			close $tmpfile;
			open my $spruce, "-|", "spruce merge $tmpdir/value_formatting";

			for my $line (<$spruce>) {
				chomp $line;
				next unless $line;
				next if $line eq "---";
				print $fh "${indent}$line\n";
			}
			close $spruce;
			die "Unable to convert JSON to spruce-compatible YAML. This is a bug\n"
				if $? >> 8;
		}
	}
	close $fh;
	explain "Created #C{$file} environment file";
}

sub ensure_org_level_environment_file_exists {
	my ($parent,$kit,$version,@features) = @_;

	my %existing_info;
	if (-e $parent) {
		%existing_info = %{LoadFile($parent)};
		explain "Using existing #C{$parent} file as base config.";
	} else {
		open my $fh, ">", $parent or die "Couldn't write to $parent: $!";
		print $fh <<EOF;
---
kit:
  name:     $kit
  version:  $version
EOF
		if (@features) {
			print $fh "  features:\n";
			print $fh "  - $_\n" foreach (@features);
		} else {
			print $fh "  features: []\n";
		}
		%existing_info = (
			kit => {
				name => $kit,
				version => $version,
				features => \@features
			}
		);
		close $fh; $fh = undef;
		explain "Created new #C{$parent} file for $kit/$version";
	}
	return %existing_info;
}

sub kit_yaml_files {
	my ($env) = @_;
	my @files;

	my ($kit,$version) = kit_name_and_version_for($env);
	$kit ||= "dev";
	die "No kit/version detected in $env.\n" unless $kit && ($kit eq 'dev' || $version);

	my @features = @{get_key($env, 'kit.features', get_key($env, 'kit.subkits',[]))};
	my $meta = read_kit_metadata($kit, $version);
	validate_features($kit, $version, $meta, @features) unless -f kit_file($kit,$version,"hooks/blueprint",0);

	my $dir = 'dev';
	if ($kit && $version) {
		$dir = get_kit($kit,$version);
	}
	return kit_yaml_files_in($kit,$version,$env, $dir, @features);
}

sub kit_yaml_files_in {
	my ($kit,$version,$env, $dir, @features) = @_;
	$kit     ||= "dev";
	$version ||= "";

	my @files;
	# use hooks/blueprint script if present
	my $blueprint_script_path = "$dir/hooks/blueprint";
	if (-f $blueprint_script_path) {
		-x $blueprint_script_path || chmod_or_fail 0755,$blueprint_script_path;
		my $helper = blueprint_script_helper($kit,$version,$env,@features);
		pushd($dir);
		my $result = Genesis::Run::get(
			{onfailure => "Could not execute $kit/$version hooks/blueprint script successfully"},
			'source "$1"; hooks/blueprint', $helper
		);
		@files = map {Cwd::abs_path($_) || $_ } split /\s+/, $result;
		popd;
		my @missing_files = grep {! -e $_} @files;
		if (@missing_files) {
			error "%s",
				"#R{ERROR:} Missing $kit/$version files required to satisfy selected features in #C{$env}:\n  - ".
				join("\n  - ", @missing_files).
				"\n\nPlease contact kit author to get a fix.\n";
			exit 2
		}
	} else {
		my $features_dir = (-d "$dir/features") ? 'features' : 'subkits';
		@files = glob "$dir/base/*.yml";
		push @files, map { glob "$dir/$features_dir/$_/*.yml" } @features;
	}
	return @files;
}

sub generate_blueprint_script {
	my (@features) = @_;
	return clean_heredoc(<<"	|EOF");
	|#!/bin/bash
	|# Genesis hooks/blueprint script
	|#
	|# This script outputs the list of merge files needed to support the desired
	|# feature set selected by the environment parameter file.  As generated, it
	|# lists all *.yml files in the base, then all *.yml files in each detected
	|# feature directory, in the order the features are specified in the environment
	|# yml file.  If finer control is desired, add logic around the wants_kit_feature()
	|# function (takes a feature as a string, returns exit code 0 if present, non-
	|# zero exit code otherwise).
	|
	|set -eu
	|
	|validate_features ${\join("\\\n                  ", map {"'$_' "} @features)}
	|
	|declare -a manifests
	|manifests+=(base/*.yml)
	|
	|for dir in features/*; do
	|	sub=\$(basename \$dir)
	|	if want_feature \$sub; then
	|		manifests+=(\$dir/*.yml)
	|	fi
	|done
    |echo \${manifests[@]}
	|EOF
}

sub blueprint_script_helper {
	# Assumes it will be executed in the base of the kit directory
	# by the kit_yaml_files_in command.
	my ($kit,$version,$env,@features) = @_;
	$kit     ||= "dev";
	$version ||= "";

	my $env_file = get_env_file($env);
	my $helper_dir = workdir('helper');
	my $out = clean_heredoc(<<"	|EOF");
	|export GENESIS_KIT_NAME="$kit";
	|export GENESIS_KIT_VERSION="$version";
	|export GENESIS_ENV_FILE="$env_file";
	|export GENESIS_REQUESTED_FEATURES="${\join(' ', @features)}"
	|
	|want_feature() {
	|	local __want=\${1:?want_feature() -- must specify a feature}
	|	local __feature
	|	for __feature in \$GENESIS_REQUESTED_FEATURES; do
	|		[[ "\$__want" == "\$__feature" ]] && return 0
	|	done
	|	return 1
	|}
	|export -f want_feature
	|
	|invalid_features() {
	|	local __found
	|	local __valid
	|	local __have
	|	declare -a __invalid
	|	for have in \$GENESIS_REQUESTED_FEATURES; do
	|		__found='';
	|		for __valid in "\$@"; do
	|			[[ "\$__have" == "\$__valid" ]] && __found=1 && break
	|		done
	|		[[ -n \$__found ]] || __invalid+=(\$__have)
	|	done
	|	echo "\${__invalid[@]}"
	|	return 0
	|}
	|export -f invalid_features
	|
	|valid_features() {
	|	local __have
	|	local __found
	|	local __valid
	|	for __have in \$GENESIS_REQUESTED_FEATURES; do
	|		__found=''
	|		for __valid in "\$@"; do
	|			[[ "\${__have}" = "\${__valid}" ]] && __found=1 && break
	|		done
	|		[[ -n \$__found ]] || return 1
	|	done
	|	return 0
	|}
	|export -f valid_features
	|
	|validate_features() {
	|	local __bad
	|	if ! valid_features "\$@"; then
	|		echo >&2 "\$GENESIS_KIT_NAME/\$GENESIS_KIT_VERSION does not understand the following feature flags:"
	|		for __bad in \$(invalid_features "\$@"); do
	|			echo >&2 " - \$__bad"
	|		done
	|		[[ -f "feature_usage.txt" ]] && echo >&2 "" && cat "feature_usage.txt"
	|		exit 1
	|	fi
	|}
	|export -f validate_features
	|
	|EOF

	return mkfile_or_fail("$helper_dir/blueprint_helper",$out);
}

sub new_script_helper {
	my ($kit,$version) = @_;
	my $helper_dir = workdir('helper');
	my $genesis_binary=Cwd::abs_path($0);
	my $out = clean_heredoc(<<"	|EOF")
	|export GENESIS_KIT_NAME="$kit"
	|export GENESIS_KIT_VERSION="$version"
	|describe() {
	|	$genesis_binary ui-describe ""  "\$@"
	|}
	|export -f describe
	|prompt_for() {
	|	local __var="\$1" __type="\$2"; shift 2;
	|	if [[ "\$__type" =~ ^secret- ]] ; then
	|		export GENESIS_TARGET_VAULT="$ENV{GENESIS_TARGET_VAULT}"
	|		$genesis_binary ui-prompt-for "\$__type" "\$__var" "\$@"
	|		local __rc="\$?"
	|		[[ \$__rc -ne 0 ]] && echo "Error encountered - cannot continue" && exit \$__rc
	|	else
	|		local __tmpfile
	|		__tmpfile=\$(mktemp)
	|		[[ $? -ne 0 ]] && echo >&2 "Failed to create tmpdir: \$__tmpfile" && exit 2
	|		$genesis_binary ui-prompt-for "\$__type" "\$__tmpfile" "\$@"
	|		local __rc="\$?"
	|		if [[ \$__rc -ne 0 ]] ; then
	|			# error
	|			echo "Error encountered - cannot continue";
	|			rm -f "\$__tmpfile"
	|			exit \$__rc
	|		fi
	|		if [[ \$__type =~ ^multi- ]] ; then
	|			local __i
	|			eval "unset \$__var"
	|			eval "while IFS= read -r -d '' \\"\${__var}[__i++]\\"; do :; done < \\"\$__tmpfile\\""
	|			eval "\$__var=(\\"\\\${\${__var}[@]:1}\\")"
	|		else
	|			eval "\$__var=\\\$(<\\"\$__tmpfile\\")"
	|		fi
	|		rm -f "\$__tmpfile"
	|	fi
	|	return 0
	|}
	|export -f prompt_for
	|
	|EOF
	.clean_heredoc(<<'	|EOF');
	|param_entry() {
	|	local __disabled="" __varname="$1" __key="$2" __opt="$3" ; shift 3
	|	if [[ "$__opt" == "-d" ]] ; then
	|		__disabled="# "
	|		__opt=$1 ; shift
	|	fi
	|	if [[ "$__opt" == "-a" ]] ; then
	|		if [[ "${#@}" -eq 0 ]] ; then
	|			eval "$__varname+=\"  $__disabled\$__key: []\\n\""
	|		else
	|			eval "$__varname+=\"  $__disabled\$__key:\\n\""
	|			local __line
	|			for __line in "$@" ; do
	|				eval "$__varname+=\"    \$__disabled- \$__line\\n\""
	|			done
	|		fi
	|	elif [[ -n "$__opt" ]] ; then
	|		eval "$__varname+=\"  $__disabled\$__key: \$__opt\\n\""
	|	else
	|		eval "$__varname+=\"  $__disabled\$__key: \$$__key\\n\""
	|	fi
	|}
	|export -f param_entry
	|param_comment() {
	|	local __line __varname=$1; shift
	|	eval "$__varname+=\"\\n\""
	|	for __line in "$@" ; do
	|		eval "$__varname+=\"  # \$__line\\n\""
	|	done
	|}
	|export -f param_comment
	|describe_and_comment() {
	|	local varname=$1; shift
	|	describe "$@"
	|	param_comment $varname "$@"
	|}
	|export -f describe_and_comment
	|
	|EOF

	return mkfile_or_fail("$helper_dir/new_helper",$out);
}

# takes a list of tokens, in order, and generates
# all strictly ordered combinations of them.
#
# for example:
#  [us, east, 1] -> [[us]
#                    [us-east]
#                    [us-east-1]]
#
sub expand_tokens {
	my @tokens = @_;

	my @l;
	my @pre;

	for (@tokens) {
		push @pre, $_;
		push @l, join '-', @pre;
	}

	return @l;
}

# return a list of the hyphen-separated tokens
# that form a common prefix to both arguments.
#
# for example:
#   us-east-1-preprod-a
#   us-east-1-sandbox-a
#   ->    (us, east, 1)
#
sub common_base {
	my ($a, $b) = @_;
	my @a = split /-/, $a;
	my @b = split /-/, $b;
	my @c = (); # common

	while (@a and @b) {
		$a = shift @a;
		$b = shift @b;
		last unless $a eq $b;
		push @c, $a;
	}
	return @c;
}

# return a list of the hyphen-separated tokens
# that form a unique suffix for the second argument.
#
# for example:
#   us-east-1-preprod-a
#   us-east-1-sandbox-a
#   ->     us-east-1, (sandbox, a)
sub unique_suffix {
	my ($a, $b) = @_;
	my @a = split /-/, $a;
	my @b = split /-/, $b;
	my @pre;

	while (@a and @b) {
		last if $a[0] ne $b[0];
		$a = shift @a;
		$b = shift @b;
		push @pre, $a;
	}
	return join('-', @pre), @b;
}

our %KIT_CACHE_DIR;
sub get_kit {
	my ($kit,$version) = @_;
	unless (exists $KIT_CACHE_DIR{"$kit/$version"}) {
		my $dir = workdir('kit');
		die "Kit $kit/$version not found!\n" unless -e ".genesis/kits/$kit-$version.tar.gz";
		Genesis::Run::do_or_die(
			"Could not read kit file",
			'tar -xz -C "$1" --strip-components 1 -f ".genesis/kits/${2}-${3}.tar.gz"',
			$dir, $kit, $version
		);
		$KIT_CACHE_DIR{"$kit/$version"} = $dir;
	}
	return $KIT_CACHE_DIR{"$kit/$version"};
}

sub mergeable_yaml_files {
	my ($file) = @_;
	$file =~ s/\.yml$//;
	my @parts = split /-/, $file;

	my @ll;
	if ($ENV{PREVIOUS_ENV}) {
		for (expand_tokens(common_base($file, $ENV{PREVIOUS_ENV}))) {
			my $here = ".genesis/cached/$ENV{PREVIOUS_ENV}/$_.yml";
			push @ll, $here if -f $here;
		}
		my ($pre, @unique) = unique_suffix($ENV{PREVIOUS_ENV}, $file);
		$pre = "$pre-" unless $pre eq "";
		for (map { "$pre$_" } expand_tokens(@unique)) {
			my $here = "$_.yml";
			push @ll, $here if -f $here;
		}

	} else {
		while (@parts) {
			my $here = join('-', @parts) . ".yml";
			push @ll, $here if -f $here;
			pop @parts;
		}
		@ll = reverse @ll;
	}
	return @ll;
}

sub standalone_environment_yaml_files {
	return grep { find_key("params.env", $_) } @_;
}

sub get_env {
	(my $env = shift) =~ s/\.yml$//;
	my $file =  $env.".yml";
	die "Environment file '$file' does not exist!\n" unless -f $file;
	#die "File '$file' is not a valid environment!\n" unless find_key('params.env',$file);
	#^ The above breaks tests (t/compile.t) because we were lax in the past
	#  about what constitutes a deployable env yml file.  If test-env.yml is a
	#  valid file, with params.env == test-env, can you deploy with file
	#  test-env-upgrade.yml that changes the kit version but keeps the same
	#  params.env??? (Commented out for now)
	#  we may also want a check such as the following:
	#die "File '$file' defines a different environment according to its params.env.  Cut and paste error?\n" unless get_key($env,'params.env') eq $env;
	return $env;
}

sub get_env_file {
	my ($env) = @_;
	$env =~ s/.yml$//;
	return $env.".yml";
}

sub build_jq_filter {
	my ($path) = @_;
	$path =~ s/^([^\.])/.$1/; # ensure it starts with a .
	my @path_bits = grep /\S/, split(/([\.\[]+)/, $path);
	my ($join,$value,$filter);
	while (@path_bits) {
		($join,$value,@path_bits) = @path_bits;
		if ($join eq '.') {
			$filter .= "$join$value";
		} elsif ($join =~ /^\.?\[$/ && $value =~ /([-[:word:]]+)=([-[:word:]]+)\]$/) {
			$filter .= "[] | select(.$1 == \"$2\") | ";
		} elsif ($join =~ /^\.?\[$/ && $value =~ /(\d+)\]$/) {
			$filter .= "[$1]";
		} else {
			die "Invalid pick path: $join$value\n";
		}
	}
	$filter =~ s/ \| $//; # clean off trailing pipes if select was last item.
	return $filter;
}

sub find_key {
	my ($key, @files) = @_;
	my $filter = build_jq_filter($key);
	for (@files) {
		next unless -f $_;
		my ($out,$rc) = run('spruce json "$1" | jq -r "$2"', $_, $filter);
		return $_ if $rc == 0 and $out !~ /^(null\n)?$/;
	}
	return '';
}

sub has_key {
	find_key($_[1], reverse mergeable_yaml_files($_[0]));
}

# Get key from environment file hierarchy.  Returns the default
# if the key does not exist or is null, otherwise it returns the value of
# the key (even if value is 0 or empty string.)
sub get_key {
	my ($file, $key, $default) = @_;
	return $default unless has_key($file, $key);
	my $filter = build_jq_filter($key);

	my $out = Genesis::Run::get(
		{onfailure => "Unable to merge environment files"},
		'f="$1"; shift; spruce merge --skip-eval "$@" | spruce json | jq -Mc "$f"',
		$filter, mergeable_yaml_files($file)
	);
	JSON::PP->new->allow_nonref->decode($out);
}

sub has_feature {
	my ($file, $feature) = @_;
	my %features = map { $_ => 1 } @{get_key($file, "kit.features") || get_key($file, "kit.subkits") || []};
	return $features{$feature};
}

###########################################################################

sub dereference_param {
	my ($env, $key) = @_;
	my $val = get_key($env, $key);
	die "Unable to resolve '$key' for $env. This must be defined in the environment YAML.\n"
		unless defined $val;
	return $val;
}

sub dereference_params {
	my ($cmd, $env) = @_;
	$cmd =~ s/\$\{(.*?)\}/dereference_param($env, $1)/ge;
	return $cmd;
}

sub safe_path_exists {
	return Genesis::Run::check(qw(safe exists), $_[0]);
}

sub safe_commands {
	my ($creds, %options) = @_;
	my @cmds;
	my $force_rotate = ($options{scope}||'') eq 'force';
	my $missing_only = ($options{scope}||'') eq 'add';
	for my $path (sort keys %$creds) {
		if (! ref $creds->{$path}) {
			my $cmd = $creds->{$path};
			$cmd = dereference_params($cmd, $options{env});

			if ($cmd =~ m/^(ssh|rsa)\s+(\d+)(\s+fixed)?$/) {
				my $safe = [$1, $2, "secret/$options{prefix}/$path"];
				push @$safe, "--no-clobber", "--quiet" if ($3 && !$force_rotate) || $missing_only;
				push @cmds, $safe;

			} elsif ($cmd =~ m/^dhparams?\s+(\d+)(\s+fixed)?$/) {
				my $safe = ['dhparam', $1, "secret/$options{prefix}/$path"];
				push @$safe, "--no-clobber", "--quiet" if ($2 && !$force_rotate) || $missing_only;
				push @cmds, $safe;

			} else {
				die "unrecognized credential type: `$cmd'\n";
			}
		} elsif ('HASH' eq ref $creds->{$path}) {
			for my $attr (sort keys %{$creds->{$path}}) {
				my $cmd = $creds->{$path}{$attr};
				$cmd = dereference_params($cmd, $options{env});

				if ($cmd =~ m/^random\s+(\d+)(\s+fmt\s+(\S+)(\s+at\s+(\S+))?)?(\s+allowed-chars\s+(\S+))?(\s+fixed)?$/) {
					my ($len, $format, $destination, $valid_chars, $fixed) = ($1, $3, $5, $7, $8);
					my @allowed_chars = ();
					if ($valid_chars) {
						@allowed_chars = ("--policy", $valid_chars);
					}
					my $safe = ['gen', $len, @allowed_chars, "secret/$options{prefix}/$path", $attr];
					push @$safe, "--no-clobber", "--quiet" if ($fixed && !$force_rotate) || $missing_only;
					push @cmds, $safe;
					if ($format) {
						$destination ||= "$attr-$format";
						my $safe = ["fmt", $format , "secret/$options{prefix}/$path", $attr, $destination];
						push @$safe, "--no-clobber", "--quiet" if ($fixed && !$force_rotate) || $missing_only;
						push @cmds, $safe;
					}

				} else {
					die "unrecognized credential type: `$cmd'\n";
				}
			}
		} else {
			die "unrecognized datastructure for $path. Please contact your kit author\n";
		}
	}

	return @cmds;
}

sub cert_commands {
	my ($certs, %options) = @_;
	my @cmds;
	my $force_rotate = ($options{scope}||'') eq 'force';
	my $missing_only = ($options{scope}||'') eq 'add';
	for my $path (sort keys %$certs) {
		my @cmd = (
			"x509",
			"issue",
			"secret/$options{prefix}/$path/ca",
			"--name", "ca.$path",
			"--ca");
		push @cmd, "--no-clobber", "--quiet" if !$force_rotate; # All CA certs are considered kept
		push @cmds, \@cmd;

		for my $cert (sort keys %{$certs->{$path}}) {
			next if $cert eq "ca";
			my $c = $certs->{$path}{$cert};

			die "Required 'names' value missing for cert at $path/$cert.\n" unless $c->{names}[0];
			my $cn = $c->{names}[0];
			$c->{valid_for} ||= "1y";

			my @name_flags = map {( "--name", dereference_params($_, $options{env}) )} @{$c->{names}};
			my @cmd = (
				"x509",
				"issue",
				"secret/$options{prefix}/$path/$cert",
				"--ttl", $c->{valid_for},
				@name_flags,
				"--signed-by", "secret/$options{prefix}/$path/ca");
			push @cmd, "--no-clobber", "--quiet" if $missing_only || $c->{fixed};
			push @cmds, \@cmd;
		}
	}
	return @cmds;
}

sub check_secret {
	my ($cmd, %options) = @_;
	my (@keys);
	my $type = $cmd->[0];
	my $path = $cmd->[2];
	if ($type eq 'x509') {
		if (grep {$_ eq '--signed-by'} @$cmd) {
			$type = "certificate";
			@keys = qw(certificate combined key);
		} else {
			$type = "CA certificate";
			@keys = qw(certificate combined crl key serial);
		}
	} elsif ($type eq 'rsa') {
		@keys = qw(private public);
	} elsif ($type eq 'ssh') {
		@keys = qw(private public fingerprint);
	} elsif ($type eq 'dhparam') {
		@keys = qw(dhparam-pem);
	} elsif ($type eq 'gen') {
		$type = 'random';
		my $path_offset = $cmd->[1] eq '-l' ? 3 : 2;
		$path_offset += 2 if $cmd->[$path_offset] eq '--policy';
		$path = $cmd->[$path_offset];
		@keys = ($cmd->[$path_offset + 1]);
	} elsif ($type eq 'fmt') {
		$type = 'random/formatted';
		@keys = ($cmd->[4]);
	} else {
		die "Unrecognized credential or certificate command: '".join(" ", @$cmd)."'\n";
	}
	return map {["[$type]", "$path:$_"]} grep {!safe_path_exists("$path:$_")} @keys;
}

###########################################################################

sub validate_repo_name {
	my ($name) = @_;
	return $name =~ m/^[a-z][a-z0-9-]+$/;
}

sub check_env_name_for_errors {
	my ($name) = @_;
	return "Can only contain lowercase alphanumeric characters and dashes." if $name !~ m/^[a-z0-9-]+$/;
	return "Must start with a lowercase alphabetic character." if $name !~ m/^[a-z]/;
	return "Cannot contain sequential dashes." if $name =~ m/--/;
	return "Must be at least two levels to allow a base file for pipeline propagation." if $name !~ m/-/;
	return "";
}

###########################################################################

our %ord_suffix = (11 => 'th', 12 => 'th', 13 => 'th', 1 => 'st', 2 => 'nd', 3 => 'rd');
sub ordify {
	return "$_[0]". ($ord_suffix{ $_[0] % 100 } || $ord_suffix{ $_[0] % 10 } || 'th')." ";
}

sub clean_heredoc {
	my $heredoc = join("",map {s/^\s*\|//; $_} split(/^/, shift));
	chomp $heredoc;
	return $heredoc;
}

sub __prompt_for_line {
	my ($prompt,$validation,$err_msg,$default,$allow_blank) = @_;
	$prompt = join(' ', grep {defined($_) && $_ ne ""} ($prompt, '>')) . " ";

	# `validate` is a sub with first argument the test value, and the second
	# being an optional error message
	#
	# NOTE:  IF YOU ADD OR MODIFY A VALIDATION, YOU NEED TO ADD IT TO THE
	#        `validate_kit_metadata` routine below
	my $validate;
	if (defined($validation)) {
		if (ref($validation) eq 'CODE') {
			$validate = $validation; # Only used by internal usage of prompts
		} elsif ($validation eq "ip") {
			$validate = sub() {
				my @ipbits = split(/\./, $_[0]);
				my $msg = ($_[1] ? $_[1] :"$_[0] is not a valid IPv4 address");
				return "" if scalar(grep {$_ =~ /^\d+$/ && $_ !~ /^0./ && $_ < 256} @ipbits) == 4;
				return "$msg: octets cannot be zero-padded" if scalar(grep {$_ =~  /^0./} @ipbits);
				return $msg;
			}
		} elsif ($validation eq "url") {
			$validate = sub() {
				return "" if (is_valid_uri($_[0]));
				return ($_[1] ? $_[1] :"$_[0] is not a valid URL");
			}
		} elsif ($validation eq "port") {
			$validate = sub() {
				return "" if ( ($_[0] =~ m/^\d+$/) && ($_[0] >= 0 ) && ($_[0] <= 65535) );
				return ($_[1] ? $_[1] :"$_[0] is not a valid port");
			}
		} elsif ($validation =~ m/^(-?\d+(?:.\d+)?)(?:(\+)|-(-?\d+(?:.\d+)?))$/) {
			my ($__min,$__unbound_max,$__max) = ($1,$2,$3);
			$__unbound_max ||= "";
			$validate = sub() {
				return "" if (($_[0] =~ m/^\d+$/) && ($_[0] >= $__min ) && ($_[0] <= $__max || $__unbound_max eq "+"));
				return ($_[1] ? $_[1] : ( $__unbound_max eq "+" ? "$_[0] must be at least $__min" : "$_[0] expected to be between $__min and $__max"));
			}
		} elsif ($validation =~ m/^(!)?\/(.*)\/(i?m?s?)$/) {
			my $__vre;
			my $__negate = ($1 && $1 eq "!");
			# safe because the only thing being eval'ed is the optional i,s, or m
			eval "\$__vre = qr/\$2/$3"
				or die "Error compiling param regex: $!";
			$validate = $__negate ? sub() {
				return ($_[0] !~ $__vre ? "" : ( $_[1] ? $_[1] : "Matches exclusionary pattern"));
			} : sub() {
				return ($_[0] =~ $__vre ? "" : ( $_[1] ? $_[1] : "Does not match required pattern"));
			};
		} elsif ($validation =~ m/^(!)?\[([^,]+(,[^,]+)*)\]$/) {
			my @__vlist = split(",", $2);
			my $__negate = ($1 && $1 eq "!");
			$validate =  sub() {
				my $needle=shift;
				my @matches = grep {$_ eq $needle} @__vlist;
				return $__negate ?
					(scalar(@matches) == 0 ? "" : ($_[1] ? $_[1] : "Cannot be one of ".join(", ",@__vlist))):
					(scalar(@matches) != 0 ? "" : ($_[1] ? $_[1] : "Expecting one of ".join(", ",@__vlist)));
			}
		} elsif ($validation =~ m/^((^|,)[^,]+){2,}$/) { # Deprecated list match 2 or more
			my @__vlist = split(",", $validation);
			$validate = sub() {
				my $needle=shift;
				my @matches = grep {$_ eq $needle} @__vlist;
				return (scalar(@matches) != 0 ? "" : ($_[1] ? $_[1] : "Expecting one of ".join(", ",@__vlist)));
			}
		} elsif ($validation eq "vault_path") {
			$validate = sub() {
				return "" unless vaulted();
				return (safe_path_exists $_[0]) ? "" : ($_[1] ? $_[1] :"$_[0] not found in vault");
			}
		} elsif ($validation eq "vault_path_and_key") {
			$validate = sub() {
				# Revisit this when https://github.com/starkandwayne/safe/issues/121 is resolved; for
				# now, assume there can only be one colon separating the path from the key.
				return "$_[0] is missing a key - expecting secret/<path>:<key>" unless $_[0] =~ qr(^[^:]+:[^:]+$);
				return "" unless vaulted();
				return (safe_path_exists $_[0]) ? "" : ($_[1] ? $_[1] :"$_[0] not found in vault");
			}
		}
	}

	while (1) {
		print csprintf("%s", $prompt);
		chomp (my $in=<STDIN>);
		if ($in eq "" && defined($default)) {
			$in = $default;
			print(csprintf("\033[1A%s#C{%s}\n",$prompt, $in));
		}
		$in =~ s/^\s+|\s+$//g;

		return "" if ($in eq "" && $allow_blank);
		my $err="";
		if ($in eq "") {
			return "" if $allow_blank;
			$err= "#R{No default:} you must specify a non-empty string";
		} else {
			$err = &$validate($in,$err_msg) if defined($validate);
			$err = "#r{Invalid:} $err" if $err;
		}

		no warnings "numeric";
		return (($in eq $in + 0) ? $in + 0 : $in) unless $err;
		use warnings "numeric";
		error($err);
	}
}

sub __prompt_for_block {
	my ($prompt) = @_;
	$prompt = "$prompt (Enter <CTRL-D> to end)";
	(my $line = $prompt) =~ s/./-/g;
	print "\n$prompt\n$line\n";
	my @data = <STDIN>;
	return join("", @data);
}

sub prompt_for_boolean {
	my ($prompt,$default,$invert) = @_;
	my ($t,$f) = (JSON::PP::true,JSON::PP::false);

	my $true_re = qr/^(?:y(?:es)?|t(rue)?)$/i;
	my $false_re =  qr/^(?:no?|f(alse)?)$/i;
	my $val_prompt = "[y|n]";
	if (defined $default) {
		$default = $default ? "y" : "n" if $default =~ m/^[01]$/; # standardize
		$val_prompt = $default =~ $true_re ? "[#g{Y}|n]" : "[y|#g{N}]";
	}
	chomp $prompt;
	if ($prompt =~ /\[y\|n\]/) {
		# Allow a single line boolean prompt
		$prompt =~ s/\[y\|n\]/$val_prompt/;
		$val_prompt = $prompt;
		print "\n";
	} else {
		print "\n$prompt\n";
	}
	while (1) {
		my $answer = __prompt_for_line($val_prompt,undef,undef,$default,'allow_blank');
		return ($invert ? $f : $t) if $answer =~ $true_re;
		return ($invert ? $t : $f) if $answer =~ $false_re;
		error "#r{Invalid response:} you must specify y, yes, true, n, no or false";
	}
}
sub prompt_for_choices {
	my ($prompt, $choices, $min, $max, $labels, $err_msg) = @_;

	my %chosen;
	$labels ||= [];
	my $num_choices = scalar(@{$choices});
	for my $i (0 .. $#$choices) {
		$labels->[$i] ||= $choices->[$i];
		$prompt .= "\n  ".($i+1).") ".$labels->[$i];
	}
	my $line_prompt = "choice";
	$min ||= 0;
	$max ||= $num_choices;
	die "Illegal list maximum count specified. Please contact your kit author for a fix.\n"
		if $max < $min;

	print csprintf($prompt."\n\nMake your selections (leave $line_prompt empty to end):\n");

	my @ll;
	while (1) {
		my $v = __prompt_for_line(
			ordify(scalar(@ll) + 1) . $line_prompt,
			"1-$num_choices",
			$err_msg || "Invalid choice - enter a number between 1 and $max",
			undef,
			'allow_blank'
		);
		if ($chosen{$v}) {
			error "#r{ERROR:} ".$choices->[$v-1]." already selected - choose another value";
			next;
		}
		if ($v eq "") {
			if (scalar(@ll) < $min) {
				error "#r{ERROR:} Insufficient items provided - at least $min required.";
				next;
			}
			last;
		}
		push @ll, $choices->[$v-1];
		$chosen{$v} = 1;
		print(csprintf("\033[1A%s%s > #C{%s}\n",ordify(scalar(@ll)), $line_prompt, $labels->[$v-1]));
		last if scalar(@ll) == $max;
	}
	return \@ll;

}
sub prompt_for_choice {
	my ($prompt, $choices, $default, $labels, $err_msg) = @_;

	my $default_choice;
	my $num_choices = scalar(@{$choices});
	print "\n$prompt";
	for my $i (0 .. $#$choices) {
		my $label = (ref($labels) eq 'ARRAY' &&  $labels->[$i]) ? $labels->[$i] : $choices->[$i];
		print "\n  ".($i+1).") ".$label;
		if ($default && $default eq $choices->[$i]) {
			print csprintf(" #G{(default)}");
			$default_choice = $i+1;
		}
	}
	print "\n\n";
	my $c = __prompt_for_line(
		"Select choice",
		"1-$num_choices",
		$err_msg || "enter a number between 1 and $num_choices",
		$default_choice);

	print(csprintf("\033[1ASelect choice > #C{%s}\n", (ref($labels) eq 'ARRAY' &&  $labels->[$c-1]) ? $labels->[$c-1] : $choices->[$c-1]));
	return $choices->[$c-1];
}

sub prompt_for_line {
	my ($prompt,$label,$default,$validation,$err_msg) = @_;
	if ($prompt) {
		print "\n$prompt";
		my $padding = ($prompt =~ /\s$/) ? "" : " ";
		print(csprintf("%s", "${padding}#g{(default: $default)}")) if defined($default);
	} elsif (defined($default) && defined($label)) {
		my $padding = ($label =~ /\s$/) ? "" : " ";
		$label .= csprintf("%s", "${padding}#g{(default: $default)}");
	}
	print "\n";
	return __prompt_for_line(defined($label) ? $label : "", $validation, $err_msg, $default);
}

sub prompt_for_list {
	my ($type,$prompt,$label,$min,$max,$validation, $err_msg, $end_prompt) = @_;
	$label ||= "value";
	$min ||= 0;
	$end_prompt = "(leave $label empty to end)" unless defined($end_prompt);
	die "Illegal list maximum count specified. Please contact your kit author for a fix.\n"
		if (defined($max) and $max < 1);

	print csprintf("\n%s %s\n", $prompt, $end_prompt);

	my @ll;
	while (1) {
		my $v;
		if ($type eq 'line') {
			$v = __prompt_for_line(ordify(scalar(@ll) + 1) . $label, $validation, $err_msg, undef, 'allow_blank');
		} else {
			$v = __prompt_for_block(ordify(scalar(@ll) + 1) . $label);
		}
		if ($v eq "") {
			if (scalar(@ll) < $min) {
				error "#r{ERROR:} Insufficient items provided - at least $min required.";
				next;
			}
			last;
		}
		push @ll, $v;
		last if (defined($max) && scalar(@ll) == $max);
	}
	return \@ll;
}

sub prompt_for_block {
	printf("\n");
	return __prompt_for_block(@_);
}

# genesis prompt support routines: *_prompt_handlers {{{

sub validate_prompt_opts {
	my ($type,$opts,@valid_opts) = @_;
	my @invalid_opts;
	for my $opt (keys %$opts) {
		push @invalid_opts, $opt unless grep {$_ eq $opt} @valid_opts;
	}
	if (@invalid_opts) {
		error "#R{ERROR:} %s prompt does not support option(s) '%s'", $type, join("', '", @invalid_opts);
		error "Contact your kit author for a fix.";
		exit 2;
	}
}

sub line_prompt_handler {
	my ($prompt, %opts) = @_;
	validate_prompt_opts("line", \%opts, qw(label default validation msg));
	return prompt_for_line($prompt, $opts{label},$opts{default},$opts{validation},$opts{msg})
}

sub boolean_prompt_handler {
	my ($prompt, %opts) = @_;
	validate_prompt_opts("boolean", \%opts, qw(default invert));
	return prompt_for_boolean($prompt, $opts{default}, $opts{invert}) ? "true" : "false";
}
sub block_prompt_handler {
	my ($prompt, %opts) = @_;
	validate_prompt_opts("block", \%opts, qw());
	return prompt_for_block($prompt);
}
sub select_prompt_handler {
	my ($prompt, %opts) = @_;
	validate_prompt_opts("select", \%opts, qw(label default option));
	my (@choices,@labels);
	die "No options provided to prompt for select\n" unless $opts{option} && @{$opts{option}};
	for (@{$opts{option}}) {
		$_ =~ m/^(\[(.*?)\]\s*)?(\S.*)$/;
		push @labels, $3;
		push @choices, $1 ? $2 : $3;
	}
	return prompt_for_choice($prompt,\@choices, $opts{default}, \@labels, $opts{msg});
}
sub multi_line_prompt_handler {
	my ($prompt, %opts) = @_;
	validate_prompt_opts("multi-line", \%opts, qw(label min max validation msg));
	my $results = prompt_for_list('line',$prompt,$opts{label},$opts{min},$opts{max},$opts{validation},$opts{msg});
	return "" unless scalar @$results;
	return join("\0", '' , @$results);
}
sub multi_block_prompt_handler {
	my ($prompt, %opts) = @_;
	validate_prompt_opts("multi-block", \%opts, qw(label min max msg));
	my $results = prompt_for_list('block',$prompt,$opts{label},$opts{min},$opts{max},undef,$opts{msg});
	return "" unless scalar @$results;
	return join("\0", '' , @$results);
}
sub multi_select_prompt_handler {
	my ($prompt, %opts) = @_;
	validate_prompt_opts("multi-select", \%opts, qw(label min max option));
	my (@choices,@labels);
	die "No options provided to prompt for select\n" unless $opts{option} && @{$opts{option}};
	for (@{$opts{option}}) {
		$_ =~ m/^(\[(.*?)\]\s*)?(\S.*)$/;
		push @labels, $3;
		push @choices, $1 ? $2 : $3;
	}
	my $results = prompt_for_choices($prompt,\@choices, $opts{min}, $opts{max}, \@labels, $opts{msg});
	return "" unless scalar @$results;
	return join("\0", '' , @$results);
}
sub secret_line_prompt_handler {
	my ($prompt,%opts) = @_;
	my $secret = delete $opts{secret};
	validate_prompt_opts("secret-line", \%opts, qw(echo));
	target_vault($ENV{GENESIS_TARGET_VAULT});
	my ($path, $key) = split /:/, "secret/$secret";
	Genesis::Run::interact(
		{onfailure => "Failed to save data to secret/$secret in Vault '$ENV{GENESIS_TARGET_VAULT}'"},
		'safe prompt "$1" --  "$2" "$3" "$4"',
		$prompt, ($opts{echo} ? "ask" : "set"), $path, $key
	);
}
sub secret_block_prompt_handler {
	my ($prompt,%opts) = @_;
	my $secret = delete $opts{secret};
	validate_prompt_opts("secret-block", \%opts, ());
	target_vault($ENV{GENESIS_TARGET_VAULT});
	my ($path, $key) = split /:/, "secret/$secret";
	my $file = mkfile_or_fail(workdir()."/param", prompt_for_block($prompt));
	Genesis::Run::do_or_die(
		"Failed to save data to secret/$secret in Vault '$ENV{GENESIS_TARGET_VAULT}'",
		'safe set "$1" "${2}@${3}"', $path, $key, $file
	);
}

our $prompt_handlers = {
	line =>           \&line_prompt_handler,
	boolean =>        \&boolean_prompt_handler,
	block =>          \&block_prompt_handler,
	select =>         \&select_prompt_handler,
	"multi-line" =>   \&multi_line_prompt_handler,
	"multi-block" =>  \&multi_block_prompt_handler,
	"multi-select" => \&multi_select_prompt_handler,
	"secret-line" =>  \&secret_line_prompt_handler,
	"secret-block" => \&secret_block_prompt_handler,
};

# }}}

sub parse_uri {
	my ($uri) = @_;
	# https://tools.ietf.org/html/rfc3986
    # We use very basic validation
	$uri =~ m/^(?<uri>
		(?<scheme>[a-zA-Z][a-zA-Z0-9+.-]+):\/\/
		(?<authority>
			(?:(?<userinfo>(?<user>[^:@]+)(?::(?<password>[^@]+)))?@)?
			(?<host>[a-zA-Z0-9.\-_~]+)?
			(?::(?<port>\d+))?
		)
		(?<path>\/(?:[a-zA-Z0-9-._~]|[a-f0-9]|[!\$&'()*+,;=:@])+(?:\/(?:[a-zA-Z0-9-._~]|[a-f0-9]|[!\$&'()*+,;=:@])*)*|(?:\/(?:[a-zA-Z0-9-._~]|[a-f0-9]|[!\$&'()*+,;=:@])+)*)?
		(?:\?(?<query>(?:[a-zA-Z0-9-._~]|[a-f0-9]|[!\$&'()*+,;=:@]|%[A-Fa-f0-9]{2})+))?
		(?:\#(?<fragment>(?:[a-zA-Z0-9-._~]|[a-f0-9]|[!\$&'()*+,;=:@])+))?
	)$/gsx;
	return %+;
}

sub is_valid_uri {
	my %components = parse_uri($_[0]);
	return unless ($components{scheme}||"") =~ /^(https?|file)$/;
	return unless $components{authority} || ($components{scheme} eq 'file' && $components{path});
	return $components{uri};
}

sub check_bosh_version {
	my ($min) = @_;
	my $best = "0.0.0";
	foreach my $boshcmd (qw(bosh2 boshv2 bosh)) {
		my $version = Genesis::Run::get("$boshcmd -v 2>&1 | grep version | head -n1");
		if ($version =~ /version (\S+?)-.*/) {
			if (new_enough("bosh", $1, $min)) {
				$ENV{GENESIS_BOSH_COMMAND} = $boshcmd;
				debug "#g{Version $1} of #C{$boshcmd} meets or exceeds minimum of #w{$min}";
				return ();
			}
			$best = $1 if new_enough("bosh", $1, $best); # Track the best we've found for error message
		}
	}
	if ($best eq "0.0.0") {
		return "#R{Missing `bosh2`} - install the BOSH (v2) CLI from #B{https://github.com/cloudfoundry/bosh-cli/releases}";
	} else {
		return "BOSH (v2) CLI v${best} is installed, but Genesis requires #R{at least $min} - upgrade your BOSH CLI, via #B{https://github.com/cloudfoundry/bosh-cli/releases}";
	}
}

sub is_create_env {
	my ($env) = @_;
	# convert env to file for env if not already done
	$env = "$env.yml" unless $env =~ /\.yml$/;
	return has_feature($env, 'bosh-init') || has_feature($env, 'create-env') || has_feature($env, 'proto');
}

sub bosh_deploy {
	my ($target, $deployment, $path_to_manifest, @deploy_opts) = @_;
	my @args = ();
	if ($target eq "create-env") {
		@args = ("create-env", "--state", $deployment);
		push @args, "-n" if $ENV{BOSH_NON_INTERACTIVE};
		push @args, $path_to_manifest;
	} else {
		@args = ("-e", $target, "-d", $deployment);
		push @args, "-n" if $ENV{BOSH_NON_INTERACTIVE};
		push @args, "deploy", @deploy_opts, $path_to_manifest;
	}
	Genesis::Run::interactive_bosh(@args);
	return $? >> 8;
}

sub bosh_alias {
	Genesis::Run::interactive_bosh(
		{onfailure => "Could not create BOSH alias for '$_[0]'"},
		'alias-env', $_[0]
	);
}

sub bosh_run_errand {
	my ($target, $deployment, $errand) = @_;
	Genesis::Run::interactive_bosh(
		{onfailure => "Failed to run errand '$errand' ($deployment deployment on $target BOSH)"},
		"-n", "-e", $target, "-d", $deployment, "run-errand", $errand
	);
}

sub bosh_upload_stemcell {
	my ($name, $version, $sha1, $url) = @_;
	Genesis::Run::interactive_bosh(
		{onfailure => "Failed to upload stemcell $name/$version from $url"},
		"-n", "upload-stemcell", "--name", $name, "--version", $version, "--sha1", $sha1, $url
	);
}

sub bosh_download_cloud_config {
	my ($target, $path_to_cloudconfig) = @_;
	Genesis::Run::interactive_bosh(
		{onfailure => "Failed to download cloud-config from '$target' BOSH director."},
		'-e "$1" cloud-config > "$2"', $target, $path_to_cloudconfig
	);
	die "No cloud-config defined on BOSH director '$target'.\n" unless -s $path_to_cloudconfig;
}

sub write_stemcell_data {
	my ($file) = @_;
	my $stemcells = "{}";
	if ($ENV{GENESIS_INDEX} ne "no") {
		my $flags = "-ks";
		$flags += " -v" if envset 'GENESIS_DEBUG';
		$stemcells = Genesis::Run::get(
			{onfailure => "Unable to contact the genesis index to retrieve stemcell data. Cannot continue."},
			'curl '.$flags.' "${1}/v1/stemcell/latest | jq -Mc "$2"',
			$ENV{GENESIS_INDEX}, '. | map({"key": .name, "value": { "sha1": .sha1, "url": .url}}) | from_entries'
		);
	}
	open my $fh, ">", $file;
	print $fh <<EOF;
---
meta:
  latest_stemcells: $stemcells

EOF
	close $fh;
}

sub spruce_vault_paths {
	my (@files) = @_;
	my @keys= Genesis::Run::getlines('f="$1"; shift; spruce vaultinfo --go-patch "$@" | spruce json | jq -r "$f"', '.secrets[].key', @files);
	if ($? != 0) {
		die "Failure while running spruce vaultinfo.\n";
	}
	my %paths = map {$_ =~ s/:.*?$//; $_ => 1} @keys;
	return keys %paths;
}

sub spruce_merge {
	my (@files) = @_;
	if (!@files) {
		my (undef, $file, $line) = caller;
		die "BUG DETECTED!  $file:$line called spruce_merge without any arguments.  Please file a bug report at $GITHUB_URL\n";
	}

	# spruce_merge({ prune => ['meta', 'pipeline']}, $file1, $file2)
	# spruce_merge({ prune => 'meta'}, $file1, $file2)
	my $opts = ref($files[0]) eq 'HASH' ? shift @files : {};
	my @flags;
	for my $flag (keys %$opts) {
		for my $value (ref($opts->{$flag}) ? @{ $opts->{$flag} } : ($opts->{$flag})) {
			push @flags, "--$flag", $value;
		}
	}
	push @flags, "--go-patch";

	open my $cmd, "-|", (qw(spruce merge), @flags, @files)
		or die "Failed to execute `spruce merge': $!\n";
	my $out = do { local $/; <$cmd> };
	close $cmd;
	exit ($? >> 8 ) unless $? == 0;
	return $out;
}

# finds the "name" of the deployment type that we are in
# (i.e. redis-deployments/... -> 'redis')
sub deployment_suffix {
	my $config = LoadFile(".genesis/config");
	die "No deployment type defined in .genesis/config." unless $config->{deployment_type};
	return $config->{deployment_type};
}

sub base_yaml_files {
	my ($env) = @_;
	my $type = deployment_suffix;
	my $dir = workdir;
	open my $fh, ">", "$dir/base.yml";
	print $fh <<EOF;
meta:
  vault: (( concat "secret/" params.vault || "nowhere" ))
params:
  name: (( concat params.env "-$type" ))
name: (( grab params.name ))
EOF
	close $fh;
	return "$dir/base.yml";
}

sub merge_files {
	my ($env, $options) = @_;

	my @files = ();
	push @files, base_yaml_files($env);
	push @files, kit_yaml_files($env);
	push @files, mergeable_yaml_files($env);
	push @files, grep { $_ } $options->{'cloud-config'};
	return \@files;
}

sub merge_manifest {
	my ($file, $options) = @_;
	$file =~ s/(\.yml)?$/.yml/;

	my @prunables = qw/meta pipeline params kit compilation/;
	push @prunables, qw/resource_pools disk_pools
	                    networks vm_types disk_types
	                    azs vm_extensions/
		unless $options->{'create-env'};

	if ($options->{'create-env'}) {
		my $dir = workdir;
		write_stemcell_data("$dir/cloud.yml");
		$options->{'cloud-config'} = "$dir/cloud.yml";
	}

	return spruce_merge({
			prune => [@prunables],
		},
		@{merge_files($file, $options)});
}

sub deploy_manifest {
	my ($env, $options) = @_;
	$ENV{REDACT} = '';
	my $dir = workdir;
	my $target = '';
	my $create_env = is_create_env($env);

	if (!$create_env) {
		$target = bosh_target_for($env);
		bosh_download_cloud_config($target, "$dir/cloud.yml");
		$options->{'cloud-config'} = "$dir/cloud.yml";
	} else {
		$ENV{OFFLINE} = 1; # set offline since there's no director to talk to
	}

	my $merge_opts = {
		'cloud-config' => $options->{'cloud-config'},
		'create-env'   => $create_env,
	};
	mkfile_or_fail("$dir/manifest.yml", merge_manifest($env, $merge_opts));
	my $deployment = get_key($env, "params.name");
	if (!$deployment) {
		my $deployment_prefix = get_key($env, 'params.env');
		$env =~ s/.yml$//;
		$deployment_prefix ||= $env;
		$deployment = "$deployment_prefix-" . deployment_suffix;
	}

	mkdir_or_fail(".genesis/manifests");

	$ENV{REDACT} = 'true';
	mkfile_or_fail(".genesis/manifests/$env.yml", merge_manifest($env, $merge_opts));

	if ($create_env) {
		$target = "create-env";
		$deployment = ".genesis/manifests/$env-state.yml";
	}
	my @deploy_opts;
	push @deploy_opts, "--$_"                for grep {$options->{$_}} qw/fix recreate dry-run/;
	push @deploy_opts, "--no-redact"         if  !$options->{redact};
	push @deploy_opts, "--skip-drain=$_"     for @{$options->{'skip-drain'} || []};
	push @deploy_opts, "--$_=$options->{$_}" for grep {defined $options->{$_}} qw/canaries max-in-flight/;
	return bosh_deploy $target, $deployment, "$dir/manifest.yml", @deploy_opts;
}

sub curl {
	my ($method, $url, $headers, $data, $skip_verify, $creds) = @_;
	my @flags = ("-X", $method);
	push @flags, "-H", "$_: $headers->{$_}" for (keys %$headers);
	push @flags, "-d", $data                if  $data;
	push @flags, "-k"                       if  ($skip_verify);
	push @flags, "-u", $creds               if  ($creds);
	push @flags, "-v"                       if  (envset('GENESIS_DEBUG'));
	my $status = "";
	my $status_line = "";
	my @data = Genesis::Run::getlines('curl', '-isL', $url, @flags);
	unless (scalar(@data) && $? == 0) {
		Genesis::Run::interact('curl', '-L', $url, @flags); # curl again to get stdout/err into concourse for debugging
		return 599, "Unable to execute curl command", "";
	}
	while (my $line = shift @data) {
		if ($line =~ m/^HTTP\/\d+\.\d+\s+((\d+)(\s+.*)?)$/) {
			$status_line = $1;
			$status = $2;
		}
		# curl -iL will output a second set of headers if following links
		if ($line =~ /^\s+$/ && $status !~ /^3\d\d$/) {
			last;
		}
	}
	return $status, $status_line, join("", @data);
}

###########################################################################

sub vault_auth {
	my %options = @_;
	for (qw/vault skip_verify secret_id role_id/) {
		next if exists $options{$_} and defined $options{$_};
		die "vault_auth() requires the '$_' argument; please file a bug.\n";
	}

	my ($code, $msg, $data) = curl "POST", "$options{vault}/v1/auth/approle/login", {
			'Content-type' => 'application/json',
		},
		encode_json({
			role_id => $options{role_id},
			secret_id  => $options{secret_id},
		}), $options{skip_verify};

	if ($code != 200) {
		die "Failed to authenticate to the Vault at $options{vault} using role ID $options{role_id}:\n".
			"HTTP $msg\n$data\n";
	}
	my $output;
	eval { $output = decode_json($data); 1 }
		or die "Invalid JSON received from the Vault at $options{vault}\n($data)\n";
	exists $output->{auth} and exists $output->{auth}{client_token}
		or die "No Client Token found in response from the Vault at $options{vault}\n($data)\n";

	$ENV{VAULT_TOKEN} = $output->{auth}{client_token};
	Genesis::Run::do_or_die(
		"Failed to authenticate to the Vault at $options{vault}\n:`vault status` said",
		"vault status"
	);

	Genesis::Run::do_or_die(
		"Failed to retrieve secret/handshake from the Vault at $options{vault}",
		"vault read secret/handshake"
	)
}

sub commit_changes {
	my ($indir, $outdir, $branch, $key, $message) = @_;

	# the below copying of files into new repos from older repos is all
	# done in the name of avoiding merge conflicts, or weird errors when
	# rebasing, and git discovers that there are no changes after you rebase

	# create an output git repo based off of latest origin/$branch
	Genesis::Run::check({interactive => 1}, 'cp -R "$1" "$2"', $indir, $outdir) or exit 1;
	pushd $outdir;

	# We need this here so we can do a manual pull after the build/deploy, but
	# prior to pushing. Rebasing inside the concourse resource will not work,
	# as we are changing files that are not watched by the resources. This may
	# cause conflicts as older commits try to change more and more things that
	# have already been updated in the .genesis/manifests directory.
	#
	my $tmp = workdir;
	mkdir_or_fail  "$tmp/home/.ssh", 0700;
	mkfile_or_fail "$tmp/home/.ssh/key", 0600, $key;
    mkfile_or_fail "$tmp/home/.ssh/config", <<EOF;
Host *
  StrictHostKeyChecking no
  UserKnownHostsFile /dev/null
  LogLevel QUIET
  IdentityFile $tmp/home/.ssh/key
EOF

	$ENV{GIT_AUTHOR_NAME}   ||= 'Concourse Bot';
	$ENV{GIT_AUTHOR_EMAIL}  ||= 'concourse@pipeline';
	$ENV{GIT_COMMITTER_NAME}  = $ENV{GIT_AUTHOR_NAME};
	$ENV{GIT_COMMITTER_EMAIL} = $ENV{GIT_AUTHOR_EMAIL};
	$ENV{GIT_ASKPASS}         = "/bin/false";
	$ENV{GIT_SSH_COMMAND}     = "ssh -F $tmp/home/.ssh/config";
	$ENV{HOME}                = "$tmp/home";

	# no need to fetch or pull from origin/$branch, as the git resource in the pipeline should
	# have the latest data from origin, we just need to reset to the newest applicable ref
	Genesis::Run::do_or_die(
		{interactive => 1, env =>{HOME => "$tmp/home"}},
		"Could not reset to the newest applicable ref in git",
		'git reset --hard "origin/${1}" && git checkout "$1" &&  git pull origin "$1"',
		$branch
	);
	popd;

	# find and copy all potential changes to the outdir
	pushd $indir;
	my @output = Genesis::Run::getlines('git status --porcelain');
	popd;
	my @changes = map { chomp; s/^...//; $_; } @output;
	for my $file (@changes) {
		mkdir_or_fail(dirname("$outdir/$file"));
		Genesis::Run::do_or_die(
			"Could not copy changed files to output directory",
			'cp -R "$1" "$2"', "$indir/$file", "$outdir/$file"
		)
	}

	# check if any changes actually exist in the outdir (potential changes may have alread
	# been tracked after $indir's commit, so they could disappear here), then commit them
	pushd $outdir;
	my $output = Genesis::Run::get('git status --porcelain');
	if ($output) {
		Genesis::Run::interact( # use interact because we want to capture the output live (concourse)
			{env => {HOME => "$tmp/home"}},
			'git add -A && '.
			'git status && '.
			'git --no-pager diff --cached && '.
			'git commit -m "$1"', "CI commit: $message"
		);
	}
}

sub read_pipeline {
	my ($file) = @_;

	my @errors = ();
	my $p = Load(spruce_merge($file));
	unless (exists $p->{pipeline}) {
		# fatal error
		push @errors, "Missing top-level 'pipeline:' key.";
		return $p, \@errors;
	}

	unless (ref($p->{pipeline}) eq 'HASH') {
		# fatal error
		push @errors, "Top-level 'pipeline:' key must be a map.";
		return $p, \@errors;
	}
	for (keys %{$p->{pipeline}}) {
		push @errors, "Unrecognized `pipeline.$_' key found."
			unless m/^(name|public|tagged|errands|vault|git|slack|hipchat|stride|email|boshes|task|layout|layouts|debug|stemcells|skip_upkeep|locker|unredacted)$/;
	}
	for (qw(name vault git boshes)) {
		push @errors, "`pipeline.$_' is required."
			unless $p->{pipeline}{$_};
	}

	# validate pipeline.vault.*
	if (ref($p->{pipeline}{vault}) ne 'HASH') {
		push @errors, "`pipeline.vault' must be a map.";
	} else {
		# required subkeys
		for (qw(url)) {
			push @errors, "`pipeline.vault.$_' is required."
				unless $p->{pipeline}{vault}{$_};
		}
		# allowed subkeys
		for (keys %{$p->{pipeline}{vault}}) {
			push @errors, "Unrecognized `pipeline.vault.$_' key found."
				unless m/^(url|role|secret|verify)$/;
		}
	}

	# validate pipeline.git.*
	if (ref($p->{pipeline}{git}) ne 'HASH') {
		push @errors, "`pipeline.git' must be a map.";
	} else {
		# required subkeys
		for (qw(owner repo private_key)) {
			push @errors, "`pipeline.git.$_' is required."
				unless $p->{pipeline}{git}{$_};
		}
		# allowed subkeys
		for (keys %{$p->{pipeline}{git}}) {
			push @errors, "Unrecognized `pipeline.git.$_' key found."
				unless m/^(host|owner|repo|private_key)$/;
		}
	}

	# validate stemcells
	if (! $p->{pipeline}{skip_upkeep}) {
		if (! $p->{pipeline}{stemcells}) {
			push @errors, "Neither `pipeline.skip_upkeep' nor `pipeline.stemcells' were configured. One or the other is required.";
		} elsif (ref($p->{pipeline}{stemcells}) ne 'HASH') {
			push @errors, "`pipeline.stemcells' must be a map.";
		}
	}

	# validate locker
	if ($p->{pipeline}{locker}) {
		if (ref($p->{pipeline}{locker}) ne 'HASH') {
			push @errors, "`pipeline.locker' must be a map.";
		} else {
			for (qw/url username password/) {
				push @errors, "`pipeline.locker.$_' is required."
					unless $p->{pipeline}{locker}{$_};
			}
			for (keys %{$p->{pipeline}{locker}}) {
				push @errors, "Unrecognized `pipeline.locker.$_' key found."
					unless m/^(url|username|password|ca_cert|skip_ssl_validation)/;
			}
		}
	} else {
		$p->{pipeline}{locker}{url} = "";
	}

	# validate notifications
	my $n = 0;
	for (qw(slack hipchat stride email)) {
		$n++ if exists $p->{pipeline}{$_};
	}
	if ($n == 0) {
		push @errors, "No notification stanzas defined.  Please define `pipeline.slack', `pipeline.hipchat', `pipeline.stride' or `pipeline.email'.\n";
	} else {
		if ($p->{pipeline}{slack}) {
			# validate pipeline.slack.*
			if (ref($p->{pipeline}{slack}) ne 'HASH') {
				push @errors, "`pipeline.slack' must be a map.";
			} else {
				# required subkeys
				for (qw(webhook channel)) {
					push @errors, "`pipeline.slack.$_' is required."
						unless $p->{pipeline}{slack}{$_};
				}
				# allowed subkeys
				for (keys %{$p->{pipeline}{slack}}) {
					push @errors, "Unrecognized `pipeline.slack.$_' key found."
						unless m/^(webhook|channel|username|icon)$/;
				}
			}
		}
		if ($p->{pipeline}{hipchat}) {
			# validate pipeline.hipchat.*
			if (ref($p->{pipeline}{hipchat}) ne 'HASH') {
				push @errors, "`pipeline.hipchat' must be a map.";
			} else {
				# required subkeys
				for (qw/room_id token/) {
					push @errors, "`pipeline.hipchat.$_' is required."
						unless $p->{pipeline}{hipchat}{$_};
				}
				# allowed subkeys
				for (keys %{$p->{pipeline}{hipchat}}) {
					push @errors, "Unrecognized `pipeline.hipchat.$_' key found."
						unless m/^(url|token|room_id|notify|username)$/;
				}
			}
		}
		if ($p->{pipeline}{stride}) {
			# validate pipeline.stride.*
			if (ref($p->{pipeline}{stride}) ne 'HASH') {
				push @errors, "`pipeline.stride' must be a map.";
			} else {
				# required subkeys
				for (qw/client_id client_secret cloud_id conversation/) {
					push @errors, "`pipeline.stride.$_' is required."
						unless $p->{pipeline}{stride}{$_};
				}
				# allowed subkeys
				for (keys %{$p->{pipeline}{stride}}) {
					push @errors, "Unrecognized `pipeline.stride.$_' key found."
						unless m/^(client_id|client_secret|cloud_id|conversation)$/;
				}
			}
		}
		if ($p->{pipeline}{email}) {
			# validate pipeline.email.*
			# FIXME: fully implement and test email notifications
			push @errors, "Email notifications are not fully implemented yet.";
			if (ref($p->{pipeline}{email}) ne 'HASH') {
				push @errors, "`pipeline.email' must be a map.";
			} else {
				# required subkeys
				for (qw(to from smtp)) {
					push @errors, "`pipeline.email.$_' is required."
						unless $p->{pipeline}{email}{$_};
				}
				# to must be a list...
				if (exists $p->{pipeline}{email}{to}) {
					if (ref($p->{pipeline}{email}{to}) ne 'ARRAY') {
						push @errors, "`pipeline.email.to' must be a list of addresses.";
					} else {
						if (@{$p->{pipeline}{email}{to}} == 0) {
							push @errors, "`pipeline.email.to' must contain at least one address.";
						}
					}
				}
				# allowed subkeys
				for (keys %{$p->{pipeline}{email}}) {
					push @errors, "Unrecognized `pipeline.email.$_' key found."
						unless m/^(to|from|smtp)$/;
				}
				if (ref($p->{pipeline}{email}{smtp}) eq 'HASH') {
					# required sub-subkeys
					for (qw(host username password)) {
						push @errors, "`pipeline.email.smtp.$_' is required."
							unless $p->{pipeline}{email}{smtp}{$_};
					}
					# allowed subkeys
					for (keys %{$p->{pipeline}{email}{smtp}}) {
						push @errors, "Unrecognized `pipeline.email.smtp.$_' key found."
							unless m/^(host|port|username|password)$/;
					}
				} else {
				}
			}
		}
	}

	# validate (optional) pipeline.task.*
	if (exists $p->{pipeline}{task}) {
		if (ref($p->{pipeline}{task}) eq 'HASH') {
			# allowed subkeys
			for (keys %{$p->{pipeline}{task}}) {
				push @errors, "Unrecognized `pipeline.task.$_' key found."
					unless m/^(image|version)$/;
			}
		} else {
			push @errors, "`pipeline.task' must be a map.";
		}
	}

	# validate layouts
	my $key = undef; # for better messaging, later
	if (exists $p->{pipeline}{layout} && exists $p->{pipeline}{layouts}) {
		push @errors, "Both `pipeline.layout' and `pipeline.layouts' (plural) specified.  Please pick one or the other.";
	} elsif (exists $p->{pipeline}{layout}) {
		$p->{pipeline}{layouts}{default} = $p->{pipeline}{layout};
		delete $p->{pipeline}{layout};
		$key = 'pipeline.layout'; # we're pretending the user did it correctly.
	}
	if (ref($p->{pipeline}{layouts}) eq 'HASH') {
		for (keys %{$p->{pipeline}{layouts}}) {
			if (ref($p->{pipeline}{layouts}{$_})) {
				my $k = $key || "pipeline.layouts.$_";
				push @errors, "`$k' must be a string.";
			}
		}
	} else {
		push @errors, "`pipeline.layouts' must be a map.";
	}

	# validate BOSH directors
	if (ref($p->{pipeline}{boshes}) eq 'HASH') {
		for my $env (keys %{$p->{pipeline}{boshes}}) {
			# required sub-subkeys
			if (is_create_env($env)) {
				# allowed subkeys for a create-env deploy
				for (keys %{$p->{pipeline}{boshes}{$env}}) {
					push @errors, "Unrecognized `pipeline.boshes[$env].$_' key found."
						unless m/^(alias)$/;
				}
			} else {
				for (qw(url ca_cert username password)) {
					push @errors, "`pipeline.boshes[$env].$_' is required."
						unless $p->{pipeline}{boshes}{$env}{$_};
				}
				# allowed subkeys
				for (keys %{$p->{pipeline}{boshes}{$env}}) {
					push @errors, "Unrecognized `pipeline.boshes[$env].$_' key found."
						unless m/^(stemcells|url|ca_cert|username|password|alias)$/;
				}
			}

			if (! $p->{pipeline}{skip_upkeep}) {
				unless (is_create_env($env)) {
					if (! $p->{pipeline}{boshes}{$env}{stemcells}) {
						push @errors, "No stemcells specified for `pipeline.boshes[$env]' and `pipeline.skip_upkeep' not enabled.";
					} elsif (ref($p->{pipeline}{boshes}{$env}{stemcells}) ne 'ARRAY') {
						push @errors, "`pipeline.boshes[$env].stemcells' is not an array";
					} else {
						for (@{$p->{pipeline}{boshes}{$env}{stemcells}}) {
							push @errors, "`pipeline.boshes[$env].stemcells.$env' is not a stemcell alias listed in `pipeline.stemcells'"
								unless $p->{pipeline}{stemcells}{$_};
						}
					}
				}
			}
		}
	}

	return $p, @errors;
}

sub parse_pipeline {
	my ($file, $layout) = @_;
	my ($pipeline, @errors) = read_pipeline($file);
	if (@errors) {
		error "#R{ERRORS encountered} in pipeline definition in #Y{$file}:";
		error "  - #R{$_}" for @errors;
		exit 1;
	}

	my $src = $pipeline->{pipeline}{layouts}{$layout}
		or die "No such layout `${layout}'\n";

	# our internal representation
	my $P = $pipeline;
	$P->{file} = $file;  # the path to the original pipeline file,
	                     # which we need to merge in with the guts.yml
	                     # definition to get the final configuration.

	$P->{auto} = [];     # list of patterns that match environments
	                     # we want concourse to trigger automatically.

	$P->{envs} = [];     # list of all environment names seen in the
	                     # configuration, to be used for validation.

	$P->{will_trigger} = {}; # map of (A -> [B, C, D]) triggers, where A triggers
	                         # a deploy (or notification) of B, C, and D.  Note that
	                         # the values are lists, because one environment
	                         # can trigger multiple other environments.
	$P->{triggers} = {};     # map of B -> A where B was a deploy triggered
	                         # by a successful deploy of A. Only one environment
	                         # can have triggered each given environment

	# handle yes/no/y/n/true/false/1/0 in our source YAML.
	$P->{pipeline}{tagged}     = yaml_bool($P->{pipeline}{tagged}, 0);
	$P->{pipeline}{public}     = yaml_bool($P->{pipeline}{public}, 0);
	$P->{pipeline}{unredacted} = yaml_bool($P->{pipeline}{unredacted}, 0);

	# some default values, if the user didn't supply any
	$P->{pipeline}{vault}{role}   ||= "";
	$P->{pipeline}{vault}{secret} ||= "";
	$P->{pipeline}{vault}{verify} = yaml_bool($P->{pipeline}{vault}{verify}, 1);

	$P->{pipeline}{task}{image}   ||= 'starkandwayne/concourse';
	$P->{pipeline}{task}{version} ||= 'latest';

	# NOTE that source-level mucking about via regexen obliterates
	# all of the line and column information we would expect from
	# a more traditional parser.  If it becomes important to report
	# syntax / semantic errors with line information, this whole
	# parser has to be gutted and re-written.

	$src =~ s/\s*#.*$//gm;   # remove comments (without strings, this is fine)
	$src =~ s/[\r\n]+/ ; /g; # collapse newlines into ';' terminators
	$src =~ s/(^\s+|\s+$)//; # strip leading and trailing whitespace

	# condense the raw stream of tokens into a list or rules,
	# where each rule is itself a list of the significant tokens
	# between two terminators (or begining of file and a terminator)
	#
	# i.e.
	#   [['auto', 'sandbox*'],
	#    ['auto', 'preprod*'],
	#    ['tagged'],
	#    ['sandbox-a', '->', 'sandbox-b']]
	#
	# this structure is designed to be easier to interpret individual
	# rules from, since we can assert against arity and randomly access
	# tokens (i.e. a trigger rule must have '->' at $rule[1]).
	#
	my @rules = ();
	my $rule = [];
	for my $tok (split /\s+/, "$src ;") {
		$tok or die "'$tok' was empty in [$src]!\n";
		if ($tok eq ';') {
			if (@$rule) {
				push @rules, $rule;
				$rule = [];
			}
			next;
		}
		push @$rule, $tok;
	}

	my @auto; # patterns; we'll expand them once we have all the
	          # environments, and then populate $P->{auto};
	my %envs; # de-duplicating map; keys will become $P->{envs}
	for $rule (@rules) {
		my ($cmd, @args) = @$rule;
		if ($cmd eq 'auto') {
			die "The 'auto' directive requires at least one argument.\n"
				unless @args;
			push @auto, @args;
			next;
		}

		# Anything that is not a command must be a pipeline
		if ($P->{pipeline}{boshes}{$cmd}) {
			# Pipeline definition: env [ -> env]*
			my $orig = join ' ', @$rule;
			my ($env, $token);
			while (@$rule) {
				($env, $token, @$rule) = @$rule;
				die "Unknown environment '$env' in pipeline definition '$orig'\n"
					unless ($P->{pipeline}{boshes}{$cmd});
				$envs{$env} = 1;
				if (defined($token)) {
					die "Invalid pipeline definition '$orig': expecting '<env> [-> <env>]...'.\n"
						unless $token eq '->';
					my $target =  $rule->[0];
					die "Missing target after -> in pipeline definition '$orig'\n"
						unless $target;
					push @{$P->{will_trigger}{$env}}, $target;
				}
			}
			next;
		}
		die "Unrecognized environment or configuration directive:  '$cmd'.\n";
	}
	$P->{envs} = [keys %envs];
	$P->{aliases} = { map { $_ => ($P->{pipeline}{boshes}{$_}{alias} || $_) } keys %envs};

	%envs = (); # we'll reuse envs for auto environment de-duplication
	for my $pattern (@auto) {
		my $regex = $pattern;
		$regex =~ s/\*/.*/g;
		$regex = qr/^$regex$/;

		my $n = 0;
		for my $env (@{$P->{envs}}) {
			if ($env =~ $regex) {
				$envs{$env} = 1;
				$n++;
			}
		}
		if ($n == 0) {
			error "#Y{warning}: rule `auto $pattern' did not match any environments...\n";
		}
	}
	$P->{auto} = [keys %envs];

	# make sure we have a BOSH director for each seen environment.
	# (thanks to read_pipeline, we know any extant BOSH director configs are good)
	for my $env (@{$P->{envs}}) {
		die "No BOSH director configuration found for $env (at `pipeline.boshes[$env]').\n"
			unless $P->{pipeline}{boshes}{$env};
	}

	# figure out who triggers each environment.
	# this is an inversion of the directed acyclic graph that we
	# are storing in {triggers}.
	#
	# this means that it is illegal for a given environment to be
	# triggererd by more than one other environment.  this decision
	# was made to simplify implementation, and was deemed to not
	# impose overly much on desired pipeline structure.
	my $triggers = {};
	for my $a (keys %{$P->{will_trigger}}) {
		for my $b (@{$P->{will_trigger}{$a}}) {
			# $a triggers $b, that is $b won't deploy unti we
			# see a successful deploy (+test) of the $a environment
			die "Environment '$b' is already being triggered by environment '$triggers->{$b}'.\nIt is illegal to trigger an environment more than once.\n"
				if $triggers->{$b} and $triggers->{$b} ne $a;
			$triggers->{$b} = $a;
		}
	}
	$P->{triggers} = $triggers;

	return $P;
}

# FYI: we use quasi-JSON here, so we don't need to care about our indent level when consuming
#      the notification definitions
sub gen_notifications {
	my ($pipeline, $message, $alias) = @_;
	$alias = "" unless defined $alias;
	my $notification = "aggregate: [\n";
	if ($pipeline->{pipeline}{slack}) {
		$notification .= <<EOF;
{
  put: "slack",
  params: {
    channel: "(( grab pipeline.slack.channel ))",
    username: "(( grab pipeline.slack.username ))",
    icon_url: "(( grab pipeline.slack.icon ))",
    text: '(( concat pipeline.name ": $message" ))'
  }
},
EOF
	}
	if ($pipeline->{pipeline}{hipchat}) {
		$notification .= <<EOF;
{
  put: "hipchat",
  params: {
    from: "(( grab pipeline.hipchat.username ))",
    color: "gray",
    message: '(( concat pipeline.name ": $message" ))',
    notify: "(( grab pipeline.hipchat.notify ))"
  }
},
EOF
	}
	if ($pipeline->{pipeline}{stride}) {
		$notification .= <<EOF;
{
  put: "stride",
  params: {
    conversation: "(( grab pipeline.stride.conversation ))",
    message: '(( concat pipeline.name ": $message" ))'
  }
},
EOF
	}
	if ($pipeline->{pipeline}{email}) {
		$notification .= <<EOF;
{
  do: [
  { get: build-email-$alias },
  { task: write-email-body,
    config: {
      platform: linux,
      image_resource: {
        type: docker-image,
        source: {
          repository: ubuntu,
        },
      },

      inputs: [
        { name: build-email-$alias },
        { name: out },
      ],
      outputs: [
        { name: email },
      ],

      run: {
        path: build-email-$alias/run,
        args: [],
      },
    },
  },

  { put: email,
    params: {
      body:    email/body,
      headers: email/header,
      subject: email/subject,
    },
  }]
}
EOF
	}
	$notification .= "]";
	return $notification;
}

sub generate_pipeline_concourse_yaml {
	my ($pipeline) = @_;
	my $dir = workdir;
	open my $OUT, ">", "$dir/guts.yml"
		or die "Failed to generate Concourse Pipeline YAML configuration: $!\n";

	# Figure out what environments auto-trigger, and what don't
	my %auto = map { $_ => 1 } @{$pipeline->{auto}};

	# Determine what stemcells are being tracked
	my @stemcells = ();
	unless ($pipeline->{pipeline}{skip_upkeep}) {
		@stemcells = map { { name => $pipeline->{pipeline}{stemcells}{$_}, alias => $_ } } keys %{$pipeline->{pipeline}{stemcells}}
	}

	# CONCOURSE: pipeline (+params) {{{
	print $OUT <<'EOF';
---
pipeline:
  git:
    user:        git
    host:        github.com
    uri:         (( concat pipeline.git.user "@" pipeline.git.host ":" pipeline.git.owner "/" pipeline.git.repo ))
    owner:       (( param "Please specify the name of the user / organization that owns the Git repository" ))
    repo:        (( param "Please specify the name of the Git repository" ))
    branch:      master
    private_key: (( param "Please generate an SSH Deployment Key and install it into Github (with write privileges)" ))

EOF

	if ($pipeline->{pipeline}{slack}) {
		print $OUT <<'EOF';
  slack:
    webhook:  (( param "Please provide a Slack Integration WebHook." ))
    channel:  (( param "Please specify the channel (#name) or user (@user) to send messages to." ))
    username: runwaybot
    icon:     http://cl.ly/image/3e1h0H3H2s0P/concourse-logo.png
EOF
	}
	if ($pipeline->{pipeline}{hipchat}) {
		print $OUT <<'EOF';
  hipchat:
    url:      http://api.hipchat.com
    room_id:  (( param "Please specify the room ID that Concourse should send HipChat notifications to" ))
    token:    (( param "Please specify the HipChat authentication token" ))
    notify:   false
    username: runwaybot
EOF
	}
	if ($pipeline->{pipeline}{stride}) {
		print $OUT <<'EOF';
  stride:
    client_id: (( param "Please specify the client ID for the Stride app that Concourse should send notifications as" ))
    client_secret: (( param "Please specify the client secret for the Stride app that Concourse should send notifications as" ))
    cloud_id: (( param "Please specify the Stride cloud ID that Concourse should send notifications to" ))
    conversation: (( param "Please specify the Stride conversation name that Concourse should send notifications to" ))
EOF
	}
	if ($pipeline->{pipeline}{email}) {
		print $OUT <<'EOF';
  email:
    to:   (( param "Please provide a list of email addresses to send 'Pending Deployment' notifications to." ))
    from: (( param "Please specify a 'From:' account (an email address).  Email will be sent from this address." ))
    smtp:
      username: (( param "Please provide a username to authenticate against your Mail Server (SMTP) host." ))
      password: (( param "Please provide a password to authenticate against your Mail Server (SMTP) host." ))
      host:     (( param "Please specify the FQDN or IP address of your Mail Server (SMTP) host." ))
      port:     587
EOF
	}
	if ($pipeline->{pipeline}{locker}{url}) {
		print $OUT <<'EOF';
  locker:
    url:                 (( param "Please provide the URI to the locker API" ))
    username:            (( param "Please provide the locker API username" ))
    password:            (( param "Please provide the locker API password" ))
    # FIXME until we have service discovery (bosh dns) to reliably know the
    #       locker hostname, and have a ca_cert generated in the concourse kit,
    #       we need to turn on skip_ssl_validation, and nullify the ca_cert by default
    ca_cert:             ~
    skip_ssl_validation: true

EOF
	}
	# }}}
	# CONCOURSE: groups, and resource configuration {{{
	print $OUT <<EOF;
groups:
  - name: $pipeline->{pipeline}{name}
    jobs:
EOF
	print $OUT "    - $_\n" for sort map { "$pipeline->{aliases}{$_}-" . deployment_suffix } @{$pipeline->{envs}};
	print $OUT "    - notify-$_-changes\n" for sort map { "$pipeline->{aliases}{$_}-" . deployment_suffix }
		grep { ! $auto{$_} } @{$pipeline->{envs}};

	print $OUT <<EOF;

resources:
  - name: git
    type: git
    source:
      branch:      (( grab pipeline.git.branch ))
      private_key: (( grab pipeline.git.private_key ))
      uri:         (( grab pipeline.git.uri ))
EOF
	for (@stemcells) {
		print $OUT <<EOF;
  - name: $_->{alias}-stemcell
    type: bosh-io-stemcell
    source: { name: $_->{name} }
EOF
	}
   # }}}
	# CONCOURSE: env-specific resource configuration {{{
	for my $env (sort @{$pipeline->{envs}}) {
		# YAML snippets, to make the print's less obnoxious {{{
		#
		# 1) do we tag the jobs so that they are constrained to a
		#   specific subset of concourse workers? ('tagged' directive)
		my $tag_yaml = $pipeline->{pipeline}{tagged} ? "tags: [$env]" : "";

		my $alias = $pipeline->{aliases}{$env};
		print $OUT <<EOF;
  - name: ${alias}-changes
    type: git
    source:
      .: (( inject resources.git.source ))
      paths:
EOF
		# watch the common files in our predecessor cache - for example,
		# if us-west-1-sandbox-a triggers us-west-1-preprod-a, then
		# preprod-a would watch the cache of sandbox-a for:
		#
		#    us.yml
		#    us-west.yml
		#    us-west-1.yml
		#
		# and it would only check the top-level root for it's own files:
		#
		#    us-west-1-preprod.yml
		#    us-west-1-preprod-a.yml
		#
		if ($pipeline->{triggers}{$env}) {
			my $trigger = $pipeline->{triggers}{$env};
			my ($pre, @unique) = unique_suffix($trigger, $env);
			$pre = "$pre-" unless $pre eq "";
			for (map { "$pre$_" } expand_tokens(@unique)) {
				print $OUT <<EOF;
        - ${_}.yml
EOF
			}
			print $OUT <<EOF;

  - name: ${alias}-cache
    type: git
    source:
      .: (( inject resources.git.source ))
      paths:
        - .genesis/bin/genesis
        - .genesis/kits
        - .genesis/config
EOF
			print $OUT "# $trigger -> $env\n";
			for (expand_tokens(common_base($env, $trigger))) {
				print $OUT <<EOF;
        - .genesis/cached/${trigger}/${_}.yml
EOF
			}
		} else {
			print $OUT <<EOF;
        - .genesis/bin/genesis
        - .genesis/kits
        - .genesis/config
EOF
			for (expand_tokens(split /-/, $env)) {
				print $OUT <<EOF;
        - ${_}.yml
EOF
			}
		}
		unless (is_create_env($env)) {
			print $OUT <<EOF;

  - name: ${alias}-cloud-config
    type: bosh-config
    $tag_yaml
    source:
      target: $pipeline->{pipeline}{boshes}{$env}{url}
      client: $pipeline->{pipeline}{boshes}{$env}{username}
      client_secret: $pipeline->{pipeline}{boshes}{$env}{password}
      ca_cert: |
EOF
			for (split /\n/, $pipeline->{pipeline}{boshes}{$env}{ca_cert}) {
				print $OUT <<EOF;
         $_
EOF
			}
			print $OUT <<EOF;
      config: cloud

  - name: ${alias}-runtime-config
    type: bosh-config
    $tag_yaml
    source:
      target: $pipeline->{pipeline}{boshes}{$env}{url}
      client: $pipeline->{pipeline}{boshes}{$env}{username}
      client_secret: $pipeline->{pipeline}{boshes}{$env}{password}
      ca_cert: |
EOF
			for (split /\n/, $pipeline->{pipeline}{boshes}{$env}{ca_cert}) {
				print $OUT <<EOF;
        $_
EOF
			}
			print $OUT <<EOF;
      config: runtime

EOF
		}
		if ($pipeline->{pipeline}{locker}{url}) {
			my $deployment_suffix = deployment_suffix;
			unless (is_create_env($env)) {
				my $bosh_lock = $env;
				if ($pipeline->{pipeline}{boshes}{$env}{url} && $pipeline->{pipeline}{boshes}{$env}{url} =~ m|https?://(.*)?:(.*)|) {
					my $addr = gethostbyname($1);
					$bosh_lock = inet_ntoa($addr) . ":" . $2;
				}

				# <alias>-stemcell-lock is used to not upload the same stemcell to the same bosh multiple
				# times - not necessary for create-env
				# <alias>-bosh-lock is used to prevent the parent bosh from upgrading while we deploy
				# - not necessary for create-env
				unless ($pipeline->{pipeline}{skip_upkeep}) {
					print $OUT <<EOF;
  - name: ${alias}-stemcell-lock
    type: locker
    $tag_yaml
    source:
      locker_uri: (( grab pipeline.locker.url ))
      username: (( grab pipeline.locker.username ))
      password: (( grab pipeline.locker.password ))
      skip_ssl_validation: (( grab pipeline.locker.skip_ssl_validation ))
      ca_cert: (( grab pipeline.locker.ca_cert ))
      lock_name: ${bosh_lock}-stemcell-lock

EOF
				}
				print $OUT <<EOF;
  - name: ${alias}-bosh-lock
    type: locker
    $tag_yaml
    source:
      locker_uri: (( grab pipeline.locker.url ))
      username: (( grab pipeline.locker.username ))
      password: (( grab pipeline.locker.password ))
      skip_ssl_validation: (( grab pipeline.locker.skip_ssl_validation ))
      ca_cert: (( grab pipeline.locker.ca_cert ))
      bosh_lock: $pipeline->{pipeline}{boshes}{$env}{url}
EOF
			}
			print $OUT <<EOF;
  - name: ${alias}-deployment-lock
    type: locker
    $tag_yaml
    source:
      locker_uri: (( grab pipeline.locker.url ))
      username: (( grab pipeline.locker.username ))
      password: (( grab pipeline.locker.password ))
      skip_ssl_validation: (( grab pipeline.locker.skip_ssl_validation ))
      ca_cert: (( grab pipeline.locker.ca_cert ))
      lock_name:  ${env}-${deployment_suffix}

EOF
		}
	}
	# }}}
	# CONCOURSE: notification resource configuration {{{
	if ($pipeline->{pipeline}{slack}) {
		print $OUT <<'EOF';
  - name: slack
    type: slack-notification
    source:
      url: (( grab pipeline.slack.webhook ))

EOF
	}
	if ($pipeline->{pipeline}{hipchat}) {
		print $OUT <<'EOF';
  - name: hipchat
    type: hipchat-notification
    source:
      hipchat_server_url: (( grab pipeline.hipchat.url ))
      room_id:  (( grab pipeline.hipchat.room_id ))
      token:    (( grab pipeline.hipchat.token ))
EOF
	}
	if ($pipeline->{pipeline}{stride}) {
		print $OUT <<'EOF';
  - name: stride
    type: stride-notification
    source:
      client_id: (( grab pipeline.stride.client_id ))
      client_secret: (( grab pipeline.stride.client_secret ))
      cloud_id: (( grab pipeline.stride.cloud_id ))
EOF
	}
	if ($pipeline->{pipeline}{email}) {
		print $OUT <<'EOF';
  - name: build-email-changes-staged
    type: script
    source:
      filename: run
      body: |
        #!/bin/bash
        mkdir -p email
        rm -rf email/*
        echo "X-Concourse-Site-Env: ${CI_SITE_ENV}" >>email/header
        head -n1 out/notif > email/subject
        sed -e 's/\`\`\`//' out/notif > email/body
  - name: build-email-success
    .: (( inject resources.build-email-changes-staged ))
  - name: build-email-failure
    .: (( inject resources.build-email-changes-staged ))

  - name: email
    type: email
    source:
      to:   (( grab pipeline.email.to ))
      from: (( grab pipeline.email.from ))
      smtp:
        host:     (( grab pipeline.email.smtp.host ))
        port:     (( grab pipeline.email.smtp.port ))
        username: (( grab pipeline.email.smtp.username ))
        password: (( grab pipeline.email.smtp.password ))
EOF
	}
	# }}}
	# CONCOURSE: resource types {{{
	print $OUT <<'EOF';
resource_types:
  - name: script
    type: docker-image
    source:
      repository: cfcommunity/script-resource

  - name: email
    type: docker-image
    source:
      repository: pcfseceng/email-resource

  - name: slack-notification
    type: docker-image
    source:
      repository: cfcommunity/slack-notification-resource

  - name: hipchat-notification
    type: docker-image
    source:
      repository: cfcommunity/hipchat-notification-resource

  - name: stride-notification
    type: docker-image
    source:
      repository: starkandwayne/stride-notification-resource

  - name: bosh-config
    type: docker-image
    source:
      repository: cfcommunity/bosh-config-resource

  - name: locker
    type: docker-image
    source:
      repository: cfcommunity/locker-resource

EOF
	# }}}
	print $OUT <<EOF;
jobs:
EOF
	for my $env (sort @{$pipeline->{envs}}) {
		# CONCOURSE: env-specific job configuration {{{

		# YAML snippets, to make the print's less obnoxious {{{
		#
		# 1) do we tag the jobs so that they are constrained to a
		#   specific subset of concourse workers? ('tagged' directive)
		my $tag_yaml = $pipeline->{pipeline}{tagged} ? "tags: [$env]" : "";

		# 2) Are we auto-triggering this environment?
		my $trigger = $auto{$env} ? "true" : "false";

		# 3) what is our deployment suffix?
		my $deployment_suffix = deployment_suffix;

		# 4) what previous (triggering) job/env do we need to wait
		#    on for our cached configuration changes
		my $passed =$pipeline->{triggers}{$env} ? $pipeline->{triggers}{$env} : "";
		my $passed_alias = $passed ? "$pipeline->{aliases}{$passed}-$deployment_suffix" : "";

		# 5) Alias of environment for concourse readabilitys
		my $alias = $pipeline->{aliases}{$env};

		# 6) If we have a previous environment, generate input definition
		#    too look at our cache
		my $cache_yaml = "";
		if ($pipeline->{triggers}{$env}) {
			if ($trigger eq "true") {
				$cache_yaml = "- { get: $alias-cache, passed: [$passed_alias], trigger: true }";
			} else {
				$cache_yaml = "- { get: $alias-cache, passed: [notify-$alias-$deployment_suffix-changes], trigger: false }";
			}
		}
		my $notify_cache = $pipeline->{triggers}{$env} ?
			"- { get: $alias-cache, passed: [$passed_alias], trigger: true }" : "";

		# 7) If we don't auto-trigger, we should use passed as our notify resource
		#    otherwise, use the live value
        my $changes_yaml = $trigger eq "true" ?
			"- { get: $alias-changes, trigger: true }" :
			"- { get: $alias-changes, trigger: false, passed: [notify-$alias-$deployment_suffix-changes]}";

		# 8) Build notifications for non-automatic deployments that sense changes
		my $changes_staged_notification = gen_notifications($pipeline,
			"Changes are staged to be deployed to $env-$deployment_suffix, " .
			"please schedule + run a deploy via Concourse", "changes-staged");

		# 9) Build notifications for failed deployments
		my $deployment_failure_notification = gen_notifications($pipeline,
			"Concourse deployment to $env-$deployment_suffix failed", "failure");

		# 10) Build notifications for successful deployments
		my $deployment_success_notification = gen_notifications($pipeline,
			"Concourse successfully deployed $env-$deployment_suffix", "success");

		# 11) notifications for stemcell upload success
		my $stemcell_success_notification = gen_notifications($pipeline,
			"New stemcells have been uploaded to the $env BOSH", "success");
		# 12) notifications for stemcell upload failure
		my $stemcell_failure_notification = gen_notifications($pipeline,
			"Failed uploading new stemcells to the $env BOSH", "failure");

		# 13) directory to find the genesis binary in (use previous env cache if present, else local-changes
		my $genesis_bindir = $passed ? "$alias-cache" : "$alias-changes";

		# }}}

		if ($trigger eq "false" ) {
			# notify job for non-automatic deploys {{{
			print $OUT <<EOF;
  - name: notify-$alias-$deployment_suffix-changes
    public: true
    serial: true
    plan:
    - aggregate:
      - { get: $alias-changes, trigger: true }
EOF
			unless (is_create_env($env)) {
				print $OUT <<EOF;
      - get: $alias-cloud-config
        $tag_yaml
        trigger: true
      - get: $alias-runtime-config
        $tag_yaml
        trigger: true
EOF
			}
			print $OUT <<EOF;
      $notify_cache
EOF
			unless ($pipeline->{pipeline}{skip_upkeep}) {
				for (@{$pipeline->{pipeline}{boshes}{$env}{stemcells}}) {
					print $OUT <<EOF;
      - get: $_-stemcell
        trigger: true
        params: { tarball: true }
EOF
				}
			}
			print $OUT <<EOF;
    - $changes_staged_notification
EOF
		}
		# }}}
		print $OUT <<EOF;
  - name: $alias-$deployment_suffix
    public: true
    serial: true
    plan:
    - on_failure:
        $deployment_failure_notification
      on_success:
        $deployment_success_notification
EOF
		if ($pipeline->{pipeline}{locker}{url}) {
			print $OUT <<EOF;
      ensure:
        do:
EOF
			unless (is_create_env($env)) {
				# <alias>-bosh-lock is used to prevent the parent bosh from upgrading while we deploy
				# - not necessary for create-env
				print $OUT <<EOF;
        - put: ${alias}-bosh-lock
          $tag_yaml
          params:
            lock_op: unlock
            key: dont-upgrade-bosh-on-me
            locked_by: ${alias}-${deployment_suffix}
EOF
			}
			print $OUT <<EOF;
        - put: ${alias}-deployment-lock
          $tag_yaml
          params:
            lock_op: unlock
            key: i-need-to-deploy-myself
            locked_by: ${alias}-${deployment_suffix}
EOF
		}
		print $OUT <<EOF;
      do:
EOF
		if ($pipeline->{pipeline}{locker}{url}) {
			unless (is_create_env($env)) {
				# <alias>-bosh-lock is used to prevent the parent bosh from upgrading while we deploy
				# - not necessary for create-env
				print $OUT <<EOF;
      - put: ${alias}-bosh-lock
        $tag_yaml
        params:
          lock_op: lock
          key: dont-upgrade-bosh-on-me
          locked_by: ${alias}-${deployment_suffix}
EOF
			}
			print $OUT <<EOF;
      - put: ${alias}-deployment-lock
        $tag_yaml
        params:
          lock_op: lock
          key: i-need-to-deploy-myself
          locked_by: ${alias}-${deployment_suffix}
EOF
		}
		print $OUT <<EOF;
      - aggregate:
EOF
		# only add cloud/runtime config on true-triggers, otherwise it goes in notifications
		# also make sure that we are not deploying with create-env (no cloud/runtime config for that scenario)
		if (! is_create_env($env) && $trigger eq "true") {
			print $OUT <<EOF;
        - get: $alias-cloud-config
          $tag_yaml
          trigger: true
        - get: $alias-runtime-config
          $tag_yaml
          trigger: true
EOF
		}
		unless ($pipeline->{pipeline}{skip_upkeep}) {
			for (@{$pipeline->{pipeline}{boshes}{$env}{stemcells}}) {
				print $OUT <<EOF;
        - get: $_-stemcell
          trigger: $trigger
          params: { tarball: true }
EOF
			}
		}
		print $OUT <<EOF;
        # genesis itself handles the propagation of files from successful environment
        # to the next. anything triggering env-changes should be considered to have passed
        # the previous environment, if in cached, and if not, should be triggered
        $changes_yaml
        $cache_yaml
EOF
		# Update stemcells unless we are create-env based or skip_upkeep requested {{{
		unless (is_create_env($env) || $pipeline->{pipeline}{skip_upkeep}) {
			if ($pipeline->{pipeline}{locker}{url}) {
				print $OUT <<EOF;
      - put: ${alias}-stemcell-lock
        $tag_yaml
        params:
          lock_op: lock
          key: ${alias}-${deployment_suffix}
EOF
			}
			print $OUT <<EOF;
      - task: upload-stemcells
        $tag_yaml
EOF
			if ($pipeline->{pipeline}{locker}{url}) {
				print $OUT <<EOF;
        ensure:
          put: ${alias}-stemcell-lock
          $tag_yaml
          params:
            lock_op: unlock
            key: ${alias}-${deployment_suffix}
EOF
			}
			print $OUT <<EOF;
        config:
          inputs:
            - name: $genesis_bindir
EOF
			for (@{$pipeline->{pipeline}{boshes}{$env}{stemcells}}) {
				print $OUT <<EOF;
            - name: $_-stemcell
              path: stemcells/$pipeline->{pipeline}{stemcells}{$_}
EOF
			}
			print $OUT <<EOF;
          outputs:
            - name: out
          platform: linux
          image_resource:
            type: docker-image
            source:
              repository: starkandwayne/concourse
          run:
            path: .genesis/bin/genesis
            args: [ ci-stemcells ]
            dir: $genesis_bindir
          params:
            STEMCELLS:            ../stemcells
            BOSH_ENVIRONMENT:     $pipeline->{pipeline}{boshes}{$env}{url}
            BOSH_NON_INTERACTIVE: true
            BOSH_CA_CERT: |
EOF
			for (split /\n/, $pipeline->{pipeline}{boshes}{$env}{ca_cert}) {
				print $OUT <<EOF;
              $_
EOF
			}
			print $OUT <<EOF;
            BOSH_CLIENT:        $pipeline->{pipeline}{boshes}{$env}{username}
            BOSH_CLIENT_SECRET: $pipeline->{pipeline}{boshes}{$env}{password}

EOF
			print $OUT <<EOF if $pipeline->{pipeline}{debug};
            DEBUG:              $pipeline->{pipeline}{debug}
EOF
		}
		#   }}}
		print $OUT <<EOF;
      - task: bosh-deploy
        $tag_yaml
        config:
          platform: linux
          image_resource:
            type: docker-image
            source:
              repository: $pipeline->{pipeline}{task}{image}
              tag:        $pipeline->{pipeline}{task}{version}
          params:
            CI_NO_REDACT:         $pipeline->{pipeline}{unredacted}
            CURRENT_ENV:          $env
            PREVIOUS_ENV:         $passed
            CACHE_DIR:            $alias-cache
            GIT_BRANCH:           (( grab pipeline.git.branch ))
            GIT_PRIVATE_KEY:      (( grab pipeline.git.private_key ))
            VAULT_ROLE_ID:        $pipeline->{pipeline}{vault}{role}
            VAULT_SECRET_ID:      $pipeline->{pipeline}{vault}{secret}
            VAULT_ADDR:           $pipeline->{pipeline}{vault}{url}
            VAULT_SKIP_VERIFY:    ${\(!$pipeline->{pipeline}{vault}{verify})}
            BOSH_NON_INTERACTIVE: true
EOF
		# don't supply bosh creds if we're create-env, because no one to talk to
		unless (is_create_env($env)) {
			print $OUT <<EOF;
            BOSH_ENVIRONMENT:     $pipeline->{pipeline}{boshes}{$env}{url}
            BOSH_CA_CERT: |
EOF
			for (split /\n/, $pipeline->{pipeline}{boshes}{$env}{ca_cert}) {
				print $OUT <<EOF;
              $_
EOF
			}
			print $OUT <<EOF;
            BOSH_CLIENT:        $pipeline->{pipeline}{boshes}{$env}{username}
            BOSH_CLIENT_SECRET: $pipeline->{pipeline}{boshes}{$env}{password}
EOF
		}
		print $OUT <<EOF if $pipeline->{pipeline}{debug};
            DEBUG:              $pipeline->{pipeline}{debug}
EOF
		print $OUT <<EOF;
            WORKING_DIR:        $alias-changes # work out of latest changes for this environment
            OUT_DIR:            out/git


          run:
            # run from inside the environment changes to get latest cache + regular data
            # but use the executable from genesis
            path: $genesis_bindir/.genesis/bin/genesis
            args: [ci-pipeline-deploy]
          inputs:
            - { name: $alias-changes } # deploy from latest changes
EOF
		print $OUT <<EOF if $passed;
            - { name: $alias-cache }
EOF
		print $OUT <<EOF;
          outputs:
            - { name: out }

        # push the deployment changes up to git, even if the deploy fails, to save
        # files for create-env + reflect "live" state
        ensure:
          put: git
          params:
            repository: out/git
EOF

		# CONCOURSE: run optional errands as tasks - non-create-env only (otherwise no bosh to run the errand) {{{
		unless (is_create_env($env)) {
			for my $errand_name (@{$pipeline->{pipeline}{errands}}) {
				print $OUT <<EOF;
        # run errands against the deployment
      - task: $errand_name-errand
        $tag_yaml
        config:
          platform: linux
          image_resource:
            type: docker-image
            source:
              repository: $pipeline->{pipeline}{task}{image}
              tag:        $pipeline->{pipeline}{task}{version}
          params:
            CI_NO_REDACT:       $pipeline->{pipeline}{unredacted}
            CURRENT_ENV:        $env
            ERRAND_NAME:        $errand_name

            BOSH_ENVIRONMENT:   $pipeline->{pipeline}{boshes}{$env}{url}
            BOSH_CA_CERT: |
EOF
			for (split /\n/, $pipeline->{pipeline}{boshes}{$env}{ca_cert}) {
				print $OUT <<EOF;
              $_
EOF
			}
			print $OUT <<EOF;
            BOSH_CLIENT:        $pipeline->{pipeline}{boshes}{$env}{username}
            BOSH_CLIENT:        $pipeline->{pipeline}{boshes}{$env}{username}
            BOSH_CLIENT_SECRET: $pipeline->{pipeline}{boshes}{$env}{password}
EOF
			print $OUT <<EOF if $pipeline->{pipeline}{debug};
            DEBUG:              $pipeline->{pipeline}{debug}
EOF
			print $OUT <<EOF;

          run:
            path: ../../$genesis_bindir/.genesis/bin/genesis
            dir:  out/git
            args: [ci-pipeline-run-errand]
          inputs:
            - name: out
            - name: $genesis_bindir
EOF
			}
		}
		# }}}
		print $OUT <<EOF;
      - task: generate-cache
        $tag_yaml
        config:
          inputs:
          - { name: out }
          - { name: $genesis_bindir }
          outputs:
          - { name: cache-out }
          run:
            path: $genesis_bindir/.genesis/bin/genesis
            args: [ci-generate-cache]
          params:
            CI_NO_REDACT:    $pipeline->{pipeline}{unredacted}
            CURRENT_ENV:     $env
            WORKING_DIR:     out/git
            OUT_DIR:         cache-out/git
            GIT_BRANCH:      (( grab pipeline.git.branch ))
            GIT_PRIVATE_KEY: (( grab pipeline.git.private_key ))
EOF

		print $OUT <<EOF if $pipeline->{pipeline}{debug};
            DEBUG:       $pipeline->{pipeline}{debug}
EOF
		print $OUT <<EOF;
          platform: linux
          image_resource:
            type: docker-image
            source:
              repository: $pipeline->{pipeline}{task}{image}
              tag:        $pipeline->{pipeline}{task}{version}
      - put: git
        params:
          repository: cache-out/git
EOF

		for my $push_env (@{$pipeline->{will_trigger}{$env}}) {
			print $OUT <<EOF;
      - put: $pipeline->{aliases}{$push_env}-cache
        params:
          repository: cache-out/git
EOF
		}
	# }}}
	}
	close $OUT;

	return spruce_merge({ prune => [qw(meta pipeline)] },
		"$dir/guts.yml", $pipeline->{file});
}

sub generate_pipeline_graphviz_source {
	my ($pipeline) = @_;
	my $out = "";
	open my $fh, ">", \$out;
	print $fh "digraph {\n";
	print $fh "  rankdir = LR; node [shape=none]; edge [color=\"#777777\",fontcolor=\"red\"];\n";

	my %auto = map { $_ => 1 } @{$pipeline->{auto}};
	for my $b (keys %{$pipeline->{triggers}}) {
		my $a = $pipeline->{triggers}{$b};
		(my $b1 = $b) =~ s/-/_/g;
		(my $a1 = $a) =~ s/-/_/g;
		print $fh "  $a1 [label=\"$a\"];\n";
		print $fh "  $b1 [label=\"$b\"];\n";
		if ($auto{$b}) {
			print $fh "  $a1 -> $b1;\n";
		} else {
			print $fh "  $a1 -> $b1 [label=\"manual\"];\n";
		}
	}


	print $fh "}\n";
	close $fh;
	return $out;
}

sub pipeline_tree {
	my ($prefix, $env, $trees) = @_;
	#
	# sandbox
	#  |--> preprod
	#  |     |--> prod
	#  |     |--> prod-2
	#  |     `--> some-prod
	#  |
	#  `--> other-preprod
	#        `--> other-prod
	#

	print "$env\n";
	my $n = @{$trees->{$env} || []};
	for my $kid (sort @{$trees->{$env} || []}) {
		$n--;
		if ($n) {
			print "$prefix  |--> ";
			pipeline_tree("$prefix  |   ", $kid, $trees);
		} else {
			print "$prefix  `--> ";
			pipeline_tree("$prefix      ", $kid, $trees);
		}
	}
}

sub generate_pipeline_human_description {
	my ($pipeline) = @_;

	my %auto = map { $_ => 1 } @{$pipeline->{auto}};

	my %trees;
	my %envs = map { $_ => 1 } @{$pipeline->{envs}};
	for my $b (keys %{$pipeline->{triggers}}) {
		my $a = $pipeline->{triggers}{$b};
		push @{$trees{$a}}, $b;
		delete $envs{$b};
	}
	for (sort keys %envs) {
		pipeline_tree("", $_, \%trees);
		print "\n";
	}
}

sub is_semver {
	return $_[0] =~ m/^(\d+)(?:\.(\d+)(?:\.(\d+)(?:[.-]rc[.-]?(\d+))?)?)?$/;
}

sub semver {
	my ($name, $v) = @_;
	if ($v =~  m/^(\d+)(?:\.(\d+)(?:\.(\d+)(?:[.-]rc[.-]?(\d+))?)?)?$/) {
		return ($1, $2 || 0, $3 || 0, $4 || 0);
	}
	die "Unrecognized version string '$v' for $name\n";
}

sub new_enough {
	my ($name, $v, $min) = @_;
	my @v = semver($name, $v);
	my @min = semver($name, $min);
	while (@v) {
		return 1 if $v[0] > $min[0];
		return 0 if $v[0] < $min[0];
		shift @v;
		shift @min;
	}
	return 1;
}

sub check_version {
	my ($name, $min, $cmd, $from, $regex, $url) = @_;
	$url ||= "your platform package manager";
	my $version = Genesis::Run::get({stderr => (($from eq 'stderr') ? "&1 >":"")."/dev/null"}, $cmd);
	return "#R{Missing `$name`} -- install from #B{$url}" if (!$version || $version =~ /not found/);
	return if (envset('GENESIS_DEV_MODE') && $version =~ /development/);
	$version =~ $regex;
	return "Could not determine version of $name from `#m{$cmd}`: Got '#C{$version}" unless $1 && is_semver($1);
	if (new_enough($name, $1, $min)) {
		debug "#g{Version $1} of #C{$name} meets or exceeds minimum of #w{$min}";
		return;
	}
	return "$name v{$1} is installed, but Genesis requires #R{at least $min} -- upgrade via #B{$url}";
}

sub check_prereqs {

	my %conditions = @_;

	my $bosh_min_version = "2.0.1";
	my $reqs = [
		# Name,     Version, Command,                                Grab      Pattern                  Source
		["spruce", "1.12.0", "spruce -v",                            'stdout', qr(.*version\s+(\S+).*)i, "https://github.com/geofffranks/spruce/releases"],
		["safe",    "0.1.8", "safe -v",                              'stderr', qr(safe v(\S+)),          "https://github.com/starkandwayne/safe/releases"],
		["vault",   "0.6.0", "vault -v",                             'stdout', qr(.*vault v(\S+).*)i,    "https://www.vaultproject.io/downloads.html"],
		["git",     "1.8.0", "git --version",                        'stdout', qr(.*version\s+(\S+).*)],
		["jq",        "1.5", "jq --version",                         'stdout', qr(^jq-(\S+)),            "https://stedolan.github.io/jq/download/"],
		["curl",   "7.30.0", "curl --version 2>/dev/null | head -n1",'stdout', qr(^curl\s+(\S+))]
	];

	my @errors = grep {$_} map {check_version(@$_)} @$reqs;

	# check that we has a bosh (v2)
	push @errors, check_bosh_version($bosh_min_version);

	push @errors, "This command needs to be run from a Genesis v2 deployment repo, or specify one using -C <dir> option"
		unless (in_repo_dir || $conditions{no_repo_needed});

	if (@errors) {
		error "#R{GENESIS PRE-REQUISITES CHECKS FAILED!!}";
		error;
		error "Encountered the following errors:";
		error "  - $_" for @errors;
		exit 2;
	}
}

sub extract_kit_name_and_version {
	my ($combined) = @_;
	return ($1, $2) if $combined =~ m{(.*)/(.*)};
	return $combined, "latest";
}

sub kit_release_url {
	my ($name, $version) = @_;

	my $creds = "";
	if ($ENV{GITHUB_USER} && $ENV{GITHUB_AUTH_TOKEN}) {
		$creds = "$ENV{GITHUB_USER}:$ENV{GITHUB_AUTH_TOKEN}";
	}
	my ($code, $msg, $data) = curl "GET", "https://api.github.com/repos/genesis-community/$name-genesis-kit/releases", undef, undef, 0, $creds;
	if ($code == 404) {
		die "Could not find Genesis Kit $name on Github; does https://github.com/genesis-community/$name-genesis-kit/releases exist?\n";
	}
	if ($code != 200) {
		die "Could not find Genesis Kit $name release information; Github returned a ".$msg."\n";
	}

	my $releases;
	eval { $releases = decode_json($data); 1 }
		or die "Failed to read releases information from Github: $@\n";

	if (!@$releases) {
		die "No released versions of Genesis Kit $name found at https://github.com/genesis-community/$name-genesis-kit/releases.\n";
	}

	for (map { @{$_->{assets} || []} } @$releases) {
		if ($version eq 'latest') {
			next unless $_->{name} =~ m/^\Q$name\E-(.*)\.(tar\.gz|tgz)$/;
			$version = $1;
		} else {
			next unless $_->{name} eq "$name-$version.tar.gz"
			         or $_->{name} eq "$name-$version.tgz";
		}
		return ($_->{browser_download_url}, $version);
	}

	die "$name/$version tarball asset not found on Github.  Oops.\n";
}

sub kit_file {
	my ($kit, $version, $relpath, $required) = @_;

	if (!$kit || $kit eq "dev") {
		-d "dev/"                       or die "dev/ kit directory not found. Please contact your kit author for a fix.\n";
		!$required || -f "dev/$relpath" or die "dev/$relpath not found. Please contact your kit author for a fix.\n";
		return "dev/$relpath";
	}
	-f ".genesis/kits/$kit-$version.tar.gz"
		or die "Kit $kit/$version not found in .genesis/kits!\n";

	my $dir;
	if (exists $KIT_CACHE_DIR{"$kit/$version"}) {
		$dir = $KIT_CACHE_DIR{"$kit/$version"};
	} else {
		$dir = workdir('kit');
		run(
			{stderr => '/dev/null'},
			'tar -C "$1" -xz --strip-components 1 -f ".genesis/kits/${2}-${3}.tar.gz" "${2}-${3}/${4}"',
			$dir, $kit, $version, $relpath
		);
	}
	!$required || -f "$dir/$relpath"
		or die "$relpath not found in $kit-$version kit. Please contact your kit author for a fix.\n";
	return "$dir/$relpath";
}

sub download_kit_tarball
{
	my ($name, $want) = @_;

	if ($want eq 'latest') {
		explain "Downloading Genesis kit #M{$name} (#Y{latest} version)\n";
	} else {
		explain "Downloading Genesis kit #M{$name}, version #C{$want}\n";
	}
	my ($url, $version) = kit_release_url($name, $want);
	mkdir_or_fail ".genesis";
	mkdir_or_fail ".genesis/kits";
	open my $kit, ">", ".genesis/kits/$name-$version.tar.gz"
		or die "Failed to open .genesis/kits/$name-$version.tar.gz for writing: $!\n";
	my ($code, $msg, $data) = curl "GET", $url;
	if ($code != 200) {
		die "Failed to download $name/$version from $url: Github returned an HTTP ".$msg."\n";
	}
	print $kit $data;
	close $kit;
	debug "downloaded kit #M{$name}/#C{$version}\n";
}
sub validate_kit_files {
	my ($dir,$is_author) = @_;
	my ($metadata, @errors, @warnings);
	if (-d $dir) {
		for (qw(hooks)) {
			push @warnings, "$dir/$_ directory does not exist" unless -d "$dir/$_";
		}
		for (qw(README.md)) {
			push @errors, "$dir/$_ does not exist" unless -f "$dir/$_";
		}
		if (-f "$dir/kit.yml") {
			eval {
				$metadata = LoadFile("$dir/kit.yml") if -f "$dir/kit.yml";
			};
			push @errors, "$dir/kit.yml could not be read: $@" if $@;
		} else {
			push @errors, "$dir/kit.yml does not exist";
		}

		if (-d "$dir/subkits/") {
			# Once the docs/AUTHORING-KITS.md has been updated, we want to educate
			# kit authors that the preferred way is to use features instead of
			# subkits, and that subkits will probably be deprecated in 3.0
			#push @warnings, "Enhancement: using 'subkits' subdirectory structure has been  -- use 'features' instead."
			#	if $is_author;
			for (glob "$dir/subkits/*") {
				push @errors, "$_/params.yml does not exist" unless -f "$_/params.yml";
			}
		}
	} else {
		push @errors, "$dir does not exist";
	}

	die("$dir does not look like a valid kit directory:\n".
		"  * ".join("\n  * ", @errors).
		"\n\nCannot continue.\n")
		if @errors;
	warn("Warning: $dir has abnormal contents (non-fatal):\n".
		"  * ".join("\n  * ", @warnings).
		"\n\n")
		if @warnings;

	return $metadata;
}

sub validate_kit_metadata {
	my ($kit, $version, $meta, $is_author) = @_;
	$kit ||= "dev";
	$version = "latest" unless defined $version;
	my @errors;

	# Validate acceptable genesis version
	if (defined $meta->{genesis_version_min}) {
		if (!is_semver $meta->{genesis_version_min}) {
			push @errors, "Specified minimum Genesis version of '$meta->{genesis_version_min}' for kit is invalid.";
		} elsif (!is_semver $VERSION) {
			error "#Y{WARNING:} Using a development version of Genesis.  Cannot determine if minimal Genesis version of '$meta->{genesis_version_min}' by kit '$kit/$version' is met."
		} elsif (! new_enough "genesis", $VERSION, $meta->{genesis_version_min}) {
			# Fatal error - die immediately
			error clean_heredoc(<<"			|EOF");
			|#R{ERROR:} Kit $kit/$version requires Genesis version $meta->{genesis_version_min}, but installed Genesis is only version $VERSION.
			|
			|Please upgrade your version and don't forget to run `genesis embed` to update the version embedded in your deployment repository.
			|
			|EOF
			exit 86; #no longer available, decommissioned, off the menu
		}
	}

	# validate features/subkits
	my ($group,$label,$not_label);
	if (exists $meta->{features}) {
		if (exists $meta->{subkits}) {
			error "\n#R{ERROR:} Kit contains both 'features' and 'subkits'.\n";
			die $is_author
				? "Update kit to move subkits under 'features' and update 'subkit' key to 'feature'\n"
				: "Please contact your kit author for a fix.\n";
		}
		($group,$label,$not_label) = qw(features feature subkit);
	} elsif (exists $meta->{subkits}) {
		# Once the docs/AUTHORING-KITS.md has been updated, we want to educate
		# kit authors that the preferred way is to use features instead of
		# subkits, and that subkits will probably be deprecated in 3.0
		# error "\n#Y{DEPRECATED:} subkits are deprecated in favour of features.  Please update your kit." if $is_author;
		($group,$label,$not_label) = qw(subkits subkit feature);
	}
	if (defined $group) {
		my $errored;
		foreach (@{$meta->{"${group}"}}) {
			if (exists $_->{$not_label} ) {
				print STDERR csprintf "\n#R{ERROR:} $group '$_->{$not_label}' uses key '$not_label' instead of '$label' - should use features/feature";
				$errored = 1;
			}
		}
		die($is_author
			? "\nUpdate kit to use 'features' and 'feature' exclusively\n"
			: "\nPlease contact your kit author for a fix.\n"
		) if $errored;
	}

	# validate params
	for my $feature (sort keys %{$meta->{params}}) {
		my $i = 0;
		debug ("Validating params for feature '$feature' (#$i)");
		if (ref($meta->{params}{$feature}) ne "ARRAY") {
			push @errors, "$feature feature parameters not a list (found ".(ref($meta->{params}{$feature}) || "a string").")";
		} else {
			for my $param (@{$meta->{params}{$feature}}) {
				my $name = ($param->{param} && !ref($param->{param})) ? ':'.$param->{param} : "";
				my $parameter = "params.$feature\[$i$name\]";
				my (@extras, @bad);
				for my $key (sort keys %$param) {
					push @extras, $key if $key !~ m/^(params?|ask|vault|description|example|type|echo)$/;
				}
				if (defined($param->{ask})) {
					my $type = exists($param->{type}) ? $param->{type} : "string";
					if (defined($param->{validate})) {
						if ($type =~ m/^(string|list)$/) {
							@extras = grep {$_ !~ /^(validate|err_msg)$/ } @extras;
							if ($param->{validate} !~ m/^!?\/.*\/i?m?s?$/                      && # regex validation
								$param->{validate} !~ m/^((^|,)[^,]+){2,}$/                    && # comma-separated list
								$param->{validate} !~ m/^!?\[([^,]+(,[^,]+)*)]$/               && # new invertable comma-separated list
								$param->{validate} !~ m/^((^|,)[^,]+){2,}$/                    && # comma-separated list
								$param->{validate} !~ m/^-?\d+(\.\d+)?--?\d+(\.\d+)?$/         && # range
								$param->{validate} !~ m/^-?\d+(\.\d+)?(\+|--?\d+(\.\d+)?)$/    && # range
								$param->{validate} !~ m/^(vault_path(_and_key)?|url|port|ip)$/ ){ # key-words
								push @errors, "$parameter has an invalid validation formula";
							}

						} elsif ($type =~ m/^(multi-)?choice$/) {
							@extras = grep {$_ !~ /^(validate|err_msg)$/ } @extras;
							if (ref($param->{validate}) eq 'ARRAY') {
								# All array elements must be simple strings
								push @errors, "$parameter validation array can only contain strings or 2-string arrays"
									if (grep {ref($_) && !(ref($_) eq 'ARRAY' && $#$_ == 1 && !ref($_->[0]) && !ref($_->[1]))} @{$param->{validate}});
								my $min = 2;
								$min = $param->{min_count} if ($type eq 'multi-choice' && defined($param->{min_count}) && $param->{min_count} > $min);
								push(@errors, "$parameter requires at least 2 choices") if scalar(@{$param->{validate}}) < $min;
							} else {
								push @errors, "$parameter validation must be an array of strings or 2-string arrays";
							}
						}
					} else {
						if ($type =~ m/^(multi-)?choice$/) {
							push @errors, "$parameter requires validation to provide choices";
						}
					}
					if ( $type =~ m/^(string|block|multi-?line|choice)$/) {
						push @bad, grep {$_ !~ m/^(label|default)$/} @extras;
					} elsif ($type eq 'boolean') {
						push @bad, grep {$_ !~ m/^(label|default)$/} @extras;
						push @errors, "$parameter has invalid default value '$param->{default}'"
						  if (defined($param->{default}) && $param->{default} !~ /^(1|0|y(es)?|no?|true|false)$/i);
					} elsif ($type =~ m/^((block|multi-?line)-)?list$/) {
						push @bad, grep {$_ !~ m/^(label|(max|min)_count)$/} @extras;
						push @errors, "$parameter requires max_count to be equal to or greater than min_count"
							if (defined($param->{min_count}) && defined($param->{max_count}) && $param->{max_count} < $param->{min_count});
						foreach (qw/min_count max_count/) {
							push @errors, "$parameter requires $_ to be non-negative"
								if (defined($param->{$_}) && $param->{$_} < 0);
						}
					} elsif ($type eq 'multi-choice') {
						push @bad, grep {$_ !~ m/^((max|min)_count)$/} @extras;
						push @errors, "$parameter requires max_count to be equal to or greater than min_count"
							if (defined($param->{min_count}) && defined($param->{max_count}) && $param->{max_count} < $param->{min_count});
						foreach (qw/min_count max_count/) {
							push @errors, "$parameter requires $_ to be non-negative"
								if (defined($param->{$_}) && $param->{$_} < 0);
						}
					} else {
						push @errors, "$parameter has unsupported type '$type'";
						@bad = @extras;
					}
				} else {
					@bad = @extras;
				}
				push @errors, "$parameter has an invalid attribute: '$_'" foreach @bad;
				push @errors, "$parameter does not specify 'vault', 'param', or 'params'"
					unless ($param->{param} || $param->{params} || $param->{vault});
				push @errors, "$parameter specifies both 'param' and 'params'"
					if ($param->{param} && $param->{params});
				push @errors, "$parameter specifies both 'param' and 'vault'"
					if ($param->{param} && $param->{vault});
				push @errors, "$parameter specifies both 'params' and 'vault'"
					if ($param->{vault} && $param->{params});
				push @errors, "$parameter specifies 'param', but it is not a string"
					if $param->{param} && ref $param->{param};
				push @errors, "$parameter specifies 'params', but it is not an array"
					if $param->{params} && ref $param->{params} ne "ARRAY";
				push @errors, "$parameter specifies both 'params' and 'ask'"
					if $param->{params} && $param->{ask};
				push @errors, "$parameter does not have a 'description'"
					if ! $param->{description};
				push @errors, "$parameter specifies 'ask', but does not have a corresponding 'vault' or 'param'"
					if ($param->{ask} && ! $param->{vault} && ! $param->{param});
				push @errors, "$parameter specifies 'vault' but does not have a corresponding 'ask'"
					if $param->{vault} && ! $param->{ask};

				$i++;
			}
		}
	}

	if (@errors) {
		error "\n#R{ERROR:} The following errors have been encountered validating the $kit/$version kit:";
		for my $err (@errors) {
			error " - $err";
		}
		die ($is_author ? "Cannot continue.\n" : "Please contact your kit author for a fix.\n");
	}
}

# read the metadata for the given kit (and version)
# if no kit/version is given, assume 'dev'
sub read_kit_metadata {
	my ($kit, $version) = @_;
	my $metadata = LoadFile(kit_file($kit, $version, "kit.yml", 1));
	validate_kit_metadata($kit, $version, $metadata, !$kit || $kit eq "dev");
	return $metadata;
}

sub latest_kit_name_and_version {
	# use dev/, if we have it
	return (undef, undef) if -d "dev";

	# use latest available:
	my ($kit, @versions);
	for (glob(".genesis/kits/*.tar.gz")) {
		next unless m{^\.genesis/kits/(.*?)-(\d+(\.\d+(\.\d+([.-]rc[.-]?\d+)?)?)?).tar.gz$};
		my ($n, $v) = ($1, $2);
		if ($kit && $kit ne $n) {
			die "Found multiple different kits!\n";
		}
		$kit = $n;
		push @versions, [$v, semver($kit, $v)];
	}
	@versions > 0
		or die "No kits have been downloaded for use in this set of deployment environments.\nPlease download a kit via `genesis download kit-name[/version]`\n";
	my @sorted = reverse sort { $a->[1] <=> $b->[1] } @versions;
	return ($kit, $sorted[0][0]);
}

sub kit_name_and_version_for {
	my ($env) = @_;
	my $name = get_key($env, 'kit.name');
	my $vers = get_key($env, 'kit.version');
	return (undef, undef) if $name && $name eq 'dev';
	return ($name, $vers) if $name && $vers;
	return latest_kit_name_and_version();
}

sub check_kit_prereqs {
	my ($kit, $version) = @_;
	my $script = kit_file($kit, $version, "hooks/prereqs", 0);
	return unless -e $script;
	explain "Checking kit pre-requisites...\n";
	-x $script || chmod_or_fail 0755, $script;
	Genesis::Run::do_or_die(
		"Some prerequisites for this Genesis Kit have not been met",
		$script
	);
}

sub prompt_for_env_features {
	my ($kit, $version, $meta) = @_;
	my @features;
	my $features_meta = $meta->{features} || $meta->{subkits} || [];
	my @meta_key = (defined $meta->{features}) ? 'feature' : 'subkit';
	foreach my $feature (@$features_meta) {
		my $prompt = $feature->{prompt}."\n";
		if (exists $feature->{choices}) {
			my (@choices,@labels,$default);
			foreach (@{$feature->{choices}}) {
				push @choices, $_->{feature} || $_->{subkit};
				push @labels,  $_->{label};
				$default = ($_->{feature} || $_->{subkit}) if $_->{default} && $_->{default} =~ /^(y(es)?|t(rue)?|1)$/i;
			}
			if (exists $feature->{pick}) {
				die "There is a problem with kit $kit/$version: $feature->{type} pick invalid.  Please contact the kit author for a fix"
					unless $feature->{pick} =~ /^\d+(-\d+)?$/;
				my ($min, $max) =  ($feature->{pick} =~ /-/)
					? split('-',$feature->{pick})
					: ($feature->{pick},$feature->{pick});
				my $selections = grep {$_} prompt_for_choices($prompt,\@choices,$min,$max,\@labels);
				push @features, @$selections;
			} else {
				push @features, grep {$_} (prompt_for_choice($prompt,\@choices,$default,\@labels));
			}
		} else {
			push(@features, ($feature->{feature} || $feature->{subkit})) if  prompt_for_boolean($prompt,$feature->{default});
		}
	}
	@features = run_feature_hook($kit, $version, @features);
	validate_features($kit, $version, $meta, @features);
	return @features;
}

sub resolve_params_ref {
	my ($key,$references) = @_;
	die("\$\{$key\} referenced but not found -- perhaps it hasn't been defined yet.  Contact your Kit author for a bugfix.\n")
		unless exists($references->{$key});
	return $references->{$key};
}

sub process_kit_params {
	my %opts = @_;
	my @answers;
	my $resolveable_params = {
		"params.vault_prefix" => $opts{vault_prefix}, # for backwards compatibility
		"params.vault" => $opts{vault_prefix},
		"params.env" => $opts{env}
	};
	for my $feature ("base", @{$opts{features}}) {
		next unless defined $opts{params}{$feature} && @{$opts{params}{$feature}};
		my $kit_params_file = $feature eq "base" ? "base/params.yml" : (
			-f kit_file($opts{kit}, $opts{version}, "subkits/$feature/params.yml",0)
				? "subkits/$feature/params.yml"
				: "features/$feature/params.yml"
		);
		my $defaults = LoadFile(kit_file($opts{kit}, $opts{version}, $kit_params_file, 1));
		for my $q (@{$opts{params}{$feature}}) {
			my $answer;
			my $vault_path;
			next if ($q->{vault} && !vaulted);
			# Expand any values from default and examples for vault prefix
			foreach (qw(description ask default example validate err_msg)) {
				$q->{$_} =~ s/\$\{([^}]*)\}/resolve_params_ref($1,$resolveable_params)/ge if defined($q->{$_});
			}
			if (defined($q->{validate}) && $q->{validate} eq 'vault_path') {
				if (defined($q->{default})) {
					while ($q->{default} =~ s#/[^/]+/\.\./#/#) {};
				}
				if (defined($q->{example})) {
					while ($q->{example} =~ s#/[^/]+/\.\./#/#) {};
				}
			}
			if ($q->{ask}) {
				$q->{type} ||= "string";
				print "\n";
				if ($q->{param}) {
					print csprintf("#y{Required parameter:} #W{$q->{param}}\n\n");
				} else {
					$vault_path = "secret/$opts{vault_prefix}/$q->{vault}";
					print csprintf("#y{Secret data required} -- will be stored in Vault under #W{$vault_path}\n\n");
				}
				chomp $q->{description};
				print "$q->{description}\n";
				print "(e.g. $q->{example})\n" if defined $q->{example};
				if ($q->{param}) {
					my $type = $q->{type};
					if (defined($q->{validate}) && $q->{validate} =~ /^vault_path(_and_key)?$/ && ! vaulted()) {
						print csprintf("#y{Warning:} Cannot validate vault paths when --no-secrets option specified");
					}
					if ($type eq 'boolean') {
						$answer = prompt_for_boolean($q->{ask},$q->{default});
					} elsif ($type eq 'string') {
						$answer = prompt_for_line($q->{ask},$q->{label},$q->{default},$q->{validate},$q->{err_msg});
					} elsif ($type =~ m/^(block|multi-?line)$/) {
						$answer = prompt_for_block($q->{ask},$q->{label},$q->{default});
					} elsif ($type eq 'list') {
						$answer = prompt_for_list('line',$q->{ask},$q->{label},$q->{min_count},$q->{max_count},$q->{validate},$q->{err_msg});
					} elsif ($type =~ m/^(block|multi-?line)-list$/) {
						$answer = prompt_for_list('block',$q->{ask},$q->{label},$q->{min_count},$q->{max_count});
					} elsif ($type =~ m/^(multi-)?choice$/) {
						my ($choices,$labels)=([],[]);
						if (ref($q->{validate}) eq 'ARRAY') {
							foreach (@{$q->{validate}}) {
								if (ref($_) eq 'ARRAY') {
									push @$choices, $_->[0];
									push @$labels, $_->[1];
								} else {
									push @$choices, $_;
									push @$labels, undef;
								}
							}
						}
						if ($type eq 'choice') {
							$answer = prompt_for_choice($q->{ask},$choices,$q->{default},$labels,$q->{err_msg});
						} else {
							$answer = prompt_for_choices($q->{ask},$choices,$q->{min_count},$q->{max_count},$labels,$q->{err_msg});
						}
					} else {
						die "Unsupported type '$type' for parameter '$q->{param}'. Please contact your kit author for a fix.\n";
					}
					print "\n";
				} else {
					my ($path, $key) = split /:/, $vault_path;
					if ($q->{type} =~ /^(boolean|string)$/) {
						Genesis::Run::interact(
							{onfailure => "Failed to save data to $vault_path in Vault"},
							'safe prompt "$1" -- "$2" "$3" "$4"',
							$q->{ask}, ($q->{echo} ? "ask" : "set"), $path, $key
						);
					} elsif ($q->{type} eq "multi-line") {
						$answer = prompt_for_block($q->{ask});
						my $tmpdir = workdir;
						open my $fh, ">", "$tmpdir/param" or die "Could not write to $tmpdir/param: $!\n";
						print $fh $answer;
						close $fh;
						Genesis::Run::do_or_die(
							"Failed to save data to $vault_path in Vault",
							'safe set "$1" "${2}@${3}/param"',
							$path, $key, $tmpdir
						);
					} else {
						die "Unsupported parameter type '$q->{type}' for $q->{vault}. Please contact your kit author for a fix.\n";
					}
					print "\n";
					next;
				}
			}
			my @values;
			my $is_default = 0;
			if (! $q->{ask}) {
				$is_default = 1;
				if (defined $q->{param}) {
					$q->{params} = [$q->{param}];
				}
				for my $p (@{$q->{params}}) {
					# Should we throw an error here if the default value is
					# a spruce operator like (( param ))?
					push @values, { $p => $defaults->{params}{$p} };
					$resolveable_params->{"params.$p"} = $defaults->{params}{$p};
				}
			} else {
				push @values, { $q->{param} => $answer };
				$resolveable_params->{"params.$q->{param}"} = $answer;
			}

			push @answers, {
				comment => $q->{description},
				example => $q->{example},
				values  => \@values,
				default => $is_default,
			};
		}
	}
	return \@answers;
}

sub active_credentials {
	my ($meta, $features) = @_;

	my $active = {};
	for my $sub (('base', @$features)) {
		next unless $meta->{credentials}{$sub};
		for my $path (keys %{ $meta->{credentials}{$sub} }) {
			if (exists $active->{$path} && ref $meta->{credentials}{$sub}{$path}) {
				for my $k (keys %{ $meta->{credentials}{$sub}{$path} }) {
					$active->{$path}{$k} = $meta->{credentials}{$sub}{$path}{$k};
				}
			} else {
				$active->{$path} = $meta->{credentials}{$sub}{$path};
			}
		}
	}
	return $active;
}

sub active_certificates {
	my ($meta, $features) = @_;

	my $active = {};
	for my $sub (('base', @$features)) {
		next unless $meta->{certificates}{$sub};
		for my $path (keys %{ $meta->{certificates}{$sub} }) {
			if (exists $active->{$path} && ref $meta->{certificates}{$sub}{path}) {
				for my $k (keys %{ $meta->{certificates}{$sub}{$path} }) {
					$active->{$path}{$k} = $meta->{certificates}{$sub}{$path}{$k};
				}
			} else {
				$active->{$path} = $meta->{certificates}{$sub}{$path};
			}
		}
	}
	return $active;
}

sub target_vault {
	my ($target) = @_;
	$target ||= '-i';  # Default to interactive mode
	Genesis::Run::interact(
		{onfailure => "Could not set safe target"},
		'safe', 'target', $target
	);

	# FIXME: safe now supports safe target --json, and once that gets released, we should totes use that.
	$ENV{GENESIS_TARGET_VAULT}=Genesis::Run::get(
		{onfailure => "Could not set target vault"} ,
		'safe target 2>&1 | grep "$1" | sed -e "$2"',
		'.*targeting .* at.*', 's/.*targeting \([^ ]*\) at.*/\1/'
	);
}
# generate (and optionally rotate) credentials.
#
## just rotate credentials
# vaultify_secrets $kit_metadata,
#                  target       => "my-vault",
#                  env          => "us-east-sandbox",
#                  prefix       => "us/east/sandbox",
#                  scope        => 'rotate'; # or scope => '' or undef
#
## generate all credentials (including 'fixed' creds)
# vaultify_secrets $kit_metadata,
#                  target       => "my-vault",
#                  env          => "us-east-sandbox",
#                  prefix       => "us/east/sandbox",
#                  scope        => 'force';
#
## generate only missing credentials
# vaultify_secrets $kit_metadata,
#                  target       => "my-vault",
#                  env          => "us-east-sandbox",
#                  prefix       => "us/east/sandbox",
#                  scope        => 'add';
#
sub vaultify_secrets {
	my ($meta, %options) = @_;
	$options{env} or die "vaultify_secrets() was not given an 'env' option.\n";

	my $creds = active_credentials($meta, $options{features} || {});
	if (%$creds) {
		explain " - auto-generating credentials (in secret/$options{prefix})...\n";
		for (safe_commands $creds, %options) {
			Genesis::Run::interact(
				{onfailure => "Failure autogenerating credentials."},
				'safe', @$_
			);
		}
	} else {
		explain " - no credentials need to be generated.\n";
	}

	my $certs = active_certificates($meta, $options{features} || {});
	if (%$certs) {
		explain " - auto-generating certificates (in secret/$options{prefix})...\n";
		for (cert_commands $certs, %options) {
			Genesis::Run::interact(
				{onfailure => "Failure autogenerating certificates."},
				'safe', @$_
			);
		}
	} else {
		explain " - no certificates need to be generated.\n";
	}
}

sub check_secrets {
	my ($meta, %options) = @_;
	$options{env} or die "check_secrets() was not given an 'env' option.\n";

	my @missing = ();
	for (safe_commands(active_credentials($meta, $options{features}||{}),%options)) {
		push @missing, check_secret($_, %options);
	}
	for (cert_commands(active_certificates($meta, $options{features}||{}),%options)) {
		push @missing, check_secret($_, %options);
	}
	if (@missing) {
		my $suf = scalar(@missing) == 1 ? '' : 's';
		printf "Missing %d credential%s or certificate%s:\n  * %s\n",
			scalar(@missing), $suf, $suf,
			join ("\n  * ", map {join " ", @$_} @missing);
		return 1;
	} else {
		print "All credentials and certificates present.\n";
		return 0;
	}
}

# build a columnar display of tabular data,
# tablify($headers, [$row1,$row2,...])
sub tablify {
	my ($headers_ref, $rows_ref) = @_;
	my @headers = @{$headers_ref};
	my @rows    = @{$rows_ref};
	my @widths  = map { length $_ } @headers;

	for my $row (@rows) {
		next unless $row;
		for (my $i = 0; $i < @$row; $i++) {
			my $l = length($row->[$i] || '');
			$widths[$i] = $l unless defined $widths[$i] and $widths[$i] > $l;
		}
	}
	@widths = map { $_ + 4 } @widths;

	for (my $i = 0; $i < @headers; $i++) {
		printf("%-*s", $widths[$i], $headers[$i]);
	}
	printf("\n");

	for (my $i = 0; $i < @headers; $i++) {
		printf("%-*s", $widths[$i], ("=" x length($headers[$i])));
	}
	printf("\n");

	for my $row (@rows) {
		if ($row) {
			for (my $i = 0; $i < @$row; $i++) {
				printf("%-*s", $widths[$i], $row->[$i]);
			}
		}
		printf("\n");
	}
}

# bosh_target_for $env
sub bosh_target_for {
	my ($env) = @_;
	my ($bosh, $source);
	if (      $bosh = $ENV{GENESIS_BOSH_ENVIRONMENT}) {
			$source = "GENESIS_BOSH_ENVIRONMENT environment variable";

	} elsif ( $bosh = get_key($env, 'params.bosh')) {
			$source = "params.bosh in $env environment file";

	} elsif ( $bosh = get_key($env, 'params.env')) {
			$source = "params.env in $env environment file because no params.bosh was present";

	} else {
		die "Could not find the `params.bosh' or `params.env' key in $env!\n";
	}
	Genesis::Run::interactive_bosh({
		onfailure => "Could not find Bosh Director `$bosh` (specified via $source).",
		env       => {BOSH_ENVIRONMENT => $bosh}
		}, 'env');
	return $bosh;
}


###########################################################################

my ($COMMAND, %COMMAND, %USAGE);

sub usage {
	my ($rc, $msg, $cmd) = @_;
	$cmd = $COMMAND unless $cmd;
	print STDERR "$msg\n\n" if $msg;
	print STDERR $USAGE{$cmd} if $USAGE{$cmd};
	exit $rc;
}

our $GLOBAL_USAGE = <<EOF;
  -h, --help        Show this help screen.
  -D, --debug       Enable debugging, printing helpful message about what
                    Genesis is doing, to standard error.
  -T, --trace       Even more debugging, including debugging inside called
                    tools (like spruce and bosh).
  -C, --cwd         Effective working directory.  Defaults to '.'
  -e, --environment Which BOSH environment (aka director) to use.  If not
                    specified, it will use the value in params.bosh or
                    params.env in that order.  Can also be provided using either
                    \$GENESIS_BOSH_ENVIRONMENT or \$BOSH_ENVIRONMENT env variables.
EOF
sub options {
	my ($args, $options, @spec) = @_;
	$options->{color} = 1 unless exists $options->{color};
	GetOptionsFromArray($args, $options,
		(qw/
			help|h
			debug|D
			trace|T
			quiet|q
			offline
			cwd|C=s
			environment|e=s
			color!
		/,
		@spec))
			or usage(1);

	usage(0) if $options->{help};

	$ENV{QUIET}         = 'y' if  $options->{quiet};
	$ENV{GENESIS_DEBUG} = 'y' if  $options->{debug} || envset "DEBUG";
	$ENV{TRACE}         = 'y' if  $options->{trace};
	$ENV{NOCOLOR}       = 'y' if !$options->{color};
	$ENV{OFFLINE}       = 'y' if  $options->{offline};

	debug("bosh env: ".($options->{environment} || "-same-as-env-file-"));

	$ENV{GENESIS_BOSH_ENVIRONMENT} = $options->{environment}
		if $options->{environment};
	chdir_or_fail $options->{cwd} if $options->{cwd};
}

sub command {
	my ($name, $usage, $fn) = @_;
	if (ref($name) ne 'ARRAY') {
		$name = [$name];
	}
	for my $cmd (@$name) {
		$USAGE{$cmd}   = $usage;
		$COMMAND{$cmd} = sub {
			$COMMAND = $cmd;
			$fn->(@_);
		};
	}
}


###########################################################################

# genesis help - print the help screen. {{{

command("help", <<EOF,
genesis v$VERSION
USAGE: genesis [OPTIONS] COMMAND [MORE OPTIONS]

OPTIONS
$GLOBAL_USAGE
COMMANDS
  ci               Interactively setup Concourse deployment pipeline.
  create-kit       Create a new kit with default scaffolding.
  compile-kit      Create a distributable kit archive from dev.
  decompile-kit    Unpack a kit archive to dev.
  deploy           Generate a real manifest using Vault + Cloud Config, and deploy it to BOSH.
  describe         Describe a Concourse pipeline, in words.
  download         Download a Genesis Kit from the Internet.
  graph            Draw a Concourse pipeline.
  init             Initialize a new Genesis deployment.
  lookup           Find a key set in environment manifests.
  manifest         Generate a redacted BOSH deployment manifest for an environment.
  new              Create a new Genesis deployment environment.
  ping             See if the genesis binary is a real thing.
  repipe           Configure a Concourse pipeline for automating deployments.
  secrets          Re-generate / rotate credentials (passwords, keys, etc.).
  summary          Print a summary of defined environments.
  version          Print the version of genesis
  yamls            Print a list of the YAML files used for a single environment.

See `genesis COMMAND -h' for more specific, per-command usage information.
EOF
sub {
	usage(0);
});

# }}}
# genesis ping - see if the genesis binary is a real thing. {{{

command("ping", <<EOF,
genesis v$VERSION
USAGE: genesis ping

OPTIONS
$GLOBAL_USAGE
EOF
sub {
	check_prereqs(no_repo_needed => 1);
	print "PING!\n";
});

# }}}
# genesis version - Print the version of Genesis. {{{

command("version", <<EOF,
genesis v$VERSION
USAGE: genesis version

OPTIONS
$GLOBAL_USAGE
EOF
sub {
	print "Genesis v$VERSION\n";
});

# }}}
# genesis embed - embed Genesis in the repository {{{

command("embed", <<EOF,
genesis v$VERSION
USAGE: genesis embed

OPTIONS
$GLOBAL_USAGE
EOF
sub {
	my %options;
	options(\@_, \%options, qw/
	/);
	usage(1) if @_;
	check_prereqs;

	# FIXME: update .genesis/config with new version info
	mkdir_or_fail ".genesis/bin";
	copy_or_fail $0, ".genesis/bin/genesis";
	chmod_or_fail 0755, ".genesis/bin/genesis";
});
# }}}
#  genesis init - initialize a new Genesis repository {{{

command("init", <<EOF,
genesis v$VERSION
USAGE: genesis init [-k KIT/VERSION] [-d directory] [name]

OPTIONS
$GLOBAL_USAGE
  -k, --kit           Name (and optionally, version) of the Genesis Kit to base
                      these deployments on.  I.e.: shield/6.3.0.  If you do not
                      specify a kit, a dev directory will be created for you to
                      develop a local kit into.
  -L, --link-dev-kit  Instead of using a kit or initializing an empty dev
                      directory, this will link the specified directory to the
                      dev directory.
  -d, --directory     By default, the directory in which the Genesis deployment
                      will be created in will be named ./<name>-deployments.
                      Use this option to change it to something else.

  name                If the name argument is not specified, it will default to
                      the same name as the kit.  You must specify either name
                      or kit.
EOF
sub {
	my %options;
	options(\@_, \%options, qw/
		kit|k=s
		directory|d=s
		link-dev-kit|L=s
	/);
	usage(1) if @_ > 1; # name is now optional if kit specified
	check_prereqs(no_repo_needed => 1);

	my $abs_target;
	if ($options{'link-dev-kit'}) {
		usage(1,"Cannot specify both a kit (-k) and a link to a kit (-L)") if $options{kit};
		$abs_target = abs_path($options{'link-dev-kit'});
		my $pwd = getcwd;
		die "Link target '$options{'link-dev-kit'}' cannot be found from $pwd!\n" unless $abs_target;
	}

	my ($name) = @_;
	unless ($name) {
		if ($options{kit}) {
			($name, $_) = extract_kit_name_and_version($options{kit});
		} elsif ($options{'link-dev-kit'}) {
			$name = basename($options{'link-dev-kit'});
		} else {
			printf STDERR "You must specify a deployment name if you don't specify a kit or a dev link target.\n";
			usage(1);
		}
	}
	$name =~ s/-deployments//;

	validate_repo_name $name or die "Invalid Genesis repo name '$name'\n";

	debug "generating a new Genesis repo, named $name";

	debug "checking git config so can git commit later";
	Genesis::Run::do_or_die(
		'Please setup git - git config --global user.name "Your Name" -',
		'git config user.name');
	Genesis::Run::check(
		'Please setup git - git config --global user.email your@email.com -',
		'git config user.email');

	my $root = $options{directory} || "${name}-deployments";
	debug "in directory $root";
	if (-e $root) {
		die "Attempted to create new environment `$root' failed: Path already exists.\n";
	}
	mkdir_or_fail  "$root/.genesis";
	mkfile_or_fail "$root/.genesis/config", <<EOF;
---
genesis: $VERSION
deployment_type: $name
EOF
	mkdir_or_fail  "$root/.genesis/bin";
	copy_or_fail   $0, "$root/.genesis/bin/genesis";
	chmod_or_fail  0755, "$root/.genesis/bin/genesis";
	mkfile_or_fail "$root/README.md", <<EOF;
$name deployments
==============================

This repository contains the YAML templates that make up a series of
$name BOSH deployments, using the format prescribed by the
[Genesis][1] utility. These deployments are based off of the
[$name-genesis-kit][2].

Environment Naming
------------------

Each environment managed by this repository will have its own
deployment file, e.g. `us-east-prod.yml`. However, in many cases,
it can be desirable to share param configurations, or kit configurations
across all of the environments, or specific subsets. Genesis supports
this by splitting environment names based on hypthens (`-`), and finding
files with common prefixes to include in the final manifest.

For example, let's look at a scenario where there are three environments
deployed by genesis: `us-west-prod.yml`, `us-east-prod.yml`, and `us-east-dev.yml`.
If there were configurations that should be shared by all environments,
they should go in `us.yml`. Configurations shared by `us-east-dev` and `us-east-prod`
would go in `us-east.yml`.

To see what files are currently in play for an environment, you can run
`genesis <environment-name>`

Quickstart
----------

To create a new environment (called us-east-prod-$name):

    genesis new us-east-prod

To build the full BOSH manifest for an environment:

    genesis manifest us-east-prod

... and then deploy it:

    genesis deploy us-east-prod

To rotate credentials for an environment:

    genesis secrets us-east-prod
    genesis deploy us-east-prod

To update the Concourse Pipeline for this repo:

    genesis repipe

To download a new version of the kit, and deploy it:

    genesis download $name [version] # omitting version downloads the latest

    # update the environment yaml to use the desired kit version,
    # this might be in a different file if using CI to propagate
    # deployment upgrades (perhaps us.yml)
    vi us-east-prod.yml

    genesis deploy us-east-prod.yml # or commit + git push for CI to run through the upgrades

See the [Deployment Pipeline Documentation][3] for more
information on getting set up with Concourse deployment pipelines.

Helpful Links
-------------

- [$name-genesis-kit][2] - Details on the kit used in this repo,
  its features, prerequesites, and params.
- [Deployment Pipeline Documentation][3] - Docs on all the
  configuration options for `ci.yml`, and how the automated
  deployment pipelines behave.

[1]: https://github.com/starkandwayne/genesis
[2]: https://github.com/genesis-community/$name-genesis-kit
[3]: https://github.com/starkandwayne/genesis/blob/master/docs/PIPELINES.md

Repo Structure
--------------

Most of the meat of the deployment repo happens at the base level.
Envirionment YAML files, shared YAML files, and the CI
configuration YAML file will all be here.

The `.genesis/manifests` directory saves redacted copies of the
deployment manifests as they are deployed, for posterity, and to
keep track of any `my-env-name-state.yml` files from `bosh create-env`.

The `.genesis/cached` directory is used by CI to propagate changes
for shared YAML files along the pipelines. To aid in CI deploys, the
`genesis/bin` directory contains an embedded copy of genesis.

`.genesis/kits` contains copies of the kits that have been used in
this deployment. Once a kit is no longer used in any environment,
it can be safely removed (`genesis summary`).

`.genesis/config` is used internally by `genesis` to understand
what is being deployed, and how.
EOF

	chdir_or_fail $root;

	if ($options{'link-dev-kit'}) {
		debug "Kit: linking dev to $abs_target";
		symlink_or_fail $abs_target, "./dev";
	} elsif ($options{kit}) {
		debug "Kit: installing kit $options{kit}";
		my ($kit, $version) = extract_kit_name_and_version($options{kit});
		download_kit_tarball($kit, $version);
	} else {
		debug "Kit: creating empty ./dev kit directory";
		mkdir_or_fail "./dev";
	}

	Genesis::Run::do_or_die(
		"Failed to initialize a git repository in $root/",
		'git init');
	Genesis::Run::do_or_die(
		"Failed to stage files to git, for initial commit, in $root/",
		'git add .');
	Genesis::Run::do_or_die(
		"Failed to commit initial Genesis repository in $root/",
		'git commit -m "Initial Genesis Repo"');

	exit 0;
});

# }}}
# genesis new - create a new Genesis deployment environment (YAML file) {{{

command("new", <<EOF,
genesis v$VERSION
USAGE: genesis new [--vault target] env-name[.yml]

OPTIONS
$GLOBAL_USAGE
      --vault        The name of a `safe' target (a Vault) to store newly
                     generated credentials in.

      --prefix       By default, the vault path is secret/<env-name>/<kit>
                     where <env-name> has had any - converted to / and
                     <kit> is the kit name.  Use this option to change the part
                     after secret/

      --no-secrets   Do not generate secrets in the Vault.  You will have to
                     manually run `genesis secrets` yourself.

  -k, --kit          Name (and optionally, version) of the Genesis Kit to
                     use for this environment.  I.e.: shield/6.3.0
                     Defaults to latest.
EOF
sub {
	my %options = (
		secrets => 1,
	);
	options(\@_, \%options, qw/
		vault=s
		prefix=s
		secrets!
		kit|k=s
	/);
	usage(1) if @_ != 1;

	my ($name) = @_;
	$name =~ s/\.yml$//;

	$! = 2; # make die return 2; for the tests
	my $err = check_env_name_for_errors($name);
	die "Invalid environment name '$name': $err\n" if $err;
	-f "$name.yml" and die "Environment '$name' already exists\n";
	my $deployment = $name . "-" . deployment_suffix;
	my $prefix = ($options{prefix} ? $options{prefix} : (vault_slug($name).'/'.deployment_suffix));

	at_exit(sub {
		# remove the env file if either prereqs check or vaultification fails
		unlink "$name.yml" unless $? == 0;
	});

	check_prereqs;
	explain "Generating new environment #C{$name}...\n";

	my ($kit, $version, @features, $kit_dir);
	if ($options{kit}) {
		($kit, $version) = extract_kit_name_and_version($options{kit});
	} else {
		($kit, $version) = latest_kit_name_and_version();
	}

	if ($kit && $kit ne "dev") {
		$kit_dir = get_kit($kit,$version);
		explain "Using compiled kit $kit/$version...\n";
	} else {
		explain "Using local development kit (./dev)...";
		$kit = "dev";
		$version = "latest";
		$kit_dir = "./dev";
	}

	if ($options{secrets}) {
		target_vault($options{vault});
	}

	my $meta = read_kit_metadata($kit, $version);
	my $new_script=kit_file($kit,$version,"hooks/new",0);
	if (-f $new_script) {
		chmod_or_fail(0755, $new_script) unless -x $new_script;
		my $curdir = Cwd::getcwd;
		my $helper = new_script_helper($kit,$version);
		Genesis::Run::interact(
			'cd "$1"; source "$2"; hooks/new "$3" "$4" "$5"',
			$kit_dir, $helper, $curdir, $name, $prefix
		);
		if ($? >> 8) {
			error "#R{ERROR}: Could not create new environment $name by executing $kit/$version hooks/new script";
			exit 2;
		}
		die "New environment '$name' was not generated.  Contact your kit developer for a fix"
			unless -f "$name.yml";
		@features = @{get_key($name, 'kit.features', [])};
		(my $parent = $name) =~ s/-.*/.yml/;
		ensure_org_level_environment_file_exists($parent,$kit,$version);
	} else {
		check_kit_prereqs($kit, $version);
		@features = prompt_for_env_features($kit, $version, $meta);
		my $params = process_kit_params(kit          => $kit,
										version      => $version,
										env          => $name,
										vault_prefix => $prefix,
										params       => $meta->{params} || [],
										features     => [@features]);
		$params = run_param_hook($kit, $version, $name, $prefix, $params, @features);

		new_environment($meta, $kit, $version, $name, $prefix, $params, @features);
	}

	if ($options{secrets}) {
		explain "Generating secrets / credentials (in secret/$prefix)...\n";
		vaultify_secrets($meta, env          => $name,
		                        prefix       => $prefix,
		                        scope        => 'force',
		                        features     => \@features);
	} else {
		explain "Skipping generation of secret / credentials.\n";
		explain "Don't forget to run `$0 secrets $name`\n";
	}

	explain "New environment $name provisioned.\n";
});



# }}}
# genesis ci - generate pipeline YAML template file to be used by genesis repipe to generate a pipeline file. {{{
command("ci", <<EOF,
genesis v$VERSION
USAGE: genesis ci [--name ci.yml]

OPTIONS
$GLOBAL_USAGE
        --name          The name of the configuration yaml file to generate, default is `ci.yml'
    -f, --force         Force overwrite the configuration yaml file if it already exists.
        --vault-prefix  The prefix for any new vault secrets (default: concourse-ci)

EOF
sub {
	my (%options,%pipeline, $prompt, $default);

	options(\@_, \%options, qw/
		name=s
		vault=s
		vault-prefix=s
		force|f
	/);
	usage(1) if @_ != 0;
	check_prereqs;

	$ENV{GENESIS_CI_VAULT_PREFIX} = $options{'vault-prefix'}
		if $options{'vault-prefix'};
	$ENV{GENESIS_CI_VAULT_PREFIX} ||= "concourse-ci";

	my $name = $options{name} || "ci.yml";
	die "Pipeline configuration file '$name' already exists\n"
		if -f $name && ! $options{force};

	at_exit(sub {
		unlink "$name" unless $? == 0;
	});

	# Detect envs
	my %envs = valid_envs();
	die "\nERROR: No environments found -- cannot continue.\n\n"
		unless %envs;

	explain "\nGenerating new CI YAML Template #C{$name}...";

	target_vault($options{vault});

	explain "#Y{Setting Common Configuration}\n#Y{----------------------------}";

	$pipeline{name} = prompt_for_line(clean_heredoc(<<"	|EOF"), undef, basename(getcwd));
	|Please provide the name of you pipeline as you'd like it to appear in Concourse
	|EOF

	$pipeline{public} = prompt_for_boolean(clean_heredoc(<<"	|EOF"),0);
	|Would you like to make the Concourse pipeline (and all logs related to deployments) public?
	|EOF

	$pipeline{tagged} = prompt_for_boolean(clean_heredoc(<<"	|EOF"),0);
	|Would you like to use tags on each job (If unsure, choose no)?
	|EOF

	$pipeline{debug} = prompt_for_boolean(clean_heredoc(<<"	|EOF"),0);
	|Would you like to have debug output on BOSH jobs?
	|EOF

	$pipeline{skip_upkeep} = prompt_for_boolean(clean_heredoc(<<"	|EOF"), 0, "invert");
	|Would you like to automatically keep your stemcells up to date?
	|EOF

	my %chosen_envs;
	($pipeline{boshes},$pipeline{stemcells},%chosen_envs) = prompt_for_boshes_and_stemcells_for(!$pipeline{skip_upkeep}, %envs);

	$pipeline{layouts} = prompt_for_layouts_for(%chosen_envs);

	$pipeline{errands} = prompt_for_list("line",clean_heredoc(<<"	|EOF"), 'errand');
	|Enter any errands you'd like to use to test your deployments
	|e.g.: smoke-tests
	|EOF

	$pipeline{locker} = prompt_for_locker();

	$pipeline{vault} = prompt_for_vault($pipeline{name},%chosen_envs);

	$pipeline{git} = prompt_for_git($pipeline{name});

	do {
		$pipeline{notifications} = prompt_for_notifications();
		explain "\n#r{ERROR: You must have at least one notification system!}"
			unless %{$pipeline{notifications}};
	} until (%{$pipeline{notifications}});

	generate_ci_template_file(\%pipeline, $name);

	explain "\n#g{Generated CI template file:} #C{$name}\n";
});

#}}}
# genesis ci support method: prompt_for_git {{{
sub prompt_for_git {
	explain "\n#Y{Git Repository Details}";
	my $pipeline_name = shift;
	my %git;
	my ($user,$host,$org,$repo) = ("git","github.com",undef,$pipeline_name);
	my $gitremote = Genesis::Run::get('git config --get remote.origin.url');
	if ($gitremote) {
		chomp($gitremote);
		($user,$host,$org,$repo) = $gitremote =~ qr/^(?:ssh:\/\/([^@]+)@)?([^\/:]*)[\/:](?:(.*)\/)?([^\/]+)$/
		  if $gitremote =~ qr/^ssh:.*/;
	  ($host,$org,$repo) = $gitremote =~ qr/^https:\/\/([^\/:]*)[\/:](?:(.*)\/)?([^\/]+)$/
		if $gitremote =~ qr/^https:.*/;

		$repo =~ s/\.git$// if $repo;
	}

	$git{host} = prompt_for_line("What is the Git host?", undef, $host);
	$git{user} = prompt_for_line("What is the Git user on $git{host}?", undef, $user);
	$git{repo} = prompt_for_line("What is the name of the Git repository?", undef, $repo);
	$git{owner} = prompt_for_line("What organization owns the '$git{repo}' repository?", undef, $org);

	my $key_choice = prompt_for_choice(clean_heredoc(<<"	|EOF"),[qw|reuse add new|],'reuse',["Use existing key in Vault","Add an existing key in Vault", "Generate a new key"]);
	|How would you like to provide a SSH private key that has write access for $git{user}\@$git{host}.
	|EOF

	my $path = "secret/$ENV{GENESIS_CI_VAULT_PREFIX}/git-ssh/$git{user}\@$git{host}/$git{owner}/$git{repo}";
	if ($key_choice eq 'reuse') {
		$git{private_key} = prompt_for_line(clean_heredoc(<<"		|EOF"),undef,"$path:private", "vault_path_and_key");
		|What is the vault path for your git private key?
		|EOF
	} elsif ($key_choice eq 'new') {
		my $result = Genesis::Run::get('safe ssh 4096 "$1"', $path);
		die "Failed to generate Git SSH key: $result\n" if $? > 0;
		my $fingerprint = Genesis::Run::get('safe get "${1}:fingerprint"', $path);
		die "Failed to get SSH key fingerprint from $path:fingerprint\n$fingerprint\n" if $? > 0;
		my $pubkey = Genesis::Run::get('safe get "${1}:public"', $path);
		die "Failed to get public SSH key from $path:public\n$pubkey\n" if $? > 0;
		chomp($pubkey,$fingerprint);
		explain "\nGenerated 4096-bit SSH key (fingerprint: $fingerprint) in Vault under #W{$path}\n\n#R{IMPORTANT:} Add this PUBLIC key to your Git provider ($git{host}) to grant access for this pipeline:\n\n$pubkey";
		$git{private_key} = "$path:private";

	} else {
		my $key =  "private";
		my $vault_path = "$path:$key";
		my $answer = prompt_for_block("Enter your SSH private key for $git{user}\@$git{host}:$git{owner}/$git{repo}");
		my $tmpdir = workdir;
		open my $fh, ">", "$tmpdir/sshkeyforgit" or die "Could not write to $tmpdir/param: $!\n";
		print $fh $answer;
		close $fh;
		Genesis::Run::do_or_die(
			"Failed to save data to $vault_path in Vault",
			'safe set "$1" "${2}@${3}/sshkeyforgit"',
			$path, $key, $tmpdir
		);
		explain "Stored SSH private key in Vault under #W{$vault_path}";
		$git{private_key} = $vault_path;
	}
	return \%git;
}

#}}}
# genesis ci support method: prompt_for_notifications {{{
sub prompt_for_notifications {
	my (%notifications,$have_key);

	explain "\n#Y{Notification Details}";

	if (prompt_for_boolean("Would you like to configure Slack notification?", 1)) {
		$notifications{slack}{webhook} = prompt_for_line(clean_heredoc(<<"		|EOF"), undef, undef, "url");
		|What is your Slack Integration WebHook URL?
		|EOF
		$notifications{slack}{channel} = prompt_for_line("\nWhich slack channel which will receive notifications?");
	}

	if (prompt_for_boolean("Would you like to configure email notification via SMTP?", 0)) {
		$notifications{email}{smtp}{host} = prompt_for_line("\nWhat is the SMTP host?");
		$notifications{email}{smtp}{port} = prompt_for_line("\nWhat is the SMTP port?", undef, undef, "0-65535");
		$notifications{email}{smtp}{username} = prompt_for_line("\nWhat is the SMTP username?");

		$have_key = prompt_for_boolean(clean_heredoc(<<"		|EOF"));
		|You will need to provide the password for your SMTP user.  Do you already have this
		|available in your vault?
		|EOF

		if ($have_key) {
			$notifications{email}{smtp}{password} = prompt_for_line(clean_heredoc(<<"			|EOF"),undef,undef, "vault_path_and_key");
			|What is the vault path for your email SMTP password?
			|ex: secret/notifications/email/smtp:password
			|EOF
		} else {
			my $path = "secret/$ENV{GENESIS_CI_VAULT_PREFIX}/notifications/smtp/$notifications{email}{smtp}{host}/$notifications{email}{smtp}{username}";
			my $key =  "password";
			my $vault_path = "$path:$key";
			Genesis::Run::interact(
				{onfailure => "Failed to save data to $vault_path in Vault"},
				'safe prompt "$1" -- set "$2", "$3"',
				"What is your email SMTP password?", $path, $key
			);
			explain "Stored SMTP password in Vault under #W{$vault_path}";
			$notifications{email}{smtp}{password} = $vault_path;
		}
		$notifications{email}{to} = prompt_for_line("What email address will the notifications be sent to?");
		$notifications{email}{from} = prompt_for_line("What email address will the notifictions will be sent from?");
	}

	if (prompt_for_boolean("Would you like to configure HipChat notification?", 0)) {
		$have_key = prompt_for_boolean(clean_heredoc(<<"		|EOF"));
		|You will need to provide the HipChat notification token.  Do you already have this
		|available in your vault?
		|EOF

		if ($have_key) {
			$notifications{hipchat}{token} = prompt_for_line(clean_heredoc(<<"			|EOF"),undef,undef, "vault_path_and_key");
			|What is the vault path for your HipChat token?
			|ex: secret/notifications/hipchat:token
			|EOF
		} else {
			my $path = "secret/$ENV{GENESIS_CI_VAULT_PREFIX}/notifications/smtp/$notifications{email}{smtp}{host}/$notifications{email}{smtp}{username}";
			my $key =  "token";
			my $vault_path = "$path:$key";
			Genesis::Run::interact(
				{onfailure => "Failed to save data to $vault_path in Vault"},
				'safe prompt "$1" -- set "$2" "$3"',
				"What is your HipChat token?", $path, $key
			);

			explain "Stored HipChat token in Vault under #W{$vault_path}";
			$notifications{hipchat}{token} = $vault_path;
		}
		$notifications{hipchat}{room_id} = prompt_for_line("What is the ID of the room you want the notifications posted to?");
	}
	return \%notifications;
}

#}}}
# genesis ci support method: prompt_for_locker {{{
sub prompt_for_locker {
	my (%locker);

	explain "\n#Y{Workflow Details}";
	my $use_locker = prompt_for_boolean(clean_heredoc(<<"	|EOF"),1);
	|Locker is simple web app for managing locks.  Genesis pipelines can use it to prevent
	|multiple pipelines utilizing the same BOSH targets at the same time.  It is deployed
	|to the Concourse database node if you use the Concourse Genesis Kit to deploy Concourse.
	|
	|Would you like to use Locker?
	|EOF
	if ($use_locker) {
		$locker{url} = prompt_for_line("What is the URL to the locker API?", undef, undef, "url");
		$locker{username} = prompt_for_line("What is the locker API username?");
		my $have_key = prompt_for_boolean(clean_heredoc(<<"		|EOF"));
		|You will need to provide the Locker API password.  Do you already have this
		|available in your vault?
		|EOF

		if ($have_key) {
			$locker{password} = prompt_for_line(clean_heredoc(<<"			|EOF"),undef,undef, "vault_path_and_key");
			|What is the vault path for the Locker API password?
			|ex: secret/bosh/lite/concourse/locker/api:password
			|EOF
		} else {
			my $slug = $locker{url};
			$slug =~ s#^https?://##;
			$slug =~ s#[^a-zA-Z0-9\._-]+#_#g;
			my $path = "secret/$ENV{GENESIS_CI_VAULT_PREFIX}/locker/$slug";
			my $key =  "password";
			my $vault_path = "$path:$key";
			Genesis::Run::interact(
				{onfailure => "Failed to save data to $vault_path in Vault"},
				'safe prompt "$1" -- set "$2" "$3"',
				"What is your Locker API password?", $path, $key
			);
			explain "Stored Locker API password in Vault under #W{$vault_path}";
			$locker{password} = $vault_path;
		}
	}
	return \%locker;
}

#}}}
# genesis ci support method: prompt_for_vault {{{
sub prompt_for_vault {
	my ($name, %envs) = @_;
	explain "\n#Y{Vault Connection Details}";
	my (%vault,$safe_json);
	if (-f "$ENV{HOME}/.saferc") {
		eval {
			$safe_json = decode_json(Genesis::Run::get('spruce json "$HOME/.saferc"'));
		};
	}
	if ($@ || ! $safe_json) {
		$vault{url} = prompt_for_line("\nWhat is the Vault URL?", undef, undef,"url");
		$vault{verify} = prompt_for_boolean("\nDo you want to skip SSL verification?\n\nDefault is no.\n", 0, 'invert');
	} elsif ($safe_json->{version} && $safe_json->{version}==1) {
		$vault{url} = $safe_json->{vaults}{$safe_json->{current}}{url};
		$vault{verify} = ! $safe_json->{vaults}{$safe_json->{current}}{skip_verify};
	} else {
		$vault{url} = $safe_json->{Aliases}{$safe_json->{Current}};
		$vault{verify} = ! $safe_json->{SkipVerify}{$vault{url}};
	}

	my $default_approle_path = "secret/$ENV{GENESIS_CI_VAULT_PREFIX}/$name/vault";
	my ($regenerate, $c);

	if (safe_path_exists $default_approle_path) {
		my $choices = ["use","regen","alt","skip"];
		my $labels = [
			"Use this path for role_id and secret_id",
			"Regenerate new credentials to this path",
			"Specify alternate paths for role_id and secret_id",
			"Manually add it later - do this if you do not have write-access to approle"
		];
		$c = prompt_for_choice(clean_heredoc(<<"		|EOF"),$choices,"use",$labels);
		|Discovered Concourse AppRole credentials at $default_approle_path.
		|Do you want to:
		|EOF
	} else {
		my $choices = ["regen","alt","skip"];
		my $labels = [
			"Generate credentials to this path",
			"Specify alternate paths for role_id and secret_id",
			"Manually add it later - do this if you do not have write-access to approle"
		];
		$c = prompt_for_choice(clean_heredoc(<<"		|EOF"),$choices,"use",$labels);
		|Could not find Concourse AppRole credentials at $default_approle_path.
		|Do you want to:
		|EOF
	}
	if ($c eq "use" || $c eq "regen") {
		$regenerate = ($c eq "regen");
		$vault{role}   = $default_approle_path . ":role_id";
		$vault{secret} = $default_approle_path . ":secret_id";
	} elsif ($c eq "skip") {
		$vault{role}   = "";
		$vault{secret} = "";
	} else {
		$vault{role} = prompt_for_line(clean_heredoc(<<"		|EOF"),undef,"$default_approle_path:role_id","/secret\/.*[^\/]:.+", "Expecting secret/<path>:<key>");
		|Please specify the path in Vault that contains the vault Role ID for Concourse
		|EOF
		$vault{secret} = prompt_for_line(clean_heredoc(<<"		|EOF"),undef,"$default_approle_path:secret_id",,"/secret\/.*[^\/]:.+", "Expecting secret/<path>:<key>");
		|Please specify the path in Vault that contains the vault Secret ID for Concourse
		|EOF

		unless (safe_path_exists $vault{role} && safe_path_exists $vault{secret}) {
			explain "#R{WARNING: $vault{role} doesn't exist!" unless safe_path_exists $vault{role};
			explain "#R{WARNING: $vault{secret} doesn't exist!" unless safe_path_exists $vault{secret};
			die "Exiting.\n" unless prompt_for_boolean(clean_heredoc(<<"			|EOF"));
			|To use these paths, the Concourse AppRole credentials will have to be (re-)generated.
			|Continue [y|n]?
			|EOF
			$regenerate = 1;
		}
	}

	if ($regenerate) {
		my @paths;
		foreach (keys %envs) {
			my $env = $envs{$_}{env};
			explain "#Y{Determining Vault paths needed for $env ...}\n";

			my $dir = workdir;
			if (is_create_env($env)) {
				write_stemcell_data("$dir/cloud.yml"); # Why write stemcell to cloud.yml??!!
			} else {
				bosh_download_cloud_config(bosh_target_for($env), "$dir/cloud.yml");
			}
			my %options = ('cloud-config' => "$dir/cloud.yml");
			my $vault_prefix = $envs{$_}{vault};
			push @paths, "secret/$vault_prefix/*";
			my @merge_files = @{merge_files($envs{$_}{file}, \%options)};
			for my $extra_path (sort grep {chomp; $_ !~ m/^secret\/$vault_prefix\// } spruce_vault_paths(@merge_files)) {
				push @paths, $extra_path;
			}
		}
		push @paths, "secret/handshake";
		generate_ci_approle_policies(
			$name,
			$vault{role},
			$vault{secret},
			@paths
		)
	};

	return \%vault;
}

#}}}
# genesis ci support method: prompt_for_boshes_and_stemcells_for {{{
sub prompt_for_boshes_and_stemcells_for {
	my ($ask_stemcells, %envs) = @_;

	# Get the current boshes
	my (%boshes, %chosen_envs);
	if (-f $ENV{HOME}."/.bosh/config") {
		my $bosh_json = decode_json(Genesis::Run::get('spruce json "$HOME/.bosh/config"'));
		$boshes{$_->{alias}} = {
			url => (($_->{url} =~ /:\d+$/) ? $_->{url} : $_->{url}.":25555"),
		} foreach (@{$bosh_json->{environments}});
		foreach (keys %boshes) {
			# Add the url (with and without port) to the lookup map.
			$boshes{$boshes{$_}{url}} = $boshes{$_};
			(my $url = $boshes{$_}{url}) =~ s /:\d+$//;
			$boshes{$url} = $boshes{$_};
		}
	}

	explain "\n#Y{Processing Detected Environments}\n#Y{--------------------------------}";

	my (%boshenvs,%used_stemcells);
	foreach my $e (sort keys(%envs)) {
		my $env = $envs{$e}{env};
		explain "\n#W{==> Environment:} #C{$env} (./$envs{$e}{file})";
		next unless prompt_for_boolean("Do you want to use this environment [y|n]?", 1);
		$chosen_envs{$e} = $envs{$e};

		$boshenvs{$env} = {};
		my %bosh_info = $boshes{$envs{$e}{bosh}} ? %{$boshes{$envs{$e}{bosh} }} : ();
		# Get display name (defaults to environment)
		$boshenvs{$env}{alias} = prompt_for_line("Display name", undef, $env);

		if ($bosh_info{url}) {
			# Found in .bosh/config (either alias or url)
			$boshenvs{$env}{url} = $bosh_info{url};
			explain "\nUsing BOSH director at #C{$boshenvs{$env}{url}}";
		} else {
			# Not found -- need info
			if (is_valid_uri($envs{$e}{bosh})) {
				$boshenvs{$env}{url} = $envs{$e}{bosh};
				explain "\nUsing BOSH director at #C{$boshenvs{$env}{url}}";
			} else {
				$boshenvs{$env}{url} = prompt_for_line("Could not determine BOSH url for alias `$e` -- please specify fully\ne.g.: https://10.0.1.44:25555");
				$boshenvs{$env}{url} .= ":25555" unless $boshenvs{$env}{url} =~ m/:\d+$/;
			}
		}

		$boshenvs{$env}{username} = prompt_for_line(
			undef,
			"Concourse Username",
			"concourse "
		);

		my $prefix = "secret/". vault_slug($envs{$e}{bosh});
		if (safe_path_exists("$prefix/bosh/users/concourse:password")) {
			$boshenvs{$env}{password} = "$prefix/bosh/users/concourse:password";
			explain "\nUsing BOSH concourse user password in Vault under #C{'$boshenvs{$env}{password}'}";
		} else {
			$boshenvs{$env}{password} = prompt_for_line(clean_heredoc(<<"			|EOF"),"Specify vault path", undef, "vault_path_and_key");
			|Could not locate the password for concourse user in Vault under:
			|$prefix/bosh/users/concourse:password.
			|EOF
		}
		if (safe_path_exists("$prefix/bosh/ssl/ca:certificate")) {
			$boshenvs{$env}{ca_cert} = "$prefix/bosh/ssl/ca:certificate";
			explain "\nUsing BOSH CA Certificate in Vault under #C{'$boshenvs{$env}{ca_cert}'}";
		} else {
			$boshenvs{$env}{ca_cert} = prompt_for_line(clean_heredoc(<<"			|EOF"),"Specify vault path", undef, "vault_path_and_key");
			|Could not locate the BOSH SSL CA certificate in Vault under:
			|$prefix/bosh/ssl/ca:certificate.
			|EOF
		}

		my ($stemcells, %candidates) = ([]);
		if ($ask_stemcells) {
			explain "\nFetching stemcells from BOSH...";
			my $bosh_client = $boshenvs{$env}{username};
			my $bosh_ca_cert = Genesis::Run::get('safe get "$1"', $boshenvs{$env}{ca_cert});
			my $bosh_client_secret = Genesis::Run::get('safe get "$1"', $boshenvs{$env}{password});
			my $sc_info = Genesis::Run::bosh({
				onfailure => "Could not retrieve stemcells",
				env => {
					BOSH_CA_CERT => $bosh_ca_cert,
					BOSH_CLIENT => $bosh_client,
					BOSH_CLIENT_SECRET => $bosh_client_secret,
				}}, 
				'-e "$1" stemcells', $boshenvs{$env}{url}
			);
			my (@choices, @labels);
			foreach (split("\n", $sc_info)) {
				my ($stemcell, undef, $os) = split(' ',  $_);
				next unless $stemcell;

				my ($alias) = split("-$os-",$stemcell);
				$alias =~ s/^bosh-//;
				$alias .= '-$os' if $candidates{$alias} &&($candidates{$alias} ne $stemcell);
				next if $candidates{$alias};
				$candidates{$alias} = $stemcell;
				push @choices, $alias;
				push @labels, $stemcell;
			}
			$stemcells = prompt_for_choices("Select one or more stemcells to watch for updates",\@choices,1,undef,\@labels);
		}
		$boshenvs{$env}{stemcells} = $stemcells;
		$used_stemcells{$_} = $candidates{$_} foreach (@$stemcells);

		print "\n";
	}

	die "NO REMAINING ENVIRONMENTS - Cannot continue!\n" unless %chosen_envs;

	return (\%boshenvs, \%used_stemcells, %chosen_envs);
}

#}}}
# genesis ci support method: prompt_for_layouts_for {{{
sub prompt_for_layouts_for {
	my %envs = @_;

	explain "\n#Y{Buliding Pipeline Layouts}\n#Y{-------------------------}";
	my %layouts = ();
	my $default_layout = "default";
	my $validate = undef;
	do {
		my $name = prompt_for_line("Name of ".ordify(keys(%layouts) + 1)."layout", undef, $default_layout, $validate);
		$default_layout = undef if $default_layout && $name eq $default_layout;

		explain "\n#G{Valid deployment environments:} ".join(", ", sort keys(%envs))."";
		my $validate_pathway = sub() {
			my @valid_envs = grep {defined($envs{$_})} split(" -> ",$_[0]);
			my @invalid_envs = grep {!defined($envs{$_})} split(" -> ",$_[0]);
			return "Unknown environment specified: ${\join(', ', map {qq('$_')} @invalid_envs)}" if @invalid_envs;
			return "No environments specified" unless @valid_envs;
			# TODO: also check for duplicates and cycles
			return "";
		};

		$layouts{$name}{deployments_chains} = prompt_for_list("line", clean_heredoc(<<"		|EOF"),"deployment pathway",1,undef,$validate_pathway,undef,"\n\nSpecify one or more deployment pathways (leave empty to end)\n" );
		|Deployment pathways describe the flow of the pipeline from one passing deployment
		|to the next.  You can specify multiple pathways, and reuse environments across
		|pathways, as long as no cycles are created.
		|e.g.:  ${\join(" -> ", sort keys(%envs))}
		|EOF

		my $auto_triggers = prompt_for_choices(clean_heredoc(<<"		|EOF"), [(sort keys(%envs))]);
		|
		|What deployments do you want to automaticlly trigger when there are corresponding
		|deployment or stemcell changes?
		|EOF

		$layouts{$name}{auto} = join(" ",@$auto_triggers);
		$validate = "![".join(",",keys(%layouts))."]";

	} while (prompt_for_boolean("Would you like to enter another layout for your pipeline?"));
	return \%layouts;
}

#}}}
# genesis ci support method: generate_ci_template_file {{{
sub generate_ci_template_file() {
	my ($pipeline, $name) = @_;

	open my $OUT, ">", $name or die "Unable to open $name for writing: $!\n";
	print $OUT <<"EOF";
pipeline:
  name: $pipeline->{name}

  public:      ${\boolean_to_yaml($pipeline->{public})}
  tagged:      ${\boolean_to_yaml($pipeline->{tagged})}
  debug:       ${\boolean_to_yaml($pipeline->{debug})}
  skip_upkeep: ${\boolean_to_yaml($pipeline->{skip_upkeep})}

  git:
EOF

	my @components = ("owner","repo");
	unshift(@components, "host") unless $pipeline->{git}{host} eq "github.com";
	unshift(@components, "user") unless $pipeline->{git}{user} eq "git";
	foreach (@components) {
		my $label = sprintf("%-13s", "$_:");
		print $OUT <<"EOF";
    $label$pipeline->{git}{$_}
EOF
	}
	my $role_op = $pipeline->{vault}{role}
		? "vault \"$pipeline->{vault}{role}\""
		: "param \"Please provide a vault path for pipeline.vault.role\"";
	my $secret_op = $pipeline->{vault}{secret}
		? "vault \"$pipeline->{vault}{secret}\""
		: "param \"Please provide a vault path for pipeline.vault.secret\"";
	print $OUT <<"EOF";
    private_key: (( vault "$pipeline->{git}{private_key}" ))

  vault:
    role:   (( $role_op ))
    secret: (( $secret_op ))
    url:    $pipeline->{vault}{url}
    verify: ${\boolean_to_yaml($pipeline->{vault}{verify})}
EOF

	if ($pipeline->{notifications}{slack}{webhook}) {
		print $OUT <<"EOF";

  slack:
    webhook: "$pipeline->{notifications}{slack}{webhook}"
    channel: "$pipeline->{notifications}{slack}{channel}"
EOF
	}

	if ($pipeline->{notifications}{hipchat}{token}) {
		print $OUT <<"EOF";

  hipchat:
    token:   (( vault "$pipeline->{notifications}{hipchat}{token}" ))
    room_id: $pipeline->{notifications}{hipchat}{room_id}
EOF
	}

	if ($pipeline->{notifications}{email}{to}) {
		print $OUT <<"EOF";

  email:
    to:   $pipeline->{notifications}{email}{to}
    from: $pipeline->{notifications}{email}{from}
    smtp:
      username: $pipeline->{notifications}{email}{smtp}{username}
      password: (( vault "$pipeline->{notifications}{email}{smtp}{password}" ))
      host:     $pipeline->{notifications}{email}{smtp}{host}
      port:     $pipeline->{notifications}{email}{smtp}{port}
EOF
	}

	if ($pipeline->{locker}{url}) {
		print $OUT <<"EOF";

  locker:
    url:      $pipeline->{locker}{url}
    username: $pipeline->{locker}{username}
    password: (( vault "$pipeline->{locker}{password}" ))
EOF
	}

	my @stemcells = split("\n",$pipeline->{stemcells});
	print $OUT <<"EOF";

  stemcells:${\(scalar(keys %{$pipeline->{stemcells}}) ? "" : " {}")}
EOF
	foreach my $alias (keys %{$pipeline->{stemcells}}) {
		print $OUT <<"EOF"
    $alias: $pipeline->{stemcells}{$alias}
EOF
	}

	print $OUT <<"EOF";

  boshes:
EOF
	foreach my $env (keys %{$pipeline->{boshes}}) {
		print $OUT <<"EOF";
    $env:
      alias:     $pipeline->{boshes}{$env}{alias}
      url:       $pipeline->{boshes}{$env}{url}
      ca_cert:   (( vault "$pipeline->{boshes}{$env}{ca_cert}" ))
      username:  $pipeline->{boshes}{$env}{username}
      password:  (( vault "$pipeline->{boshes}{$env}{password}" ))
      stemcells: ${\(scalar(@{$pipeline->{boshes}{$env}{stemcells}}) ? "" : " []")}
EOF
		foreach my $i ( 0 .. $#{ $pipeline->{boshes}{$env}{stemcells} } ) {
			print $OUT <<"EOF";
      - $pipeline->{boshes}{$env}{stemcells}[$i]
EOF
		}
		print $OUT "\n";
	}

	print $OUT <<"EOF";
  layouts:
EOF
	foreach my $layout (keys %{$pipeline->{layouts}}) {
		print $OUT <<"EOF";
    $layout: |+
      auto $pipeline->{layouts}{$layout}{auto}
EOF
		print $OUT "      $_\n" foreach (@{$pipeline->{layouts}{$layout}{deployments_chains}});
		print $OUT "\n";
	}

	if ($pipeline->{errands}) {
		my @errands;
		for my $i ( 0 .. $#{ $pipeline->{errands} } ) {
			push (@errands, $pipeline->{errands}[$i]);
		}
		my $errands = "[".join(",", @errands)."]";

		print $OUT <<"EOF";
  errands: $errands
EOF
	}

	close $OUT;
}
#}}}
# genesis deploy - Pull in Cloud Config, Generate a manifest, deploy {{{

command("deploy", <<EOF,
genesis v$VERSION
USAGE: genesis deploy <options> env-name[.yml]

OPTIONS
$GLOBAL_USAGE
  -n, --non-interactive  Do not ask any questions, assume 'y' for any that would
                         normally be asked.  Allows automation to deploy without
                         requiring human intervention or expect-style scripting.

      --[no-]redact      Determines if values are shown on the diff output.  By
                         default, the manifest will be redacted unless being
                         output to the live console.
      --skip-drain xxx   Skip running drain scripts for specific instance group.
                         Can be specified multiple times.

      --canaries #       Override the default number of canary VMs per instance
                         group.

      --max-in-flight #  Override the default number of maximum VMs in flight
                         per instance group.

Can specify one of the follow three:
      --dry-run          Build the manifest and validate it against the current
                         state of the BOSH director for this deployment, but
                         doesn't change anything.

      --recreate         Recreate all VMs instead of just applying changes to them.

      --fix              Only recreate VMs that are unresponsive.

EOF
sub {
	my %options = (redact => ! controlling_terminal);
	options(\@_, \%options, qw/
		non-interactive|n
		redact!
		fix
		recreate
		dry-run
		skip-drain=s@
		canaries=i
		max-in-flight=i
	/);
	usage(1) if @_ != 1;
	my $env = get_env(shift);
	check_prereqs;

	if (scalar(grep {$_} ($options{fix}, $options{recreate}, $options{'dry-run'})) > 1) {
		usage(1,"Can only specify one of --dry-run, --fix or --recreate");
	}

	if ($options{'non-interactive'}) {
		$ENV{BOSH_NON_INTERACTIVE}='true';
		delete $options{'non-interactive'};
	}

	my $rc = deploy_manifest($env, \%options);
	exit $rc;
});
# }}}
# genesis secrets - Generate / Rotate required credentials for an environment. {{{

command("secrets", <<EOF,
genesis v$VERSION
USAGE: genesis secrets [check|add|rotate [--force]] [--vault target] deployment-env.yml

Checks, adds or rotates secrets for your deployment.

  * check:  Checks that all required secrets are present.  Returns a exit code
            of 1 if any are missing, and lists them, otherwise states all
            secrets are present and exits with 0.

  * add:    Generates any missing secrets required by the deployment.  Useful
            to generate credentials after upgrading kits or if `genesis new
            --no-secrets` was used to create the deployment.

  * rotate: Generates new secrets for your deployment. If any credentials were
            marked by the kit as `fixed', they are not updated unless the
            `--force` option was also specified.

OPTIONS
$GLOBAL_USAGE
  -f, --force        Rotate *ALL* credentials, including any credentials that
                     the kit defined as `fixed'. This is very dangerous.  Only
                     applies to `rotate`

      --vault        The name of a `safe' target (a Vault) to store newly
                     generated credentials in.

EOF
sub {
	my %options;
	options(\@_, \%options, qw/
		force|force-rotate-all|f
		vault=s
	/);

	my ($action, $name) = @_;
	if (!$name) {
		die "Must specify environment name\n" if $action =~ m/^(check|add|rotate)$/;
		$name = $action;
		$action = 'check';
	}
	usage(1) if @_ < 1 or @_ > 2;
	usage(1, "Must specify check, add or rotate, not $action")
		unless (grep {$_ eq $action} qw(check add rotate));
	if ($options{force}) {
		usage(1, "Can only specify --force with rotate") if $action ne 'rotate';
		$action = 'force';
	}

	check_prereqs;

	$name =~ s/\.yml$//;
	die "No environment file named $name exists.\n" unless -f $name.".yml";
	my $prefix = get_key($name, 'params.vault');
	unless ($prefix) {
		$prefix = vault_slug($name)."-".deployment_suffix;
	}
	my $deployment = $name . "-" . deployment_suffix;

	my ($kit, $version) = kit_name_and_version_for($name);
	my $meta = read_kit_metadata($kit, $version);
	target_vault($options{vault});

	if ($action eq "check") {
		exit check_secrets(   $meta,
			env       => $name,
			prefix    => $prefix,
			features  => get_key($name, 'kit.features', get_key($name, 'kit.subkits', []))
		);
	} else {
		vaultify_secrets($meta,
			env       => $name,
			prefix    => $prefix,
			features  => get_key($name, 'kit.features', get_key($name, 'kit.subkits', [])),
			scope     => $action
		);
	}
});

# }}}
# genesis yamls - Print a list of the YAML files used for a single environment. {{{

command("yamls", <<EOF,
genesis v$VERSION
USAGE: genesis yamls [--include-kit] deployment-env.yml

OPTIONS
      --include-kit This is also include the files that will be merges from the kit.
$GLOBAL_USAGE
EOF
sub {
	my %options;
	options(\@_, \%options, qw/
		include-kit
	/);
	usage(1) if @_ != 1;
	check_prereqs;

	my ($kit,$version) = kit_name_and_version_for($_[0]);
	my @yamls;
	if ($options{"include-kit"}) {
		push @yamls, kit_yaml_files($_[0]);
		if ($kit && $kit ne "dev") {
			my $cache_dir = Cwd::abs_path($KIT_CACHE_DIR{"$kit/$version"});
			@yamls = map {$_ =~ s%^$cache_dir/%\@kit($kit/$version):%; $_} @yamls;
		}
	}
	push @yamls, mergeable_yaml_files($_[0]);
	print "$_\n" for @yamls;
});

# }}}
# genesis create-kit - Create the structure for a new kit {{{
#
command("create-kit", <<EOF,
genesis v$VERSION
USAGE: genesis create-kit -d|--dev -n NAME [FEATURE ...]

OPTIONS
$GLOBAL_USAGE
  -d, --dev       create kit in ./dev directory instead of <name>-genesis-kit
  -n, --name      Name of the kit archive.
EOF
sub {
	my %options;
	options(\@_, \%options, qw/
		name|n=s
		dev|d
	/);
	usage(2) unless $options{name};
	check_prereqs(no_repo_needed => ! $options{dev}); # only require repo if in dev mode

	my $dir = ($options{cwd} || ".") . "/". ($options{dev} ? "dev" : "$options{name}-genesis-kit");

	die "$dir already exists, cowardly refusing to overwrite it\n"
	  if -d $dir;

	mkdir_or_fail $dir;
	mkdir_or_fail "$dir/base";

	mkfile_or_fail "$dir/gitignore", <<EOF;
*.tar.gz
EOF
	mkfile_or_fail "$dir/base/params.yml", <<EOF;
---
# Contains the defaults for the parameters needed for the base $options{name} kit.
params: {}
EOF
	mkfile_or_fail "$dir/base/$options{name}.yml", <<EOF;
---
# Contains the configuration for base $options{name} kit.
instance_groups: {}
properties: {}

releases:
- name: $options{name}
  version:
  sha1:
  url:

EOF
	mkfile_or_fail "$dir/base/0-deployment.yml", <<EOF;
---
# Contains the instance_groups in install order, as well as the stemcells and
# update stanzas for the base $options{name} kit.
instance_groups:
- name: *jobname*
  instances: 1
  azs: (( grab params.availability_zones ))
  stemcell: default
  persistent_disk_pool: (( grab params.disk_pool ))
  networks:
  - name: (( grab params.network ))
    static_ips: (( static_ips(0) ))
  vm_type: (( grab params.vm_type ))
  update:
    max_in_flight: 1

stemcells:
- alias: default
  os: (( grab params.stemcell_os ))
  version: (( grab params.stemcell_version ))

meta:
  vault: (( concat "secret/" params.vault ))

update:
  serial: false
  canaries: 1
  canary_watch_time: 30000-600000
  update_watch_time: 5000-600000
  max_in_flight: 1
  max_errors: 1
EOF

	# Features (backwards compatibility named Subkits)
	mkdir_or_fail "$dir/features";
	my ($feature_groups, $feature_param_groups, $feature_prompts, @feature_names);
	foreach my $feature_req (@_) {
		my ($feature,$prompt) = split("=",$feature_req, 2);
		push @feature_names, $feature;
		mkdir_or_fail "$dir/features/$feature";
		$feature_groups .= "  $feature: {}\n";
		$feature_param_groups .= "  $feature: []\n";
		next if defined($prompt) && $prompt eq '-';
		$prompt ||= "Do you want to use feature '$feature'?";
		$feature_prompts .= "- prompt: $prompt\n  feature: $feature\n";

		mkfile_or_fail "$dir/features/$feature/params.yml", "---\nparams: {}\n";
		mkfile_or_fail "$dir/features/$feature/$feature.yml", "--- {}\n";
	}

	my $features = "";
	if ($feature_prompts) {
		$features = "features:\n$feature_prompts";
	} else {
		$features = "features: []\n";
	}

	my $gen_version="";
	if (is_semver $VERSION) {
		$gen_version = "\ngenesis_min_version: $VERSION\n";
	} else {
		print STDERR csprintf("\n#R{Warning:} Using development version of Genesis -- cannot specify minimum Genesis version\n");
	}

	my $user = Genesis::Run::get('git config user.name');
	my $email = Genesis::Run::get('git config user.email');
	mkfile_or_fail "$dir/kit.yml", <<EOF;
---
name: $options{name}
version: 0.0.1
author: $user <$email>
homepage: https://github.com/cloudfoundry-community/$options{name}-boshrelease
github: https://github.com/genesis-community/$options{name}-genesis-kit
$gen_version
$features
params:
  base: []
$feature_param_groups
credentials:
  base: {}
$feature_groups
certificates:
  base: {}
$feature_groups
EOF

	mkfile_or_fail "$dir/README.md", <<EOF;
$options{name} Genesis Kit
=================

FIXME: The kit author should have filled this in with details about
what this is, and what it provides. But they have not, and that is sad.
Perhaps a GitHub issue should be opened to remind them of this?

Quick Start
-----------

To use it, you don't even need to clone this repository! Just run
the following (using Genesis v2):

```
# create a $options{name}-deployments repo using the latest version of the $options{name} kit
genesis init --kit $options{name}

# create a $options{name}-deployments repo using v1.0.0 of the $options{name} kit
genesis init --kit $options{name}/1.0.0

# create a my-$options{name}-configs repo using the latest version of the $options{name} kit
genesis init --kit $options{name} -d my-$options{name}-configs
```

Once created, refer to the deployment repo's README for information on creating

Features
-------

FIXME: The kit author should have filled this in with details
about what features are defined, and how they affect the deployment. But they
have not, and that is sad. Perhaps a GitHub issue should be opened to remind
them of this?

Params
------

FIXME: The kit author should have filled this in with details about the params
present in the base kit, as well as each feature defined. These should likely
be in different sections (one for base, one per feature). Unfortunately,
the author has not done this, and that is sad. Perhaps a GitHub issue
should be opened to remind them of this?

Cloud Config
------------

FIXME: The kit author should have filled in this section with details about
what cloud config definitions this kit expects to see in play and how to
override them. Also useful are hints at default values for disk + vm sizing,
scaling considerations, and other miscellaneous IaaS components that the deployment
might require, like load balancers.

EOF

	mkdir_or_fail "$dir/hooks";
	mkfile_or_fail "$dir/hooks/blueprint", generate_blueprint_script(@feature_names);

	explain "\n#G{Created new Genesis kit '}#C{$options{name}}#G{' in directory }#C{$dir}\n\n"
});

# }}}
# genesis compile-kit - Create a distributable kit archive from dev/. {{{

command("compile-kit", <<EOF,
genesis v$VERSION
USAGE: genesis compile-kit -v VERSION [-n NAME] [-d|--dev]

OPTIONS
$GLOBAL_USAGE

  -v, --version Version to package.

  -n, --name    Name of the kit archive.  If not provided, will take the name
                of the current (or specified with -C) directory before the
                suffix of -genesis-kit (standalone mode) or -deployments
                (dev mode).

  -d, --dev     Compile based off of a dev-kit (./dev). If not specified,
                genesis will compile based off of ./<name>-genesis-kit.
                Automatically set if run from inside a genesis deployments directory.

  -f, --force   Proceed with compilation even if there are unstaged or uncommitted
                changes in the working directory.  Normally, genesis will refuse
                to continue when this happens.
EOF
sub {
	my %options;
	options(\@_, \%options, qw/
		dev|d
		name|n=s
		version|v=s
		force|f
	/);
	usage(1) if @_ != 0;

	my $dir;
	unless ($options{name}) {
		my $pwd = abs_path($options{cwd} || getcwd);
		if ($pwd =~ /\/([^\/]*)-deployments(\/)?$/) {
		# Building from a dev inside a deployment repo - gleen the name
			$options{name} = $1;
			$dir = "$pwd/dev";
			$options{dev} = 1;
		} elsif ($pwd =~ /\/([^\/]*)-genesis-kit(\/)?$/) {
			$options{name} = $1;
			$dir = $pwd;
			die "Current directory is a kit -- cannot specify dev mode\n"
				if $options{dev};
		}
	}
	usage(1, "Missing name option, cannot determine from `pwd`") unless $options{name};
	usage(1) unless $options{version};
	check_prereqs(no_repo_needed => 1);

	unless ($dir) {
		if ($options{dev}) {
			$dir = ($options{cwd} || ".") . "/dev";
			die "$dir does not exist -- cannot continue compiling dev kit.\n" unless -d $dir;
		} else {
			$dir = ($options{cwd} || ".");
			$dir .= "/$options{name}-genesis-kit"
				if (! -f "$dir/kit.yml" && -d "/$options{name}-genesis-kit");
		}
	}

	my $metadata = validate_kit_files($dir,1);
	validate_kit_metadata($options{name},$options{version},$metadata,1);

	my $temp = tempdir(CLEANUP => 1);
	my $stem = "$options{name}-$options{version}";
	mkdir_or_fail "$temp/$stem";
	run('cp -aH "${1}"/* "${2}/${3}"', $dir, $temp, $stem);
	run('rm -rf "${1}/${2}/"{.git,.gitignore,*.tar.gz,ci}', $temp, $stem);
	run(
		'echo "version: ${1}" | spruce merge "${2}/kit.yml" - > "${3}/${4}/kit.yml"',
		$options{version}, $dir, $temp, $stem
	);

	if (!$options{force}) {
		my $changes = Genesis::Run::get('git status --porcelain');
		if ($? == 0 && $changes) {
			error "\n#R{ERROR}: Unstaged / uncommited changes found in working directory.\n".
			      "Please either #C{stash} or #C{commit} those changes before compiling your kit.\n";
			exit 1;
		}
	}
	run('tar -czf "${2}.tar.gz" -C "$1" "$2/"', $temp, $stem);

	printf "Created $stem.tar.gz\n\n";
});

# }}}
# genesis decompile-kit - Unpack a kit archive to dev/. {{{

command("decompile-kit", <<EOF,
genesis v$VERSION
USAGE: genesis decompile-kit [NAME/VERSION | path/to/kit.tar.gz]

OPTIONS
$GLOBAL_USAGE
  -f, --force  Overwrite dev/, if it exists.
EOF
sub {
	my %options;
	options(\@_, \%options, qw/
		force|f
	/);
	usage(1) if @_ != 1;
	check_prereqs;

	if (-d "dev" && !$options{force}) {
		die "dev/ directory already exists (and --force not specified).  Bailing out.\n";
	}

	my $temp = tempdir(CLEANUP => 1);
	my $file = $_[0];
	if (! -f $file) {
		(my $stem = $file) =~ s|/|-|;
		$file = ".genesis/kits/$stem.tar.gz";
	}
	-f $file or die "Unable to find Kit archive $_[0]\n";

	run('tar -xzf "$1" -C "$2" && rm -rf dev && mv "${2}/*/" dev/', $file, $temp);
});

# }}}
# genesis manifest - Compile a deployment manifest. {{{

command("manifest", <<EOF,
genesis v$VERSION
USAGE: genesis manifest [--no-redact] [--cloud-config path.yml] deployment-env.yml

OPTIONS
$GLOBAL_USAGE

  -c, --cloud-config PATH    Path to your downloaded BOSH cloud-config

      --[no-]redact          Determines if vault values are fetched or redacted.
                             By default, the manifest will be redacted unless
                             being output to the live console.
EOF
sub {
	my %options = (redact => ! controlling_terminal);
	options(\@_, \%options, qw/
		cloud-config|c=s
		redact!
	/);
	usage(1) if @_ != 1;
	my $env = get_env(shift);
	check_prereqs;

	$ENV{REDACT} = $options{'redact'} ? "1" : "";

	my $create_env = is_create_env($env);

	# set offline since there's no director to talk to
	$ENV{OFFLINE} = 1 if ($create_env);

	if (!$options{'cloud-config'} && !$create_env) {
		if (!online) {
			error "You requested #B{offline} mode, but did not provide a #C{--cloud-config} to use.\n";
			error "In offline mode, Genesis is not allowed to talk to the BOSH director,\n";
			error "so you must provide a cloud config explicitly.\n";
			exit 1;
		}
		my $dir = workdir;
		bosh_download_cloud_config(bosh_target_for($env), "$dir/cloud.yml");
		$options{'cloud-config'} = "$dir/cloud.yml";
	}
	print merge_manifest($env, {
		'cloud-config' => $options{'cloud-config'},
		'create-env'   => $create_env,
	});
});

# }}}
# genesis repipe - Deploy a Concourse CI/CD deployment pipeline. {{{

command(["repipe", "push"], <<EOF,
genesis v$VERSION
USAGE genesis repipe [pipeline-layout]

OPTIONS
$GLOBAL_USAGE
  -t, --target     The name of your Concourse target (per `fly targets'),
                   if it differs from the pipeline layout name.

  -n, --dry-run    Generate the Concourse Pipeline configuration, but
                   refrain from actually deploying it to Concourse.
                   Instead, just print the YAML.

  -c, --config     Path to the pipeline configuration file, which specifies
                   Git parameters, notification settings, pipeline layouts,
                   etc.  Defaults to 'ci.yml'
EOF
sub {
	my %options;
	options(\@_, \%options, qw/
		dry-run|n
		target|t=s
		config|c=s
	/);
	check_prereqs;

	my $layout = $_[0] || "default";
	$options{target} ||= $layout;
	$options{config} ||= 'ci.yml';

	my $pipeline = parse_pipeline($options{config}, $layout);
	my $yaml = generate_pipeline_concourse_yaml($pipeline);
	if ($options{'dry-run'}) {
		print $yaml;
		exit 0;
	}

	my $dir = workdir;
	mkfile_or_fail "${dir}/pipeline.yml", $yaml;
	Genesis::Run::interact(
		{onfailure => "Could not upload pipeline $pipeline->{pipeline}{name}"},
		'fly','-t',$options{target},'set-pipeline','-p',$pipeline->{pipeline}{name},'-c',"${dir}/pipeline.yml"
	);
	Genesis::Run::interact(
		{onfailure => "Could not unpause pipeline $pipeline->{pipeline}{name}"},
		'fly','-t',$options{target},'unpause-pipeline','-p',$pipeline->{pipeline}{name}
	);
	my $action = ($pipeline->{pipeline}{public} ? 'expose' : 'hide');
	Genesis::Run::interact(
		{onfailure => "Could not $action pipeline $pipeline->{pipeline}{name}"},
		'fly','-t',$options{target},$action.'-pipeline','-p',$pipeline->{pipeline}{name}
	);
	exit 0;
});
# }}}
# genesis graph - Draw a Concourse CI/CD deployment pipeline. {{{

command("graph", <<EOF,
genesis v$VERSION
USAGE genesis graph [pipeline-layout] | dot -Tpng > pipe.png

Note: This command outputs a directed, acyclic graph (a DAG) in the
      Graphviz language (http://www.graphviz.org/).  If you want a
      picture of the pipeline, you will need to pipe the output through
      one of the many Graphviz formatters, like `dot -Tpng > out.png`

OPTIONS
$GLOBAL_USAGE
  -c, --config     Path to the pipeline configuration file, which specifies
                   Git parameters, notification settings, pipeline layouts,
                   etc.  Defaults to 'ci.yml'
EOF
sub {
	my %options;
	options(\@_, \%options, qw/
		config|c=s
	/);
	check_prereqs;

	my $layout = $_[0] || "default";
	$options{config} ||= 'ci.yml';

	my $pipeline = parse_pipeline($options{config}, $layout);
	my $dot = generate_pipeline_graphviz_source($pipeline);
	print "$dot\n";
	exit 0;
});
# }}}
# genesis describe - Describe a Concourse CI/CD deployment pipeline. {{{

command("describe", <<EOF,
genesis v$VERSION
USAGE genesis describe [pipeline-layout]

OPTIONS
$GLOBAL_USAGE
  -c, --config     Path to the pipeline configuration file, which specifies
                   Git parameters, notification settings, pipeline layouts,
                   etc.  Defaults to 'ci.yml'
EOF
sub {
	my %options;
	options(\@_, \%options, qw/
		config|c=s
	/);
	check_prereqs;

	my $layout = $_[0] || "default";
	$options{config} ||= 'ci.yml';

	my $pipeline = parse_pipeline($options{config}, $layout);
	generate_pipeline_human_description($pipeline);
	exit 0;
});
# }}}
# genesis lookup - Find a key set in environment manifests. {{{

command("lookup", <<EOF,
genesis v$VERSION
USAGE genesis lookup key env-name default-value

OPTIONS
$GLOBAL_USAGE
EOF
sub {
	my %options;
	options(\@_, \%options, qw/
	/);
	usage(1) if @_ != 3;
	check_prereqs;

	my ($key, $env, $default) = @_;
	my $v = get_key($env, $key);
	$v = defined $v ? $v : $default;
	if (ref($v)) {
		print encode_json($v)."\n";
	} else {
		print "$v\n";
	}
	exit 0;
});
# }}}
# genesis download - Download a Genesis Kit from the Internet. {{{

command("download", <<EOF,
genesis v$VERSION
USAGE genesis download NAME[/VERSION] [...]

OPTIONS
$GLOBAL_USAGE
EOF
sub {
	my %options;
	options(\@_, \%options, qw/
	/);
	usage(1) if @_ < 1;
	check_prereqs;

	for (@_) {
		my ($name, $version) = extract_kit_name_and_version($_);
		download_kit_tarball($name, $version)
			or exit 1;
	}
	exit 0;
});
# }}}
# genesis summary - Print a summary of each environment. {{{

command("summary", <<EOF,
genesis v$VERSION
USAGE genesis summary

OPTIONS
$GLOBAL_USAGE
EOF
sub {
	my %options;
	options(\@_, \%options, qw/
	/);
	check_prereqs;

	my @rows;
	my $stem = undef;
	for my $env (standalone_environment_yaml_files(glob("*.yml"))) {
		$env =~ s/\.yml$//;
		my $kit = get_key($env, "kit.name");
		my $ver = get_key($env, "kit.version");

		# FIXME: look at last  time i deployed the manifest instead of this cache file
		# FIXME: show what is out of date, if anything
		my $last = "never";
		if (-f ".genesis/cached/$env/last") {
			my $ts = get_file(".genesis/cached/$env/last") + 0;
			if ($ts) { # in case `last' is corrupt (i.e. not a timestamp)
				$last = strftime(envdefault("GENESIS_TIME_FORMAT", "%Y-%m-%d %H:%M:%S%P (@@)"), localtime($ts));

				$last =~ s/@@/ago($ts)/ge;
			}
		}

		(my $tmp = $env) =~ s/-[^-]*$//;
		push @rows, undef if defined $stem && $stem ne $tmp;
		$stem = $tmp;

		push @rows, [$env, "$kit/$ver", $last];

	}
	tablify(['Environment', 'Kit/Version', 'Last Deployed'], \@rows);
	exit 0;
});
# }}}
# genesis vault-policies - Generate Vault policies for an environment {{{
command("vault-policies", <<EOF,
genesis v$VERSION
USAGE genesis vault-policies [pipeline-layout]

OPTIONS
$GLOBAL_USAGE
  -c, --config     Path to the pipeline configuration file, which specifies
                   Git parameters, notification settings, pipeline layouts,
                   etc.  Defaults to 'ci.yml'
EOF
sub {
	my %options;
	options(\@_, \%options, qw/
	/);
	check_prereqs;

	my $layout = $_[0] || "default";
	$options{config} ||= "ci.yml";
	my @paths;

	$ENV{REDACT} = "true"; # we don't need vault creds for this, just pipeline layout
	my $pipeline = parse_pipeline($options{config}, $layout);
	for my $env (sort @{$pipeline->{envs}}) {
		# Always grab cloud config, since we're probably up and running if using this command
		# Posible issues we could run into are that the jumpbox doesn't have access to all
		# BOSH directors, or that someone is trying to build their vault policies before
		# anything is running. If we run into these cases, this can be changed, either by
		# somehow providing cloud configs for *all* boshes, or by making `spruce vaultinfo`
		# ignore static_ips?
		my $dir = workdir;
		if (is_create_env($env)) {
			write_stemcell_data("$dir/cloud.yml"); # Why write stemcell to cloud.yml??!!
		} else {
			bosh_download_cloud_config(bosh_target_for($env), "$dir/cloud.yml");
		}
		$options{'cloud-config'} = "$dir/cloud.yml";

		# get all files for a deployment
		my $vault_prefix = get_key($env, "params.vault", "");
		chomp $vault_prefix;
		die "Unable to find `params.vault' for environment `$env'. Cannot continue\n" unless $vault_prefix;

		push @paths, "secret/$vault_prefix/*";
		for my $extra_path (sort grep {chomp; $_ !~ m/^secret\/$vault_prefix\// } spruce_vault_paths(@{merge_files($env, \%options)})) {
			push @paths, $extra_path;
		}
	}
	push @paths, "secret/handshake";
	generate_ci_hcl_file('-', @paths);
});

sub generate_ci_approle_policies {
	my (
		$role_name,
		$role_path,
		$secret_path,
		@access_paths
	) = @_;

	my $dir = workdir;
	my $hcl_file = "$dir/concourse.hcl";
	my $r;

	explain "#Y{Determining vault paths needed for Concourse pipelines...}\n";
	generate_ci_hcl_file($hcl_file, @access_paths);

	explain "#Y{Creating Concourse AppRole for $role_name}\n";
	Genesis::Run::do_or_die(
		"Could not set policy for $role_name",
		'safe "$@"', "vault", "policy-write", $role_name, $hcl_file
	);
	Genesis::Run::do_or_die(
		"Could not create approle for $role_name",
		'safe "$@"', "vault", "write", "auth/approle/role/$role_name",
		"secret_id_ttl=0",
		"token_num_uses=0",
		"token_ttl=1m",
		"token_max_ttl=1m",
		"secret_id_num_uses=0",
		"policies=$role_name"
	);

	explain "#Y{Getting role and secret credentials from AppRole}\n";
	my ($role_p, $role_k) = $role_path =~/^(.*):([^:]*)$/;
	die "Invalid vault path '$role_path': expecting <path>:<key>\n" unless defined($role_p) && defined($role_k);

	my ($secret_p, $secret_k) = $secret_path =~/^(.*):([^:]*)$/;
	die "Invalid vault path '$secret_path': expecting <path>:<key>\n" unless defined($secret_p) && defined($secret_k);

	Genesis::Run::do_or_die(
		"Could not store role_id to $role_path",
		'safe read "auth/approle/role/${1}/role-id" | spruce json | jq -r .role_id | safe paste "$2" "$3"',
		$role_name, $role_p, $role_k
	);
	Genesis::Run::do_or_die(
		"Could not store secret_id to $secret_path",
		'safe vault write -f -format=json "auth/approle/role/${1}/secret-id | jq -r ".data.secret_id" | safe paste "$2" "$3"',
		$role_name, $secret_p, $secret_k
	);

	explain "#G{Completed AppRole creation for $role_name.}";
}

sub generate_ci_hcl_file {
	my (
		$hclfile,           # SET TO '-' to print to screen
		@vault_paths
	) = @_;

	my $fh;
	if ($hclfile eq '-') {
		$fh = *STDOUT;
	} else {
		open($fh, ">$hclfile") or die "can't open $hclfile: $!\n";
	}

	my %done;
	foreach (@vault_paths) {
		next if $done{$_};
		$done{$_} = 1;
		print $fh clean_heredoc(<<"		|EOF");
		|path "$_" {
		|    capabilities = [ "read", "list" ]
		|}
		|EOF
	}
	close $fh unless ($hclfile eq '-');
}

# }}}
# genesis ci-pipeline-deploy - Deploy via the CI/CD Pipeline {{{
command("ci-pipeline-deploy", <<EOF,
genesis v$VERSION
USAGE genesis ci-pipeline-deploy

OPTIONS
$GLOBAL_USAGE
EOF
sub {
	explain "[#G{genesis} ci-pipeline-deploy] v#G{%s}\n\n", $VERSION;

	my %options;
	options(\@_, \%options, qw/
	/);
	usage(1) if @_;
	check_prereqs(no_repo_needed => 1);

	# environment variables we should have
	#   CURRENT_ENV                - Name of the current environment
	#   PREVIOUS_ENV               - Name of previous environment (if applicable, for finding
	#
	#   VAULT_ROLE_ID              - Vault RoleID to authenticate to Vault with
	#   VAULT_SECRET_ID            - Vault SecretID to authenticate to Vault with
	#   VAULT_ADDR                 - URL of the Vault to use for credentials retrieval
	#   VAULT_SKIP_VERIFY          - Whether or not to enforce SSL/TLS validation
	#
	#   GIT_BRANCH                 - Name of the git branch to push commits to. post-deploy
	#   GIT_PRIVATE_KEY            - Private Key to use for pushing commits, post-deploy
	#
	#   WORKING_DIR - Path to the directory to deploy/work from
	#   OUT_DIR     - Path to the directory to output to
	#   CACHE_DIR   - Path to the directory our cache is in (required if PREVIOUS_ENV is present
	#
	# and unless we're a create-env based deploy, we should also have:
	#   BOSH_ENVIRONMENT           - URL of the BOSH director to deploy on
	#   BOSH_CA_CERT               - CA Certificate for the BOSH director
	#   BOSH_CLIENT                - Username or client ID (UAA-auth) to authenticate with
	#   BOSH_CLIENT_SECRET         - Password/Client-Secret to authenticate with

	my @undefined = grep { !$ENV{$_} }
		qw/CURRENT_ENV GIT_BRANCH GIT_PRIVATE_KEY
		   OUT_DIR WORKING_DIR
		   VAULT_ROLE_ID VAULT_SECRET_ID VAULT_ADDR/;
	push @undefined, "CACHE_DIR" if ($ENV{PREVIOUS_ENV} && ! $ENV{CACHE_DIR});

	# move to working dir prior to seeing if current env is bosh-init
	pushd $ENV{WORKING_DIR};
	push(@undefined, grep { !$ENV{$_} }
		qw/BOSH_ENVIRONMENT BOSH_CA_CERT
		   BOSH_CLIENT BOSH_CLIENT_SECRET/) unless is_create_env($ENV{CURRENT_ENV});

	if (@undefined) {
		error "The following #R{required} environment variables have not been defined:";
		error " - \$#Y{$_}" for @undefined;
		error;
		error;
		error "Please check your CI Pipeline configuration.";
		exit 1;
	}

	if ($ENV{PREVIOUS_ENV}) {
		Genesis::Run::do_or_die({interactive => 1}, "Failed to run `$_`", $_) for (
			"rm -rf .genesis/config .genesis/kits .genesis/cached",
			"cp -R '../$ENV{CACHE_DIR}/.genesis/cached' .genesis/cached",
			"cp -R '../$ENV{CACHE_DIR}/.genesis/config' .genesis/config",
			"cp -R '../$ENV{CACHE_DIR}/.genesis/kits' .genesis/kits"
		);
	}

	# don't set up a bosh alias if we're a create-env based deploy, no need, no data
	unless (is_create_env($ENV{CURRENT_ENV})) {
		my $target = bosh_target_for($ENV{CURRENT_ENV});
		bosh_alias($target); # exits on failure
	}

	vault_auth(vault       => $ENV{VAULT_ADDR},
	           skip_verify => envset("VAULT_SKIP_VERIFY"),
	           role_id     => $ENV{VAULT_ROLE_ID},
	           secret_id   => $ENV{VAULT_SECRET_ID});

	# exits if it fails
	my $rc = deploy_manifest($ENV{CURRENT_ENV}, { redact => !envset('CI_NO_REDACT') });
	if ($ENV{PREVIOUS_ENV}) {
		## rm cache dir
		## copy previous env cache dir
		# leaving as system calls for Concourse so output shows up in log
		system("rm -rf .genesis/config .genesis/kits .genesis/cached") == 0 or exit 1;
		system("git checkout .genesis/config"); # ignore failure for git checkout so that
		system("git checkout .genesis/kits");   # we don't cause problems if these files dont
		system("git checkout .genesis/cached"); # yet exist in the working tree (but did in the cache tree)
	}
	popd;
	commit_changes($ENV{WORKING_DIR}, $ENV{OUT_DIR}, $ENV{GIT_BRANCH}, $ENV{GIT_PRIVATE_KEY},
		"deployed to $ENV{CURRENT_ENV}");
	exit $rc;
});
# }}}
# genesis ci-stemcells - Upload stemcells to an environment via the CI/CD Pipeline {{{
command("ci-stemcells", <<EOF,
genesis v$VERSION
USAGE genesis ci-stemcells

OPTIONS
$GLOBAL_USAGE
EOF
sub {
	explain "[#G{genesis} ci-stemcells] v#G{%s}\n\n", $VERSION;

	my %options;
	options(\@_, \%options, qw/
	/);
	usage(1) if @_;
	check_prereqs(no_repo_needed => 1);

	# environment variables we should have
	#   STEMCELLS - Path to the directory containing stemcells to upload
	#   BOSH_ENVIRONMENT           - URL of the BOSH director to deploy on
	#   BOSH_CA_CERT               - CA Certificate for the BOSH director
	#   BOSH_CLIENT                - Username or client ID (UAA-auth) to authenticate with
	#   BOSH_CLIENT_SECRET         - Password/Client-Secret to authenticate with
	#
	my @undefined = grep { !$ENV{$_} }
		qw/STEMCELLS BOSH_ENVIRONMENT BOSH_CA_CERT BOSH_CLIENT BOSH_CLIENT_SECRET/;
	if (@undefined) {
		error "The following #R{required} environment variables have not been defined:";
		error " - \$#Y{$_}" for @undefined;
		error;
		error;
		error "Please check your CI Pipeline configuration.";
		exit 1;
	}

	opendir(my $dh, $ENV{STEMCELLS})
		or die "Could not open `$ENV{STEMCELLS}' directory to find stemcells.\n";
	while (my $stemcell = readdir($dh)) {
		if ($stemcell !~ /^\./ && -d "$ENV{STEMCELLS}/$stemcell") {
			my $version = get_file "$ENV{STEMCELLS}/$stemcell/version";
			my $sha1    = get_file "$ENV{STEMCELLS}/$stemcell/sha1";
			my $url     = get_file "$ENV{STEMCELLS}/$stemcell/url";
			bosh_upload_stemcell($stemcell, $version, $sha1, $url);
		}
	}
	closedir $dh
});
# }}}
# genesis ci-generate-cache - Generate cache for an environment via the CI/CD Pipeline {{{
command("ci-generate-cache", <<EOF,
genesis v$VERSION
USAGE genesis ci-generate-cache

OPTIONS
$GLOBAL_USAGE
EOF
sub {
	explain "[#G{genesis} ci-generate-cache] v#G{%s}\n\n", $VERSION;

	my %options;
	options(\@_, \%options, qw/
	/);
	usage(1) if @_;
	check_prereqs(no_repo_needed => 1);

	# environment variables we should have
	#   CURRENT_ENV - Name of the current environment
	#   GIT_BRANCH                 - Name of the git branch to push commits to. post-deploy
	#   GIT_PRIVATE_KEY            - Private Key to use for pushing commits, post-deploy
	#   WORKING_DIR - Path to the directory to deploy/work from
	#   OUT_DIR     - Path to the directory to output to
	#
	my @undefined = grep { !$ENV{$_} }
		qw/CURRENT_ENV GIT_BRANCH GIT_PRIVATE_KEY
		   WORKING_DIR OUT_DIR/;
	if (@undefined) {
		error "The following #R{required} environment variables have not been defined:";
		error " - \$#Y{$_}" for @undefined;
		error;
		error;
		error "Please check your CI Pipeline configuration.";
		exit 1;
	}

	pushd $ENV{WORKING_DIR};
	mkdir_or_fail ".genesis/cached/$ENV{CURRENT_ENV}";
	for my $file (expand_tokens(split /\-/, $ENV{CURRENT_ENV})) {
		copy_or_fail "$file.yml", ".genesis/cached/$ENV{CURRENT_ENV}/$file.yml" if -f "$file.yml";
	}
	popd;
	commit_changes($ENV{WORKING_DIR}, $ENV{OUT_DIR}, $ENV{GIT_BRANCH}, $ENV{GIT_PRIVATE_KEY}, "generated cache for $ENV{CURRENT_ENV}");
});
# }}}
# genesis ci-pipeline-run-errand - Run arbitrary errands via the CI/CD Pipeline {{{

command("ci-pipeline-run-errand", <<EOF,
genesis v$VERSION
USAGE genesis ci-pipeline-run-errand

OPTIONS
$GLOBAL_USAGE
EOF
sub {
	explain "[#G{genesis} ci-pipeline-run-errand] v#G{%s}\n\n", $VERSION;

	my %options;
	options(\@_, \%options, qw/
	/);
	usage(1) if @_;
	check_prereqs(no_repo_needed => 1);

	# environment variables we should have
	#   CURRENT_ENV - Name of the current environment
	#   BOSH_ENVIRONMENT   - URL of the BOSH director to deploy on
	#   BOSH_CA_CERT       - CA Certificate for the BOSH director
	#   BOSH_CLIENT        - Username or client ID (UAA-auth) to authenticate with
	#   BOSH_CLIENT_SECRET - Password/Client-Secret to authenticate with
	#   ERRAND_NAME - Name of the Smoke Test errand to run

	my @undefined = grep { !$ENV{$_} }
		qw/CURRENT_ENV ERRAND_NAME
		   BOSH_ENVIRONMENT BOSH_CA_CERT
		   BOSH_CLIENT BOSH_CLIENT_SECRET/;
	if (@undefined) {
		error "The following #R{required} environment variables have not been defined:";
		error " - \$#Y{$_}" for @undefined;
		error;
		error;
		error "Please check your CI Pipeline configuration.";
		exit 1;
	}

	my $target = bosh_target_for($ENV{CURRENT_ENV});
	bosh_alias($target); # exits on failure

	my $deployment = "$ENV{CURRENT_ENV}-" . deployment_suffix;
	bosh_run_errand($target, $deployment, $ENV{ERRAND_NAME}); # exits on failure

	exit 0;
});
# }}}

# genesis ui-describe - Provides colored explanatory test {{{
command("ui-describe", <<EOF,
genesis v$VERSION
USAGE genesis ui-describe "string" ... [options...]

Prints each string, separated by a new line.  Supports color blocks by the
wrapping of a block of text with #x{block}, where x is one of:
  b - blue
  c - dark cyan
  g - green
  k - black
  m - magenta
  r - red
  w - light grey
  y - brown
  B - light blue
  C - cyan
  G - light green
  K - dark grey
  M - light magenta
  R - light red
  W - white
  Y - yellow

GLOBAL OPTIONS (may not apply)
$GLOBAL_USAGE
EOF
sub {
	my %options;
	options(\@_, \%options);
	explain $_ for (@_);
});
# }}}

# genesis ui-prompt-for - Provides prompts in support of hooks/new script {{{
command("ui-prompt-for", <<EOF,
genesis v$VERSION
USAGE genesis ui-prompt-for <type> <path> [options...] [<prompt>]

<type> is one of:
    line:          prompt for a single line of text
    boolean:       prompt for a boolean value, returns "true"/"false"
    block:         prompt for a multi-line block of text
    select:        prompt the user to select one of a list of choices
    multi-line     prompt for zero or more lines of text
    multi-block:   prompt for zero or more blocks of text
    multi-select:  provide the user with a list of choices to select zero or more of them
    secret-line:   prompt for a single line of test, stores it in vault
    secret-block:  prompt for a block of text, stores it in vault

<path> is either a file path, or a vault path exlcuding the secret/ prefix (for secret-* types)

Note: With multi-* types, the first entry in the file is blank, to indicate
     that there is at least one entry -- an empty list will not contain any
     fields.  This is to distinguish between a single empty string and no
     entries at all.

OPTIONS
  -l, --label  "x"      prompt string immediately in front of cursor (default: '> ')
      --default "x"     for line/boolean/select: default value if user leaves prompt empty.
  -V, --validation "x"  for line/multi-line: validation type, one of :
                          comma-separated list of strings: [a,b,c]
                          negative comma-separated list:   ![a,b,c]
                          regular expression literal: /^(this|that)\$/i
                          negative regular expression: !/[^a-zA-Z0-9]/
                          range expression: min-max
                          "url"
                          "port"
                          "vault_path"
                          "vault_path_and_key"
  -m, --min x           for multi-*: minimum items to enter - default: none
  -M, --max x           for multi-*: maximum items to enter - default: unlimited
  -o, --option "x"      options to chose from (can be specified multiple times)
                        either specify a string that is used for both the value
                        and the label, or in the form of "[value]label"
      --msg "x"         specify the message to print on validation failure, default
                        is specific to the validation type used.
      --invert          (boolean only) invert the answer (true becomes 0, false 1)
      --echo            (secret-line only) echo what the user types to the screen

GLOBAL OPTIONS (may not apply)
$GLOBAL_USAGE
EOF
sub {

	my %options;
	options(\@_, \%options, qw(
		label|l=s
		default=s
		validation|V=s
		min|m=i
		max|M=i
		option|o=s@
		invert
		echo
	));
	usage(1) if @_ < 2 || @_ > 3; # prompt is optional, type and path are not
	check_prereqs(no_repo_needed => 1);
	my ($type,$path,$prompt) = @_;
	my $use_vault = ($type =~ /^secret-*/);
	$options{secret} = $path if ($use_vault);

	delete @options{qw(color debug trace quiet cwd offline environment)};  # clean out global options
	die csprintf(
		"#R{ERROR:} cannot prompt for %s: unknown type, expecting one of: %s\n",
		$type,
		join(", ", (sort keys %$prompt_handlers))
	) unless exists($prompt_handlers->{$type});

	if ($use_vault && ! vaulted) {
		explain clean_heredoc(<<"		|EOF");
		|
		|#Y{WARNING:} No vault selected - you will have to later manually add the answer to
		|"#C{$prompt}"
		|to #G{secret/$path} when the Vault is available
		|EOF
		return 0
	}
	my $result = $prompt_handlers->{$type}->($prompt,%options);
	mkfile_or_fail $path, $result unless ($use_vault);
	exit 0
});
# }}}

###########################################################################

sub main {
	debug "genesis starting up...";

	$ENV{GENESIS_INDEX} = "https://genesis.starkandwayne.com" unless $ENV{GENESIS_INDEX};

	# Check if we're in a v1 repo
	my $path = abs_path(getcwd);
	my $in_version = 0;
	if (in_repo_dir) {
		$in_version = 2;
	} else {
		while ($path ne "") {
			if (-d "$path/global" && -e "$path/global/deployment.yml") {
				$in_version = 1;
				last;
			}
			$path =~ s/\/[^\/]*$//;
		}
	}

	if ($in_version == 1) {
		# Set GENESIS_V1_PATH env var to shadow the obscure location
		($ENV{GENESIS_V2_VERSION} = $VERSION) =~ s/^\((.*)\)$/$1/;
		exec $ENV{GENESIS_V1_BIN}, @_;
	}
	my ($cmd, @args);
	while (@_ > 0) {
		my $arg = shift @_;
		if ($cmd || $arg =~ m/^-+/) {
			push @args, $arg;
			push @args, shift @_ if $arg eq '-C';
		} else {
			$cmd = $arg;
		}
	}

	if ($cmd) {
		debug "running command '$cmd'";
		debug "arguments are [".join(', ', @args)."]";
		if (exists $COMMAND{$cmd}) {
			$COMMAND{$cmd}(@args);
			exit 0;
		}
		error "unrecognized command '$cmd'";
		usage(2, "", "help");
	}
	if (@args and $args[0] =~ m/^(-h|--help)$/) {
		$COMMAND{help}();
		exit 0;
	}
	if (@args and scalar(@args) == 1 && $args[0] =~ m/^(-v|--version)$/) {
		$COMMAND{version}();
		exit 0;
	}
	$COMMAND{help}();
	exit 2;
}

main(@ARGV);

__DATA__
