#!/bin/bash
unset IFS

# echo >&2 "======"$'\n'"DEBUG: called '${FUNCNAME[0]}' with "$'\n'" --($@)--"$'\n'"^^^^^^"
: <<'dox-overview:genesis'
USAGE
@~include=usage{"cmd":"<command> [options] [arguments]"}

DESCRIPTION
	Genesis is a tool build around a BOSH deployment paradigm that allows you to
	create and manage unified deployment manifests across multiple sites and
	environments.

	It does this by breaking up your BOSH configuration manifest along three
	logical strata: global, site and environment.  This allows you to work on
	small related blocks of elements, reducing complexity and redundancy, then
	package them up for deployment across different IaaS providers and target
	environments with properties appropriate for their needs.

CONCEPTS
@~include=topic{"category":"concept","leader":"    ","scope":"intro","desc":"block"}

	More details are available for each concept by running
	`<<SCRIPT_NAME>> help --concept <concept-name>`.

COMMON COMMANDS
@~include=topic{"category":"command","scope":"common","leader":"  genesis ","desc":"inline"}

  For more details, run `genesis help <command>`
dox-overview:genesis

: <<'dox-concept:Makefiles'
DESCRIPTION
	When Genesis provisions a new environment, it creates a Makefile that
	provides some easy "shortcut" command invocation targets to simplify the
	manifest generation process.

		make help
			Displays this help content.

		make version
			Displays the version and location of the genesis executable that will be
			used by the other make actions

		make refresh
			Pull in fresh copies of global and site YAML templates (into .global/ and
			.site/).  This is a shortcut for `<<SCRIPT_NAME>> refresh all`

		make manifest
			Build a new manifest for the environment by merging the template YAML
			files together.

		make deploy
			Build the manifest and attempt to deploy it.  This safely handles Vault'd
			credentials by creating a separate manifest yaml file that only exists
			for the duration of the deploy.

	Since this is a real Makefile, you can combine the two actions.  For example:

		make refresh manifest
			Refresh global / site configuration, and then build an up-to-date
			deployment manifest.

SEE ALSO
@~include=topic{"category":"concept","scope":"makefile","desc":"none","leader":"  <<SCRIPT_NAME>> help --concept "}

COMMANDS
@~include=topic{"category":"command","scope":"makefile","desc":"inline","leader":"  <<SCRIPT_NAME>> "}

dox-concept:Makefiles

( set -o posix ; set > /tmp/variables.$$)
__debug_vars() {
	diff /tmp/variables.$$ <(set -o posix; set) | grep '^[<>]'
}
VERSION="(development build)"
SCRIPT_NAME=$0 # or $(basename $0) ?

USERNAME=$(whoami)
CANON_REPO=https://github.com/starkandwayne/genesis
API_REPO=https://api.github.com/repos/starkandwayne/genesis

GENESIS_INDEX=${GENESIS_INDEX:-https://genesis.starkandwayne.com}
GENESIS_INDEX=${GENESIS_INDEX%/}
if [[ ${GENESIS_INDEX} = "no" ]]; then
	GENESIS_INDEX=
fi

HAVE_TREE=
if [[ -n $(command -v tree 2>/dev/null) ]]; then
	HAVE_TREE=yes
fi

####################################################
# common functions used by other parts of Genesis

WORKDIR=""
need_a_workdir() {
	if [[ -z ${WORKDIR} ]]; then
		WORKDIR=$(mktemp -d -t genesis.XXXXXX)
		trap "rm -rf ${WORKDIR}" INT TERM QUIT EXIT
	fi
}

find_toplevel_root() {
	(while [[ $(pwd) != "/" && ! -d global/ && ! -f .deployment ]]; do
		cd ..
	 done
	 if [[ -d global || -f .deployment ]]; then
		pwd
	 fi)
}

all_sites() {
	setup
	for dir in ${DEPLOYMENT_ROOT}/*/; do
		site=${dir%%/}
		site=${site##*/}

		if [[ "${site}" != "global" && -d "${dir}/site" ]]; then
			echo ${site}
		fi
	done
}

all_pipeline_sites() {
	spruce json $(ci_pipeline_yaml) | jq -r ".sites | keys | .[]"
}

all_environments_for() {
	local site=${1:?all_environments_for() - no site name provided}
	setup
	for dir in ${DEPLOYMENT_ROOT}/${site}/*/; do
		env=${dir%%/}
		env=${env##*/}

		if [[ -f "${dir}/Makefile" ]]; then
			echo ${env}
		fi
	done
}

check_site() {
	local path=${1:?is_site() - no site argument provided}
	if [[ ! -d "${DEPLOYMENT_ROOT}/${path}" ]]; then
		echo >&2 "Site ${path} not found"
		exit 1
	fi
	if [[ ! -d "${DEPLOYMENT_ROOT}/${path}/site" ]]; then
		echo >&2 "${path} does not look like a valid site"
		exit 2
	fi
}

check_environment() {
	local path=${1:?check_environment() - no site/environment argument provided}
	if [[ ! -d "${DEPLOYMENT_ROOT}/${path}" ]]; then
		echo >&2 "Environment ${path} not found"
		exit 1
	fi
	if [[ ! -f "${DEPLOYMENT_ROOT}/${path}/Makefile" ]]; then
		echo >&2 "${path} does not look like a valid environment"
		exit 2
	fi
}

line() {
	echo
	echo "########################################################################"
	echo
}

version_checker() {
	if [[ $1 == $2 ]]
	then
		return 0
	fi
	local IFS=.
	local i actual=($1) expected=($2)
	# fill empty fields in actual with zeros
	for ((i=${#actual[@]}; i<${#expected[@]}; i++))
	do
		actual[i]=0
	done
	actual_numeric=0
	expected_numeric=0
	for ((i=0; i<${#actual[@]}; i++))
	do
		if [[ -z ${expected[i]} ]]
		then
			# fill empty fields in expected with zeros
			expected[i]=0
		fi
		actual_numeric=$((actual_numeric+${actual[i]}*1000**(${#actual[@]}-i)))
		expected_numeric=$((expected_numeric+${expected[i]}*1000**(${#expected[@]}-i)))
	done


	if [[ ${actual_numeric} -lt ${expected_numeric} ]]; then
		return 1
	fi
	return 0
}

setup() {
	if [[ ${DEPLOYMENT_ROOT:-unset} != "unset" ]]; then
		return
	fi

	DEPLOYMENT_ROOT=$(find_toplevel_root)
	if [[ -z ${DEPLOYMENT_ROOT:-} ]]; then
		echo >&2 "Unable to determine Genesis DEPLOYMENT_ROOT"
		exit 3
	fi

	if [[ -f ${DEPLOYMENT_ROOT}/.genesis_deps ]]; then
		errors=""
		while IFS='' read -r line || [[ -n "$line" ]]; do
			cmd=$(echo $line | perl -pe 's|^(.*?):.*$|$1|')
			ver=$(echo $line | perl -pe 's|^.*?: *(.*)$|$1|')
			if [[ -z $(command -v ${cmd}) ]]; then
				errors="This genesis deployment requires the '${cmd}' command\n${errors}"
				continue
			fi
			if [[ ${ver} != "null" && ${ver} != '~' ]]; then
				dev_version=$(${cmd} -v 2>&1 | perl -pe 's/.*development.*/DEV/')
				if [[ ${dev_version} == "DEV" ]]; then
					echo "Treating 'development' version as up-to-date with ${ver}"
					continue
				fi
				current_version=$(${cmd} -v 2>&1 | perl -pe 's|.*?(\d+\.\d+(\.\d+)*).*|$1|')
				if [[ -z ${current_version} || $(echo ${current_version} | egrep '[^0-9\.]') ]]; then
					errors="This genesis deployment requires ${cmd} version ${ver}, but the current version could not be parsed\n${errors}"
					echo ${current_version}
					continue
				fi
				if ! version_checker ${current_version} ${ver}; then
					errors="This genesis deployment requires ${cmd} version ${ver} (found ${current_version})\n${errors}"
					continue
				fi
			fi
		done < ${DEPLOYMENT_ROOT}/.genesis_deps
		if [[ -n ${errors} ]]; then
			echo -e ${errors}
			exit 1
		fi
	fi

	# What type of deployment is this?
	#
	#    normal    - A normal BOSH deployment
	#    bosh-init - A bosh-init BOSH deployment
	#
	DEPLOYMENT_TYPE=normal
	if [[ -f "${DEPLOYMENT_ROOT}/.deployment" ]]; then
		DEPLOYMENT_TYPE=$(cat "${DEPLOYMENT_ROOT}/.deployment")
	fi

	case ${DEPLOYMENT_TYPE} in
	(bosh) DEPLOYMENT_TYPE=bosh-init ;;
	(normal|bosh-init) ;;
	(*) echo >&2 "Unrecognized deployment type: ${DEPLOYMENT_TYPE}"
	    exit 3 ;;
	esac

	DEPLOYMENT_SITE=""
	DEPLOYMENT_ENVIRONMENT=""

	local relpath=${PWD##$DEPLOYMENT_ROOT/}
	if [[ ${relpath#global} == ${relpath} ]]; then
		# not in /global
		local site=${relpath%%/*}
		if [[ -n ${site} && -d "${DEPLOYMENT_ROOT}/${site}" && -d "${DEPLOYMENT_ROOT}/${site}/site" ]]; then
			DEPLOYMENT_SITE=${site}

			relpath=${relpath#$site/}
			local env=${relpath%%/*}
			if [[ -n ${env} && ${env} != "site" && -d "${DEPLOYMENT_ROOT}/${site}/${env}" ]]; then
				DEPLOYMENT_ENVIRONMENT=${env}
				if [[ -f "${DEPLOYMENT_ROOT}/${site}/${env}/.type" ]]; then
					DEPLOYMENT_TYPE=$(cat "${DEPLOYMENT_ROOT}/${site}/${env}/.type")
				fi
			fi
		fi
	fi

	SPRUCE_OPTS=""
	if [[ -n "${SPRUCE_TRACE}" ]]; then
		SPRUCE_OPTS="--debug --trace"
	elif [[ -n "${SPRUCE_DEBUG}" ]]; then
		SPRUCE_OPTS="--debug"
	fi

	DEPLOYMENT_NAME="${DEPLOYMENT_ROOT##*/}"
	DEPLOYMENT_NAME="${DEPLOYMENT_NAME%%-deployment*}"
	DEPLOYMENT_SITE_DIR="${DEPLOYMENT_ROOT}/${DEPLOYMENT_SITE}"
	DEPLOYMENT_ENV_DIR="${DEPLOYMENT_ROOT}/${DEPLOYMENT_SITE}/${DEPLOYMENT_ENVIRONMENT}"
}

actual_yaml_files() {
	while (($#)) ; do
		[[ -f "$1" ]] && echo $1
		shift
	done
}

ensure_yaml_file() {
	local path=${1:?ensure_yaml_file() - no path given}
	if [[ ! -s $path ]]; then
		echo "--- {}" > $path
	fi
}

ensure_ci_configuration() {
	ensure_yaml_file $(ci_pipeline_yaml)
}

ALL_VAULTED=""
need_a_vault() {
	if [[ -z ${ALL_VAULTED} ]]; then
		ALL_VAULTED=yes
		if [[ -n ${VAULT_ADDR} ]]; then
			echo "Authenticating to Vault at ${VAULT_ADDR}"
			if [[ -z $(command -v vault) ]]; then
				echo >&2 "\`vault' command not found in your \$PATH"
				echo >&2 "  ($PATH)"
				echo >&2 "You may need to install Vault in your task image"
				exit 1
			fi
			echo

			if [[ -n ${CI_SITE_ENV} ]]; then
				touch      ~/.vault
				chmod 0400 ~/.vault

				if [[ ${VAULT_SKIP_VERIFY} == '1' ]]; then
					skip_verify='-k'
				fi
				creds='{"user_id":"'${CI_VAULT_USER_ID:-generic-deployment-generic-userpipeline}'","app_id":"'${CI_VAULT_APP_ID:-concourse}'"}'
				if ! curl ${skip_verify} -Ls ${VAULT_ADDR}/v1/auth/app-id/login --data "${creds}" > ~/.vault; then
					echo >&2 "Failed to authenticate to the Vault app-id backend:"
					cat >&2 ~/.vault
					exit 2
				fi

				export VAULT_TOKEN=$(cat ~/.vault | jq -r '.auth.client_token')
				rm ~/.vault
				if ! vault status; then
					echo >&2 "Failed to authenticate to Vault at ${VAULT_ADDR}; bailing..."
					exit 2
				fi
			fi

			echo
			echo "Testing Vault authentication by retrieving secret/handshake"
			if ! vault read secret/handshake; then
				echo >&2 "Failed to retrieve secret/handshake; assuming authentication failed..."
				exit 3
			fi
			echo

		else
			echo >&2 "No VAULT_ADDR found in environment; skipping authentication step"
		fi
	fi
}

ask_bosh() {
	local url=$1

	need_a_workdir
	file="${WORKDIR}/bosh.$(echo ${url} | sha1sum | awk '{print $1}')"
	if [[ ! -f ${file} ]]; then
		need_a_bosh
		curl -Lks -u "${DIRECTOR_CREDS}" ${DIRECTOR_URL}/${url} > ${file}
	fi
	cat ${file}
}

need_a_bosh() {
	setup
	if [[ -n ${DIRECTOR_URL} ]]; then
		return
	fi

	# Interrogate bosh_config for director-y things
	if [[ -f ~/.bosh_config ]]; then
		DIRECTOR_URL=$(spruce json ~/.bosh_config | jq -r .target)
		DIRECTOR_CREDS=$(spruce json ~/.bosh_config | jq -r '.auth[.target].username + ":" + .auth[.target].password')
		DIRECTOR_UUID=$(curl -m${DIRECTOR_TIMEOUT:-3} -Lks -u "${DIRECTOR_CREDS}" ${DIRECTOR_URL}/info | jq -r .uuid)
	fi
}


####################################################
# checks and validating functions

need_command() {
	local cmd=${1:?need_command() - no command name given}

	if [[ ! -x "$(command -v $cmd)" ]]; then
		echo >&2 "${cmd} is not installed."
		if [[ "${cmd}" == "spruce" ]]; then
			echo >&2 "Please download it from https://github.com/geofffranks/spruce/releases"
		fi
		exit 2
	fi
}

check_site_name() {
	local site=${1:?check_site_name() - no site name provided}

	cleaned=$(echo -n ${site} | sed -e 's/[^a-z0-9_-]//')
	if [[ ${cleaned} != ${site} ]]; then
		echo >&2 "Error: Site name '${site}' contains invalid characters"
		exit 2
	fi
}

check_environment_name() {
	local env=${1:?check_environment_name() - no env name provided}

	case ${env} in
	(site|global)
		echo >&2 "Error: Environment name '${env}' is reserved"
		exit 2
		;;
	esac

	cleaned=$(echo -n ${env} | sed -e 's/[^a-z0-9_-]//')
	if [[ ${cleaned} != ${env} ]]; then
		echo >&2 "Error: Environment name '${env}' contains invalid characters"
		exit 2
	fi
}

must_be_in_a_site() {
	setup
	if [[ -z ${DEPLOYMENT_SITE} ]]; then
		echo >&2 "Error: Must be in a site directory to run this command"
		exit 2
	fi
}

must_be_in_an_environment() {
	setup
	if [[ -z ${DEPLOYMENT_ENVIRONMENT} ]]; then
		echo >&2 "Error: must be in an environment directory to run this command"
		exit 2
	fi
}

####################################################
# helper functions

env_root() {
	site=${1:?env_root() - No site given}
	name=${2:?env_root() - No environment given}

	setup
	echo "${DEPLOYMENT_ROOT}/${site}/${name}"
}

switch_to() {
	local site=${1}
	local name=${2}

	if [[ -z ${site} ]]; then
		cd ${DEPLOYMENT_ROOT}/global
	elif [[ -z ${name} ]]; then
		cd ${DEPLOYMENT_ROOT}/${site}/site
	else
		cd ${DEPLOYMENT_ROOT}/${site}/${name}
	fi

	unset DEPLOYMENT_ROOT
	setup
}

create_makefile() {
	path=${1:?create_makefile() - No path given}

	cat > ${path} <<EOF
# genesis, available at ${CANON_REPO}

save_VAULT_ADDR := \$(VAULT_ADDR)
VAULT_ADDR =
REDACT = yes

root_path := \$(realpath \$(dir \$(abspath \$(lastword \$(MAKEFILE_LIST))))../..)
ifdef USE_SYSTEM_GENESIS
	PATH := \$(PATH)
else
	PATH := \$(root_path)/bin:\$(PATH)
endif

help: check
	@PATH=\$(PATH) genesis help --concept Makefiles

version:
	@PATH=\$(PATH) echo "using \$\$(which genesis)"
	@PATH=\$(PATH) genesis version

manifest: check
	@REDACT=yes PATH=\$(PATH) genesis build

deploy: check
	@REDACT= VAULT_ADDR=\$(save_VAULT_ADDR) PATH=\$(PATH) genesis deploy

refresh: check
	@PATH=\$(PATH) genesis refresh

check:
	@PATH=\$(PATH) genesis ping >/dev/null 2>&1 || (echo >&2 "You need to install Genesis first (see ${CANON_REPO})" && exit 1)

.PHONY: help check manifest deploy refresh version
EOF
}

create_root_readme() {
	cat <<EOF
${DEPLOYMENT_NAME} Deployments
==============================

This repository contains the YAML templates that make up a series of
${DEPLOYMENT_NAME} BOSH deployments, using the format prescribed by the
[Genesis][1] utility.

The configuration is broken up into three logical strata: _global_,
_site_, and _environment_.  _Global_ defines the universal aspects of any
deployment, including overall job structure, constituent BOSH releases,
and invariant (or default) properties.  Each _site_ represents a single
IaaS (an AWS VPC, a vSphere cluster, etc.), and further refines the global
configuration for that infrastructure.  Each _environment_ represents a
single BOSH deployment, with specific network numbering, credentials,
domain names, etc.

For more information, see the READMEs scattered throughout this repository,
and check out \`genesis help\`.  You can download the Genesis program from
[Github][1]

Quickstart
----------

To create a new site:

    genesis new site NAME

To create a new environment

    cd site-name/
    genesis new environment NAME

To build the full BOSH manifest for an environment:

    cd site-name/env-name
    make manifest

... and then deploy it:

    cd site-name/env-name
    make deploy




[1]: ${CANON_REPO}
EOF
}

create_global_readme() {
	case ${DEPLOYMENT_TYPE} in
	(normal) # {{{
		cat <<EOF
Global Definitions

This directory contains templates that describe the common elements of this
deployment, to be shared (and possibly overridden) by sites and environments.
The templates are merged in the following order:

  global/jobs.yml             Specify what jobs will make up the canonical
                              deployment, and what templates to apply to them.

  global/deployment.yml       Define the global structure of all deployments
                              with the correct param calls to remind template
                              writers to override the correct things.

  global/properties.yml       Define the properties (global or per-job) for this
                              deployment.


NOTE: If you make changes to the templates in here, they will automatically
propagate to any newly-created environments, but you will need to run a
refresh for existing environments to receive those updates.
EOF
		;; # }}}
	(bosh-init) # {{{
		cat <<EOF
Global Definitions

This directory contains templates that describe the common elements of BOSH
deployments, to be shared (and possibly overridden) by sites and environments.
The templates are merged in the following order:

  global/jobs.yml             Specify what jobs will make up the BOSH deployment,
                              and what templates to apply to them.

  global/deployment.yml       Define the global structure of all BOSH deployments
                              with the correct param calls to remind template
                              writers to override the correct things.

  global/properties.yml       Define the properties (global or per-job) for the
                              BOSH deployment.


NOTE: If you make changes to the templates in here, they will automatically
propagate to any newly-created environments, but you will need to run a
refresh for existing environments to receive those updates.
EOF
		;; # }}}
	esac
}

create_site_readme() {
	local site=${1:?create_site_readme() - no site given}

	case ${DEPLOYMENT_TYPE} in
	(normal) # {{{
		cat <<EOF
Site Definitions (${site})

This directory contains templates that describe the infrastructure-specific
settings and site-wide properties.  The templates are merged in the following order:

  site/disk-pools.yml         If you need to, you can put disk pool
                              definitions in this file.

  site/update.yml             Specify job update parameters here, which can
                              change based on the cloud provider in use,
                              and its performance characteristics.

  site/jobs.yml               Here you can modify the list of jobs defined
                              at the global level, remove jobs (by setting
                              their instances: count to 0), and supply any
                              additional, site-wide job properties.

  site/networks.yml           Define what networks to use for all the
                              environments in this site (although you may
                              want to defer the actual numbering to the
                              environment level.

  site/resource-pools.yml     Set up the resource pools to use for job
                              virtual machines, and apply their cloud
                              properties (i.e. availability zones)

  site/properties.yml         Define properties (both globally and per-job),
                              that are specific to this environment.  These will
                              most likely override global properties.


NOTE: If you make changes to the templates in here, they will automatically
propagate to any newly-created environments, but you will need to run a
refresh for existing environments to receive those updates.
EOF
		;; # }}}
	(bosh-init) # {{{
		cat <<EOF
Site Definitions (${site})

This directory contains templates that describe the infrastructure-specific
settings and site-wide properties.  The templates are merged in the following order:

  site/disk-pools.yml         If you need to, you can put disk pool
                              definitions in this file.

  site/jobs.yml               Here you can modify the list of jobs defined
                              at the global level, remove jobs (by setting
                              their instances: count to 0), and supply any
                              additional, site-wide job properties.

  site/networks.yml           Define what networks to use for all the
                              environments in this site (although you may
                              want to defer the actual numbering to the
                              environment level.

  site/resource-pools.yml     Set up the resource pools to use for job
                              virtual machines, and apply their cloud
                              properties (i.e. availability zones)

  site/properties.yml         Define properties (both globally and per-job),
                              that are specific to this environment.  These will
                              most likely override global properties.


NOTE: If you make changes to the templates in here, they will automatically
propagate to any newly-created environments, but you will need to run a
refresh for existing environments to receive those updates.
EOF
# site/README
		;; # }}}
	esac
}

create_environment_readme() {
	local site=${1:?create_environment_readme() - no site given}
	local name=${2:?create_environment_readme() - no environment given}

	case ${DEPLOYMENT_TYPE} in
	(normal) # {{{
		cat <<EOF
Environment Definitions (${site}/${name})

This directory contains templates that describe the environment-specific
settings of a single deployment.  These templates will be combined with
the global and site templates to produce a single BOSH manifest for deployment
purposes.  The templates are merged in the following order:

  monitoring.yml              Configure whatever (external) monitoring system you
                              want to track the performance and health of your
                              deployment.

  networking.yml              Configure the network numbering for this deployment.

  director.yml                Identify the BOSH director UUID for this deployment.

  scaling.yml                 Define the scaling properties for this deployment,
                              including things like the number of instances, sizes
                              of persistent disks, resource pool limits, etc.

  properties.yml              Define properties (both globally and per-job),
                              that are specific to this environment.  These will
                              most likely override global and site properties.

  credentials.yml             Define passwords and credentials here, so that they
                              are centralized.  Keep in mind that commiting these
                              into version control incurs some security risk.

  cloudfoundry.yml            For deployments that integrate with Cloud Foundry
                              installations (i.e. as service brokers), you can
                              specify the integration details here, including
                              things like the CF API, credentials, domains, etc.

  name.yml                    Specify the name of this deployment.


This directory also contains a Makefile that makes it easier to build
the final BOSH manifest from all of the constituent templates.
Run \`make' to see some help, or \`make manifest' to just rebuild.
EOF
		;; # }}}
	(bosh-init) # {{{
		cat <<EOF
Environment Definitions (${site}/${name})

This directory contains templates that describe the environment-specific
settings of a single bosh-init deployment.  These templates will be combined
with the global and site templates to produce a single manifest suitable for
deployment via \`bosh-init'.  The templates are merged in the following order:

  networking.yml              Configure the network numbering for this BOSH.

  properties.yml              Define properties (both globally and per-job),
                              that are specific to this environment.  These will
                              most likely override global and site properties.

  credentials.yml             Define passwords and credentials here, so that they
                              are centralized.  Keep in mind that commiting these
                              into version control incurs some security risk.

  name.yml                    Specify the name of this deployment.


This directory also contains a Makefile that makes it easier to build
the final manifest from all of the constituent templates.
Run \`make' to see some help, or \`make manifest' to just rebuild.
EOF
		;; # }}}
	esac
}

create_deployment() {
	setup
	mkdir -p ${DEPLOYMENT_ROOT}/global
	mkdir -p ${DEPLOYMENT_ROOT}/global/releases

	create_root_readme   >${DEPLOYMENT_ROOT}/README.md
	create_global_readme >${DEPLOYMENT_ROOT}/global/README

	cat > ${DEPLOYMENT_ROOT}/global/deployment.yml <<EOF
---
name: (( param "Please define the deployment name in the environment templates" ))

resource_pools: (( param "Please define one or more resource pools for your BOSH deployment" ))
disk_pools:     (( param "Please define one or more disk pools for your BOSH deployment" ))
networks:       (( param "Please define one or more networks for your BOSH deployment" ))

update:
  canaries: 1
  max_in_flight: 1
  serial: true
EOF
	for file in jobs properties; do
		cat > ${DEPLOYMENT_ROOT}/global/${file}.yml <<EOF
--- {}
EOF
	done
}

refresh_global() {
	setup
	local site=${1:?refresh_global() - no site given}
	local env=${2:?refresh_global() - no environment given}
	local root="${DEPLOYMENT_ROOT}/${site}/${env}"

	local saved=0
	if [[ -d ${root}/.global ]]; then
		saved=1
		mv ${root}/.global ${root}/.global.old
	fi

	cp -a ${DEPLOYMENT_ROOT}/global ${root}/.global
	if [[ $? != 0 ]]; then
		if [[ ${saved} == 1 ]]; then
			mv ${root}/.global.old ${root}/.global
		fi
		echo >&2 "Error: failed to refresh global for ${site}/${env}"
		exit 2
	fi

	rm -fr ${root}/.global.old
}

create_site() {
	setup
	local site=${1:?create_site() - no site provided}

	check_site_name ${site}

	mkdir -p ${DEPLOYMENT_ROOT}/${site}
	mkdir -p ${DEPLOYMENT_ROOT}/${site}/site
	mkdir -p ${DEPLOYMENT_ROOT}/${site}/site/stemcell

	create_site_readme ${site} >${DEPLOYMENT_ROOT}/${site}/site/README

	cat > ${DEPLOYMENT_ROOT}/${site}/site/disk-pools.yml <<EOF
---
disk_pools: []
EOF
	cat > ${DEPLOYMENT_ROOT}/${site}/site/update.yml <<EOF
---
update:
  canary_watch_time: 1000-60000
  update_watch_time: 1000-60000
  max_in_flight: 1
EOF
	for file in networks resource-pools jobs properties; do
		cat > ${DEPLOYMENT_ROOT}/${site}/site/${file}.yml <<EOF
--- {}
EOF
	done

	(cd ${DEPLOYMENT_ROOT}/global/releases ; ls -1) > ${DEPLOYMENT_ROOT}/${site}/site/releases
}

refresh_site() {
	setup
	local site=${1:?refresh_site() - no site given}
	local env=${2:?refresh_site() - no environment given}
	local root="${DEPLOYMENT_ROOT}/${site}/${env}"

	local saved=0
	if [[ -d ${root}/.site ]]; then
		saved=1
		mv ${root}/.site ${root}/.site.old
	fi

	cp -a ${DEPLOYMENT_ROOT}/${site}/site ${root}/.site
	if [[ $? != 0 ]]; then
		if [[ ${saved} == 1 ]]; then
			mv ${root}/.site.old ${root}/.site
		fi
		echo >&2 "Error: failed to refresh site for ${site}/${env}"
		exit 2
	fi

	rm -fr ${root}/.site.old
}

run_env_hooks() {
	if [[ -d ${DEPLOYMENT_ROOT}/.env_hooks ]]; then
		for file in ${DEPLOYMENT_ROOT}/.env_hooks/*; do
			if [[ -f ${file} && -x ${file} ]]; then
				export VAULT_PREFIX DEPLOYMENT_NAME DEPLOYMENT_SITE DEPLOYMENT_ENVIRONMENT DEPLOYMENT_ROOT ENVIRONMENT_ROOT
				if ! ${file}; then
					echo
					echo
					echo "env_hook '${file##*/}' bailed (exit ${?})."
					echo "Tearing down ${DEPLOYMENT_SITE}/${DEPLOYMENT_ENVIRONMENT} environment..."
					rm -rf ${ENVIRONMENT_ROOT}
					exit 1
				fi
			fi
		done
	fi
}

create_normal_environment() {
	setup
	local site=${1:?create_normal_environment() - no site provided}
	local name=${2:?create_normal_environment() - no environment name provided}
	local root=$(env_root ${site} ${name})

	check_site_name ${site}
	check_environment_name ${name}

	if [[ ! -d "${DEPLOYMENT_ROOT}/${site}" ]]; then
		create_site ${site}
	fi

	mkdir -p ${root}
	create_makefile ${root}/Makefile
	create_environment_readme ${site} ${name} >${root}/README

	for file in cloudfoundry credentials director monitoring properties networking scaling; do
		cat > ${root}/${file}.yml <<EOF
--- {}
EOF
	done

	need_a_bosh
	if [[ -n ${DIRECTOR_UUID} ]]; then
		cat <<EOF > ${root}/director.yml
---
director_uuid: ${DIRECTOR_UUID}
EOF
	fi

	VAULT_PREFIX=secret/${site}/${name}/${DEPLOYMENT_NAME}
	DEPLOYMENT_SITE=${site}
	DEPLOYMENT_ENVIRONMENT=${name}
	ENVIRONMENT_ROOT=${DEPLOYMENT_ROOT}/${DEPLOYMENT_SITE}/${DEPLOYMENT_ENVIRONMENT}

	cat <<EOF > ${root}/name.yml
---
name: ${site}-${name}-${DEPLOYMENT_NAME}
meta:
  type: ${DEPLOYMENT_NAME}
  site: ${site}
  env:  ${name}
  vault_prefix: ${VAULT_PREFIX}
EOF

	run_env_hooks

	refresh_global ${site} ${name}
	refresh_site   ${site} ${name}

	if [[ -n $HAVE_TREE ]]; then
		echo "Created environment ${site}/${name}:"
		tree ${root}
	else
		echo "Created environment ${site}/${name}"
	fi
	echo
	echo
}

create_bosh_init_environment() {
	setup
	local site=${1:?create_bosh_init_environment() - no site provided}
	local name=${2:?create_bosh_init_environment() - no environment name provided}
	local root=$(env_root ${site} ${name})

	check_site_name ${site}
	check_environment_name ${name}

	if [[ ! -d "${DEPLOYMENT_ROOT}/${site}" ]]; then
		create_site ${site}
	fi

	mkdir -p ${root}
	create_makefile ${root}/Makefile
	create_environment_readme ${site} ${name} >${root}/README

	for file in credentials name properties networking; do
		cat > ${root}/${file}.yml <<EOF
--- {}
EOF
	done

	VAULT_PREFIX=secret/${site}/${name}/${DEPLOYMENT_NAME}
	DEPLOYMENT_SITE=${site}
	DEPLOYMENT_ENVIRONMENT=${name}
	ENVIRONMENT_ROOT=${DEPLOYMENT_ROOT}/${DEPLOYMENT_SITE}/${DEPLOYMENT_ENVIRONMENT}

	cat <<EOF > ${root}/name.yml
---
name: ${site}-${name}-${DEPLOYMENT_NAME}
meta:
  type: ${DEPLOYMENT_NAME}
  site: ${site}
  env:  ${name}
  vault_prefix: ${VAULT_PREFIX}
EOF

	run_env_hooks

	refresh_global ${site} ${name}
	refresh_site   ${site} ${name}

	if [[ -n $HAVE_TREE ]]; then
		echo "Created environment ${site}/${env}:"
		tree ${root}
	else
		echo "Created environment ${site}/${env}"
	fi
	echo
	echo
}

releases_from() {
	local file=${1:?releases_from() - file not provided}
	cat ${file} | sed 's/\s*#.*//'
}

releases_for_site() {
	setup
	local site=${1:?releases_for_environment() - no site name provided}

	releases_from "${DEPLOYMENT_ROOT}/${site}/site/releases"
}

releases_for_environment() {
	setup
	local site=${1:?releases_for_environment() - no site name provided}
	local name=${2:?releases_for_environment() - no environment name provided}

	releases_from "${DEPLOYMENT_ROOT}/${site}/${name}/.site/releases"
}

preflight_deployment() {
	if [[ -n ${DEPLOYMENT_OK} ]]; then
		return
	fi

	must_be_in_an_environment
	case ${DEPLOYMENT_TYPE} in
	(normal)    preflight_normal_deployment    ;;
	(bosh-init) preflight_bosh_init_deployment ;;
	esac
	DEPLOYMENT_OK=yes
}

skip_preflight() {
	DEPLOYMENT_OK=skipped
}

preflight_normal_deployment() {
	if [[ ! -f "${DEPLOYMENT_ENV_DIR}/.site/stemcell/name" ]]; then
		echo >&2 "Error: no stemcell name specified for site"
		exit 2
	fi
	local stemcell_name=$(cat "${DEPLOYMENT_ENV_DIR}/.site/stemcell/name")

	if [[ ! -f "${DEPLOYMENT_ENV_DIR}/.site/stemcell/version" ]]; then
		echo >&2 "Error: no stemcell version specified for site"
		exit 2
	fi
	local stemcell_version=$(cat "${DEPLOYMENT_ENV_DIR}/.site/stemcell/version")
	if [[ ${stemcell_version} == "latest" ]]; then
		rm -f ${DEPLOYMENT_ENV_DIR}/.site/stemcell/url
		rm -f ${DEPLOYMENT_ENV_DIR}/.site/stemcell/sha1
	fi

	ensure_present stemcell ${stemcell_name} ${stemcell_version}

	if [[ ! -f "${DEPLOYMENT_ENV_DIR}/.site/releases" ]]; then
		echo >&2 "Error: no releases listed for site"
		exit 2
	fi

	local releases=$(releases_from "${DEPLOYMENT_ENV_DIR}/.site/releases")
	for rel in ${releases}; do
		if [[ ! -d "${DEPLOYMENT_ENV_DIR}/.global/releases/${rel}" ]]; then
			echo >&2 "Error: release '${rel}' not defined globally"
			exit 2
		fi
		if [[ ! -f "${DEPLOYMENT_ENV_DIR}/.global/releases/${rel}/version" ]]; then
			echo >&2 "Error: no version specified for release '${rel}'"
			exit 2
		fi

		local release_version=$(cat ${DEPLOYMENT_ENV_DIR}/.global/releases/${rel}/version)
		if [[ ${release_version} == "latest" ]]; then
			rm -f ${DEPLOYMENT_ENV_DIR}/.global/releases/${rel}/url
			rm -f ${DEPLOYMENT_ENV_DIR}/.global/releases/${rel}/sha1
		fi
		ensure_present release ${rel} ${release_version}
	done
}

normal_site_metadata() {
	must_be_in_an_environment
	preflight_deployment

	local stemcell_name=$(cat "${DEPLOYMENT_ENV_DIR}/.site/stemcell/name")
	local stemcell_version=$(cat "${DEPLOYMENT_ENV_DIR}/.site/stemcell/version")

	local stemcell_url=""
	if [[ -f ${DEPLOYMENT_ENV_DIR}/.site/stemcell/url ]]; then
		stemcell_url=$(cat ${DEPLOYMENT_ENV_DIR}/.site/stemcell/url)
	fi
	local stemcell_sha1=""
	if [[ -f ${DEPLOYMENT_ENV_DIR}/.site/stemcell/sha1 ]]; then
		stemcell_sha1=$(cat ${DEPLOYMENT_ENV_DIR}/.site/stemcell/sha1)
	fi

	cat <<EOF
---
meta:
  stemcell:
    name: ${stemcell_name}
    version: "${stemcell_version}"
EOF
	if [[ -n ${stemcell_url} ]]; then
		echo "    url: ${stemcell_url}"
	fi
	if [[ -n ${stemcell_sha1} ]]; then
		echo "    sha1: ${stemcell_sha1}"
	fi
	echo 'update: (( param "Please specify update settings for your bosh deployment" ))'
	echo "releases:"

	local releases=$(releases_from "${DEPLOYMENT_ENV_DIR}/.site/releases")
	for rel in ${releases}; do
		local release_version=$(cat ${DEPLOYMENT_ENV_DIR}/.global/releases/${rel}/version)
		local release_url=""
		if [[ -f ${DEPLOYMENT_ENV_DIR}/.global/releases/${rel}/url ]]; then
			release_url=$(cat ${DEPLOYMENT_ENV_DIR}/.global/releases/${rel}/url)
		fi
		local release_sha1=""
		if [[ -f ${DEPLOYMENT_ENV_DIR}/.global/releases/${rel}/sha1 ]]; then
			release_sha1=$(cat ${DEPLOYMENT_ENV_DIR}/.global/releases/${rel}/sha1)
		fi

		echo "  - name: ${rel}"
		echo "    version: \"${release_version}\""
		if [[ -n ${release_url} ]]; then
			echo "    url: \"${release_url}\""
		fi
		if [[ -n ${release_sha1} ]]; then
			echo "    sha1: \"${release_sha1}\""
		fi
	done
}

build_manifest() {
	must_be_in_an_environment
	need_command spruce
	preflight_deployment

	case ${DEPLOYMENT_TYPE} in
	(normal)
		normal_site_metadata > ${DEPLOYMENT_ENV_DIR}/.begin.yml || exit 2
		PRUNES="--prune meta --prune cloud_provider"
		;;
	(bosh-init)
		bosh_init_site_metadata > ${DEPLOYMENT_ENV_DIR}/.begin.yml || exit 2
		PRUNES="--prune meta --prune update"
		;;
	esac
	(cd ${DEPLOYMENT_ENV_DIR}
	 spruce $SPRUCE_OPTS merge ${PRUNES} \
	    .begin.yml \
	    $(actual_yaml_files \
	        .begin.yml \
	        \
	        .global/jobs.yml \
	        .global/deployment.yml \
	        .global/properties.yml \
	        \
	        .site/disk-pools.yml \
	        .site/update.yml \
	        .site/jobs.yml \
	        .site/networks.yml \
	        .site/resource-pools.yml \
	        .site/properties.yml \
	        \
	        monitoring.yml \
	        networking.yml \
	        director.yml \
	        scaling.yml \
	        properties.yml \
	        credentials.yml \
	        cloudfoundry.yml \
	        name.yml))

	rc=$?

	rm -f ${DEPLOYMENT_ENV_DIR}/.begin.yml

	if [[ $rc != 0 ]]; then
		echo >&2 "Failed to merge templates; bailing..."
		exit 5
	fi
}

have_blob() {
	local type=$1; shift
	local name=$1; shift
	local version=$1; shift

	need_a_bosh
	need_a_workdir
	ask_bosh /releases  > ${WORKDIR}/bosh.releases
	ask_bosh /stemcells > ${WORKDIR}/bosh.stemcells
	if [[ -n ${DIRECTOR_UUID} ]]; then
		case "${version}/${type}" in
		(latest/release)
			test -n "$(jq <${WORKDIR}/bosh.releases -r '.[]| select(.name == "'${name}'") | "ok"')"
			return $?
			;;

		(latest/stemcell)
			test -n "$(jq <${WORKDIR}/bosh.stemcells -r '.[]| select(.name == "'${name}'") | "ok"')"
			return $?
			;;

		(*/release)
			test -n "$(jq <${WORKDIR}/bosh.releases -r '.[] | select(.name == "'${name}'") | .release_versions[] | select(.version == "'${version}'") | "ok"')"
			return $?
			;;

		(*/stemcell)
			test -n "$(jq <${WORKDIR}/bosh.stemcells -r '.[]| select(.name == "'${name}'") | select(.version == "'${version}'") | "ok"')"
			return $?
			;;

		(*)
			echo >&2 "Error: Invalid type. This is a bug. Got ${type} but expected 'stemcell' or 'release'"
			exit 2
			;;
		esac
	else
		echo >&2 "Error: Could not contact your BOSH director to find release / stemcell information"
		exit 2
	fi
}

ensure_present() {
	local type=$1; shift
	local name=$1; shift
	local version=$1; shift
	if [[ ${version} != "track" ]]; then
		if have_blob ${type} ${name} ${version}; then
			echo >&2 "Found ${type} ${name} ${version} on director"
			return 0
		else
			local root=""
			case ${type} in
			(stemcell)
				root=${DEPLOYMENT_ENV_DIR}/.site/stemcell
				;;
			(release)
				root=${DEPLOYMENT_ENV_DIR}/.global/releases/${name}
				;;
			(*)
				echo >&2 "Invalid type '${type}' given to check_index.  Please file a bug"
				exit 2
				;;
			esac

			# if sha1 + url are specified, let bosh handle the uploads
			if [[ ! -f ${root}/sha1 && ! -f ${root}/url ]]; then
				echo >&2 "Uploading ${type} ${name}/${version} as it is required, but not present"
				upload_blob ${type} ${name} ${version}
			fi
		fi
	else
		echo >&2 ${type} ${name} ${version} is set to track from the index
		check_index ${type} ${name} ${version}
	fi
}

upload_blob() {
	local type=$1; shift
	local name=$1; shift
	local version=$1; shift

	if [[ -z ${GENESIS_INDEX} ]]; then
		echo >&2 "Error: ${type} ${name}/${version} is not present on the BOSH director."
		echo >&2 "       Please either \`bosh upload ${type}\` manually, or enable the"
		echo >&2 "       Genesis index by setting the GENESIS_INDEX environment variable."
		exit 2
	fi

	need_a_workdir

	if [[ $version != "latest" ]]; then
		version="v/${version}"
	fi

	echo >&2 "  checking ${GENESIS_INDEX} for details on ${type} ${name}/${version}"
	if ! curl --fail -Lsk ${GENESIS_INDEX}/v1/${type}/${name}/${version} > ${WORKDIR}/index; then
		echo >&2 "Unable to upload ${type} ${name}/${version} - could not find details on Genesis index"
		echo >&2 "(at $GENESIS_INDEX)"
		exit 2
	fi

	url=$(jq -r ".url" <${WORKDIR}/index)
	if [[ -z ${url} ]]; then
		echo >&2 "No URL found in the Genesis index for ${type}/${name}/${version}"
		echo >&2 "(at $GENESIS_INDEX)"
		echo >&2 "Either upload the ${type} manually, or add ${name} to the Genesis index."
		exit 2
	fi

	desired_uuid=$(spruce json director.yml | jq -r '.director_uuid')
	current_uuid=$(bosh status --uuid)
	if [[ $desired_uuid != $current_uuid ]]; then
		echo >&2 "Director UUID mismatch detected. You do not appear to be targeting"
		echo >&2 "the director for this deployment (expected $desired_uuid, got $current_uuid)"
		exit 2
	fi
	echo >&2 "Could not find ${type} ${name}/${version} on the director, uploading it for you"
	if ! bosh upload "${type}" "${url}" >&2; then
		echo >&2 "Failed to upload ${type} ${name}/${version}. Bailing out"
		exit 2
	fi
}

preflight_bosh_init_deployment() {
	if [[ ! -f "${DEPLOYMENT_ENV_DIR}/.site/stemcell/name" ]]; then
		echo >&2 "Error: no stemcell name specified for site"
		exit 2
	fi
	local stemcell_name=$(cat "${DEPLOYMENT_ENV_DIR}/.site/stemcell/name")

	if [[ ! -f "${DEPLOYMENT_ENV_DIR}/.site/stemcell/version" ]]; then
		echo >&2 "Error: no stemcell version specified for site"
		exit 2
	fi
	local stemcell_version=$(cat "${DEPLOYMENT_ENV_DIR}/.site/stemcell/version")
	if [[ ${stemcell_version} == "latest" ]]; then
		echo >&2 "Error: bosh-init deployments cannot use 'latest' as a stemcell version"
		echo >&2 "       (you probably want 'track', so that Genesis uses the Index)"
		exit 2
	fi
	check_index stemcell ${stemcell_name} ${stemcell_version}

	if [[ ! -f "${DEPLOYMENT_ENV_DIR}/.site/stemcell/url" ]]; then
		echo >&2 "Error: no stemcell URL listed for site"
		exit 2
	fi
	local stemcell_url=$(cat "${DEPLOYMENT_ENV_DIR}/.site/stemcell/url")
	if [[ ! -f "${DEPLOYMENT_ENV_DIR}/.site/stemcell/sha1" ]]; then
		echo >&2 "Error: no stemcell sha1 listed for site"
		exit 2
	fi
	local stemcell_sha1=$(cat "${DEPLOYMENT_ENV_DIR}/.site/stemcell/sha1")

	if [[ ! -f "${DEPLOYMENT_ENV_DIR}/.site/releases" ]]; then
		echo >&2 "Error: no releases listed for site"
		exit 2
	fi
	local releases=$(releases_from "${DEPLOYMENT_ENV_DIR}/.site/releases")

	for rel in ${releases}; do
		if [[ ! -d "${DEPLOYMENT_ENV_DIR}/.global/releases/${rel}" ]]; then
			echo >&2 "Error: release '${rel}' not defined globally"
			exit 2
		fi
		if [[ ! -f "${DEPLOYMENT_ENV_DIR}/.global/releases/${rel}/version" ]]; then
			echo >&2 "Error: no version specified for release '${rel}'"
			exit 2
		fi

		local release_version=$(cat ${DEPLOYMENT_ENV_DIR}/.global/releases/${rel}/version)
		if [[ ${release_version} == "latest" ]]; then
			echo >&2 "Error: bosh-init deployments cannot use 'latest' as release versions [for ${rel}]"
			echo >&2 "       (you probably want 'track', so that Genesis uses the Index)"
			exit 2
		fi
		check_index release ${rel} ${release_version}

		if [[ ! -f "${DEPLOYMENT_ENV_DIR}/.global/releases/${rel}/url" ]]; then
			echo >&2 "Error: no url specified for '${rel}'"
			exit 2
		fi
		if [[ ! -f "${DEPLOYMENT_ENV_DIR}/.global/releases/${rel}/sha1" ]]; then
			url=$(cat "${DEPLOYMENT_ENV_DIR}/.global/releases/${rel}/url")
			echo >&2 "retrieving ${url}"
			sha1=$(curl -LSs "${url}" | checksum | sed -e 's/ .*//')
			if [[ -z "${sha1}" ]]; then
				echo >&2 "Error: failed to download and verify ${rel} release"
				echo >&2 "       (from $url)"
				exit 2
			fi
			echo "$sha1" > "${DEPLOYMENT_ENV_DIR}/.global/releases/${rel}/sha1"
		fi
	done
}

bosh_init_site_metadata() {
	must_be_in_an_environment
	preflight_deployment

	local stemcell_name=$(cat "${DEPLOYMENT_ENV_DIR}/.site/stemcell/name")
	local stemcell_url=$(cat "${DEPLOYMENT_ENV_DIR}/.site/stemcell/url")
	local stemcell_sha1=$(cat "${DEPLOYMENT_ENV_DIR}/.site/stemcell/sha1")
	cat <<EOF
---
meta:
  stemcell:
    url: ${stemcell_url}
    sha1: ${stemcell_sha1}

cloud_provider:
  template: (( param "Please define the Cloud Provider to use for your BOSH deployment" ))
  properties: (( param "Please define the configuration for your BOSH Cloud Provider" ))

releases:
EOF

	local releases=$(releases_from "${DEPLOYMENT_ENV_DIR}/.site/releases")
	for rel in ${releases}; do
		echo "  - name: ${rel}"
		echo "    url:  $(cat ${DEPLOYMENT_ENV_DIR}/.global/releases/${rel}/url)"
		echo "    sha1: $(cat ${DEPLOYMENT_ENV_DIR}/.global/releases/${rel}/sha1)"
	done
}

####################################################
# multi-call handlers

: <<'dox-command:version'
USAGE
@~include=usage

DESCRIPTION
	Displays the version and checksum of the genesis executable.

SEE ALSO
@~include=related{"items":["command:update","command:embed"]}
dox-command:version
cmd_version() {
	s=$(cat ${BASH_SOURCE[0]} | checksum)
	echo "genesis ${VERSION} (${s:0:12})"
	exit 0
}

: <<'dox-command:update'
USAGE
@~include=usage

DESCRIPTION
	Updates the version of the genesis executable to the latest release from the
	genesis repo.

SEE ALSO
@~include=related{"items":["command:version","command:embed"]}
dox-command:update
cmd_update() {
	need_a_workdir
	curl -Ls $(curl -s ${API_REPO}/releases/latest | jq -r '.assets[] | select(.name | test("genesis")) | .browser_download_url') > ${WORKDIR}/bin
	chmod 0755 ${WORKDIR}/bin
	if ! ${WORKDIR}/bin ping >/dev/null 2>&1; then
		echo >&2 "Download failed / corrupt; NOT proceeding with update..."
		echo >&2 "sha1:$(sha1sum ${WORKDIR}/bin | awk '{print $1}')"
		${WORKDIR}/bin ping >&2
		exit 1
	fi
	cp ${WORKDIR}/bin $0
	exit $?
}

: <<'dox-command:embed'
USAGE
@~include=usage

DESCRIPTION
	Embeds the version of `genesis' installed in your $PATH into your deployment
	repo under /bin, so it can be used via the Makefile and Concourse tasks.
	This will replace any version already embedded. 

SEE ALSO
@~include=related{"items":["command:version","command:update"]}
dox-command:embed
cmd_embed() {
  [[ -z $1 ]] || bad_usage_no_args

  echo "Embedding genesis script into repository"
  setup

  mkdir -p ${DEPLOYMENT_ROOT}/bin
  cp ${BASH_SOURCE[0]} ${DEPLOYMENT_ROOT}/bin/genesis
  chmod 755 ${DEPLOYMENT_ROOT}/bin/genesis

  ${DEPLOYMENT_ROOT}/bin/genesis version
}

: <<'dox-concept:Structure'
DESCRIPTION
  Genesis organizes the files used to build your manifests into logical
  locations based on hierarchial and functional scope.

  Each genesis-generated deployment repository contains the YAML templates that
  contain the details required to create the BOSH deployment manifest across
  one or more sites and environments.

  The configuration is broken up into three logical strata: global,
  site, and environment:

    global:
      Defines the universal aspects of any deployment, including overall job
      structure, constituent BOSH releases, and invariant (or default)
      properties.

    site:
      represents a single IaaS (an AWS VPC, a vSphere cluster, etc.), and
      further refines the global configuration for that infrastructure.

    environment:
      represents a single BOSH deployment, with specific network numbering,
      credentials, domain names, etc.

  Directory Structure
  -------------------

  <software>-deployments
  |-- README.md
  |-- bin
  |   `-- genesis
  |-- global
  |   |-- README
  |   |-- deployment.yml
  |   |-- jobs.yml
  |   |-- properties.yml
  |   `-- releases
  |       |-- <release-name-1>
  |       |   |-- sha1
  |       |   |-- url
  |       |   `-- version
  |       `-- <release-name-2>
  |           `-- version
  `-- <site-name-1>
      |-- <environment-name-1>
      |   |-- Makefile
      |   |-- README
      |   |-- cloudfoundry.yml
      |   |-- credentials.yml
      |   |-- director.yml
      |   |-- manifests
      |   |   `-- manifest.yml
      |   |-- monitoring.yml
      |   |-- name.yml
      |   |-- networking.yml
      |   |-- properties.yml
      |   `-- scaling.yml
      `-- site
          |-- README
          |-- disk-pools.yml
          |-- jobs.yml
          |-- networks.yml
          |-- properties.yml
          |-- releases
          |-- resource-pools.yml
          |-- stemcell
          |   |-- name
          |   `-- version
          `-- update.yml

  Global Definitions
  ------------------

  The `global` directory contains templates that describe the common elements
  of all deployments for this software, to be shared (and possibly overridden)
  by sites and environments.  The templates are merged in the following
  order:

    jobs.yml:       Specify what jobs will make up the canonical deployment,
                    and what templates to apply to them.

    deployment.yml: Define the global structure of all deployments with the
                    correct param calls to remind template writers to override
                    the correct things.

    properties.yml: Define the properties for this deployment.  This can be
                    done on a per-job basis, or under the top-level properties
                    key.

    releases:       This directory contains a directory for each release used
                    by the deployment.  These should not be modified by hand,
                    but instead using the `(add|set|use) release` commands. See
                    help for `Releases` for more information.

  NOTE:
    If you make changes to the templates in here, they will automatically
    propagate to any newly-created environments, but you will need to run a
    refresh for existing environments to receive those updates.

  Site Definitions
  ----------------

  All directories found at the root of the repository that themselves contain
  a directory called `site` are considered sites.  This is usually used to
  describe infrastructure-specific settings and site-wide properties, although
  you can have multiple sites that run under the same infrastructure.  The
  templates are merged in the following order:

    disk-pools.yml:     If you are using disk pools, put disk pool definitions
                        in this file.

    update.yml:         Specify job update parameters here, which can change
                        based on the cloud provider in use, and its performance
                        characteristics.

    jobs.yml:           Here you can modify the list of jobs defined at the
                        global level, remove jobs (by setting their instances:
                        count to 0), and supply any additional, site-wide job
                        properties.

    networks.yml:       Define what networks to use for all the environments in
                        this site (although you may want to defer the actual
                        numbering to the environment level.

    resource-pools.yml: Set up the resource pools to use for job virtual
                        machines, and apply their cloud properties (i.e.
                        availability zones)

    properties.yml:     Define properties (both globally and per-job), that are
                        specific to this environment.  These will most likely
                        override global properties.

  NOTE:
    If you make changes to the templates in here, they will automatically
    propagate to any newly-created environments, but you will need to run a
    refresh for existing environments to receive those updates.

  Environment Definitions
  -----------------------

  All other directories that are siblings to the `site` directory represent a
  single environment to be deployed.  Each one contains templates that describe
  the environment-specific settings of a single deployment.  These templates
  will be combined with the global and site templates to produce a single BOSH
  manifest for deployment purposes.  The templates are merged in the following
  order:

    monitoring.yml:   Configure whatever (external) monitoring system you want
                      to track the performance and health of your deployment.

    networking.yml:   Configure the network numbering for this deployment.

    director.yml:     Identify the BOSH director UUID for this deployment.

    scaling.yml:      Define the scaling properties for this deployment,
                      including things like the number of instances, sizes of
                      persistent disks, resource pool limits, etc.

    properties.yml:   Define properties (both globally and per-job), that are
                      specific to this environment.  These will most likely
                      override global and site properties.

    credentials.yml:  Define passwords and credentials here, so that they are
                      centralized.  Keep in mind that commiting these into
                      version control incurs some security risk.

    cloudfoundry.yml: For deployments that integrate with Cloud Foundry
                      installations (i.e. as service brokers), you can specify
                      the integration details here, including things like the
                      CF API, credentials, domains, etc.

    name.yml:         Specify the name of this deployment.

  This directory also contains a Makefile that makes it easier to build the
  final BOSH manifest from all of the constituent templates.  See help for
  `Makefiles`for more information.

COMMANDS
@~include=topic{"category":"command","scope":"structure","leader":"  <<SCRIPT_NAME>> ","desc":"inline"}

dox-concept:Structure

: <<'dox-concept:Structure-bosh-init'
DESCRIPTION
  Genesis can be used to create manifests that can standup a BOSH director
  using bosh-init.

TODO: Fill in info on how to do this.
dox-concept:Structure-bosh-init

: <<'dox-partial:new'
DESCRIPTION
  Creates new things, with all the right files in all the right places.
dox-partial:new

: <<'dox-command:new-deployment'
USAGE
@~include=usage{"args":"[-t <type>] [-T <template>] [-r <dir>] <name>"}

DESCRIPTION
	Create a new deployment directory, with all the necessary files for deploying
	with Genesis.

	Specifying `--template' tells genesis to create your deployment directory
	based on the specified template repo.

OPTIONS
	-t, --type <type>
		Generate a different type of deployment.  Valid values are 'normal' and
		'bosh' (or 'bosh-init'). The default is 'normal'.

	-T, --template <name>
		Base the deployment off of an upstream Genesis template, by cloning a
		repository from github.com and using that.

		Templates can be specified as qualified name containing the Github org/user
		and repository name, i.e. "jhunt/bolo", or as a simple name, i.e. "shield",
		which will be inferred to belong to the starkandwayne organization.

	-r, --root <dirname>
		The root directory under which to create the new deployment structure.
		Defaults to the current directory.

ARGUMENTS
	name
		The name of the deployment to be created.  This will result in a directory
		called <name>-deployments

SEE ALSO
@~include=related{"items":["command:new site","command:new environment"]}

@~include=related{"items":["concept:Structure","concept:Structure bosh-init"]}

@~scope=common,structure
dox-command:new-deployment

cmd_new_deployment() {
	local dtype="normal"
	local root=$(pwd)
	local name=""
	local template=""

	while (( $# )); do
		arg=$1 ; shift
		case ${arg} in
		(-t|--type)
			check_opt_usage "$arg" "$1"
			dtype=$1
			shift
			;;
		(-T|--template)
			check_opt_usage "$arg" "$1"
			template=$1
			shift
			;;
		(-r|--root)
			check_opt_usage "$arg" "$1"
			root=$1
			shift
			;;
		(-*) bad_usage_invalid_opt "$arg" ;;
		(*)
			name=${arg%-deployment*}
			shift
			;;
		esac
	done

	if [[ -n ${template} ]]; then
		if [[ ${template} != ?*/?* ]]; then
			template="starkandwayne/${template}"
		fi
		template="${template%%-deployment*}-deployment"

		if [[ -z ${name} ]]; then
			name=${template##*/}
			name=${name%%-deployment*}
		fi
	fi
	[[ -n ${name:-} ]] || bad_usage_missing "deployment name"

	if [[ ! -d ${root} ]]; then
		echo >&2 "Error: root directory ${root} does not exist"
		exit 1
	fi

	if [[ -d "${root}/${name}-deployments" ]]; then
		echo >&2 "Error: target directory ${root}/${name}-deployments already exists!"
		exit 1
	fi

	if [[ -n ${template} ]]; then
		local url=https://github.com/${template}
		set -e
		echo "cloning from template ${url}"
		git clone --origin upstream ${url} ${root}/${name}-deployments
		cd ${root}/${name}-deployments
		git config --remove-section branch.master

		cmd_embed
		git add bin/genesis

		create_root_readme   >README.md
		create_global_readme >global/README

		git add .
		git commit -m "Initial clone of templated ${name} deployment"
		exit 0
	fi

	case ${dtype} in
		(normal|bosh-init) ;;
		(bosh) dtype=bosh-init ;;
		(*)
			echo >&2 "Error: unrecognized deployment type '${dtype}'"
			exit 1
			;;
	esac

	DEPLOYMENT_TYPE=${dtype}
	DEPLOYMENT_NAME=${name}
	DEPLOYMENT_ROOT="${root}/${name}-deployments"
	mkdir ${DEPLOYMENT_ROOT}

	case ${DEPLOYMENT_TYPE} in
	(normal)
		echo "normal" > ${DEPLOYMENT_ROOT}/.deployment
		;;
	(bosh-init)
		echo "bosh-init" > ${DEPLOYMENT_ROOT}/.deployment
		;;
	esac
	create_deployment

	cmd_embed >/dev/null

	cat > ${DEPLOYMENT_ROOT}/.gitignore <<EOF
.begin.yml
.deploy.yml
EOF

	if git symbolic-ref HEAD 2>&1 | grep -qE 'fatal: Not a git repository|fatal: Unable to read current working directory'; then
		(cd ${DEPLOYMENT_ROOT}
		 git init
		 git add .
		 git commit -m "Initial commit of ${name}-deployments")
	fi
	exit 0
}

: <<'dox-command:new-site'
USAGE
@~include=usage{"args":"[-T <template>] <name>"}

DESCRIPTION
	Sets up the files and directories for a new site.

	When run, this command creates a new site with the given name, and set up the
	necessary directories and blank template files for defining the parts of a
	BOSH manifest that map to infrastructural and site-wide things.

	Specifying `--template' tells genesis to create the
	site directory based on the specified IaaS templates.

OPTIONS
	-T, --template <name>
		Base the new site off of a site template.  This generally only works if you
		generated the deployment from an upstream Genesis template (via
		'--template')

		See the `.templates' directory at the root of your
		deployment repo for valid options.

ARGUMENTS
	name
		The name of the site being created.  This is usually discriptive of a data
		center or cloud provider, such as `aws-us-east` or `myOrg-myDC-vsphere`

SEE ALSO
@~include=related{"items":["command:new deployment","command:new environment"]}

@~scope=common,structure
dox-command:new-site

cmd_new_site() {
	local name=""
	local template=""

	while (( $# )); do
		arg=$1 ; shift
		case ${arg} in
		(-T|--template)
			template=$1
			shift
			;;
		(-*)
			bad_usage_invalid_opt "$arg"
			;;
		(*)
			name=${arg}
			;;
		esac
	done
	[[ -n ${name} ]] || bad_usage_missing "site name"

	setup
	if [[ -d "${DEPLOYMENT_ROOT}/${name}" ]]; then
		echo "Site ${name} already exists"
		exit 0
	fi

	if [[ -n ${template} ]]; then
		if [[ ! -d ${DEPLOYMENT_ROOT}/.templates/${template} ]]; then
			echo >&2 "Site template '${template}' not found..."
			exit 2
		fi

		mkdir -p ${DEPLOYMENT_ROOT}/${name}
		cp -a ${DEPLOYMENT_ROOT}/.templates/${template} ${DEPLOYMENT_ROOT}/${name}/site
		create_site_readme ${name} >${DEPLOYMENT_ROOT}/${name}/README
		if [[ -n $HAVE_TREE ]]; then
			echo "Created site ${name} (from template ${template}):"
			tree "${DEPLOYMENT_ROOT}/${name}"
		else
			echo "Created site ${name} (from template ${template})"
		fi

	else
		create_site ${name}
		if [[ -n $HAVE_TREE ]]; then
			echo "Created site ${name}:"
			tree "${DEPLOYMENT_ROOT}/${name}"
		else
			echo "Created site ${name}"
		fi
	fi

	echo
	echo
	exit 0
}

: <<'dox-command:new-environment'
USAGE
@~include=usage{"args":"[-t <type>] <site> <name>","cmd":"new env[ironment]"}
@~alias=new-env

DESCRIPTION
	Set up the files and directories for a new environment.

	When run, this command creates a new environment with the given name, in the
	specified site, and set up the directories and template files for local,
	environment-specific things.

	Specifying `--type' of `bosh-init' will tell genesis to treat this specific
	environment as a bosh-init type deployment. Useful if you need to use
	bosh-init for some environments, but regular BOSH deployments for others.

OPTIONS
	-t, --type <type>
		Generate a different type of deployment.  Valid values are 'bosh-init' for
		a bosh-init environment, 'bosh' which is an abreviation for 'bosh-init',
		and 'normal' for standard bosh deployments (the default is 'normal') .

ARGUMENTS
	site (optional if in a site directory, required otherwise)
		The name of the site under which the environment is being created.
	name
		The name of the environment being created.  This is usually discriptive of
		a data center or cloud provider, such as `aws-us-east` or
		`myOrg-myDC-vsphere`

SEE ALSO
@~include=related{"items":["command:new deployment","command:new site"]}

@~scope=common,structure
dox-command:new-environment

cmd_new_environment() {
	local dtype site name
	while (( $# )); do
		arg=$1 ; shift
		case ${arg} in
		(-t|--type)
			dtype=$1
			case ${dtype} in
			(normal|bosh-init) ;;
			(bosh) dtype=bosh-init ;;
			(*) echo >&2 "unrecognized deployment type: ${dtype}"
			    exit 1 ;;
			esac
			shift
			;;
		(-*) bad_usage_invalid_opt "$arg" ;;
		(*)
			if [[ -z ${site} ]]; then
				site=${arg}
			elif [[ -z ${name} ]]; then
				name=${arg}
			else
				bad_usage_extra "$arg"
			fi
			;;
		esac
	done

	setup
	if [[ -n ${DEPLOYMENT_SITE} && -z ${name} ]]; then
		name=${site}
		site=${DEPLOYMENT_SITE}
	fi

	case ${dtype:-$DEPLOYMENT_TYPE} in
		(normal)    create_normal_environment ${site} ${name} ;;
		(bosh-init) create_bosh_init_environment ${site} ${name} ;;
	esac

	if [[ -n ${dtype} ]]; then
		echo ${dtype} > ${DEPLOYMENT_ROOT}/${site}/${name}/.type
	fi

	exit 0
}

check_index() {
	local type=${1:?check_index() - no type given}
	local name=${2:?check_index() - no name given}
	local version=${3:?check_index() - no version given}

	# if the caller wants "latest", that means latest
	# available on the BOSH director, so there's nothing
	# we can / should do about that.
	if [[ ${version} == "latest" ]]; then
		return
	fi

	local root=""
	case ${type} in
	(stemcell)
		root=${DEPLOYMENT_ENV_DIR}/.site/stemcell
		;;
	(release)
		root=${DEPLOYMENT_ENV_DIR}/.global/releases/${name}
		;;
	(*)
		echo >&2 "Invalid type '${type}' given to check_index.  Please file a bug"
		exit 2
		;;
	esac

	# if the operator wants us to track, but we are likewise
	# instructed not to contact the index, we should bail out
	if [[ -z ${GENESIS_INDEX} && ${version} == "track" ]]; then
		echo >&2 "Unable to check the Genesis Index for the latest version of ${type} ${name}!"
		echo >&2 "(GENESIS_INDEX environment variable is either not set, or"
		echo >&2 " set explicitly to 'no', disabling access to the Index)"
		exit 2
	fi

	if [[ -n ${GENESIS_INDEX} ]]; then
		need_a_workdir
		if [[ ${version} == "track" ]]; then
			echo >&2 "  checking ${GENESIS_INDEX} for details on latest ${type} ${name}"
			if ! curl --fail -Lsk ${GENESIS_INDEX}/v1/${type}/${name}/latest > ${WORKDIR}/index; then
				echo >&2 "Failed to access the Genesis Index"
				echo >&2 "(at $GENESIS_INDEX)"
				echo >&2 "Unable to track the latest version of ${type} ${name}"
				exit 2
			fi
		else
			echo >&2 "  checking ${GENESIS_INDEX} for details on ${type} ${name}/${version}"
			curl -Lsk ${GENESIS_INDEX}/v1/${type}/${name}/v/${version} > ${WORKDIR}/index
		fi

		for thing in url sha1 version; do
			v=$(jq -r ".${thing} // \"\"" <${WORKDIR}/index)
			if [[ -n ${v} ]]; then
				echo "${v}" > ${root}/${thing}
			fi
		done
	fi
}

: <<'dox-concept:Releases'
DESCRIPTION
	TODO: Add details on how releases are handled

Details on whats in the release directory, what's in the directory named for the desired release and what version sha1 and url files are for.
explain how to support multiple releases and release propagation, link to see also Refreshing.

COMMANDS
@~include=topic{"category":"command","scope":"releases","desc":"inline","leader":"  <<SCRIPT_NAME>> "}

dox-concept:Releases

: <<'dox-command:releases'
USAGE
@~include=usage{"args":"[<site> [<env>]]","cmd":"release[s]"}
@~alias=release

DESCRIPTION
	Lists the release name and version in use by the specified site or
	environment. If no arguments are specified, you must be in a site/environment
	directory.

ARGUMENTS
	site (optional)
		if this is the sole argument, the releases used by the named
		site will be displayed.  This is identical to the behaviour when run in
		a site directory with no arguments.

		Note: If in an environment directory, and just the site argument is
		supplied, it will display the releases for the environment of the same
		name as the current environment directory under the given site.

	env (optional) 
		will show the releases used by the specified environment
		under the given site.  This is identical to if no arguments are given
		when run from an environment directory.

SEE ALSO
@~include=related{"items":["concept:Releases","command:add release","command:set release", "command:use release"]}
@~scope=common,releases
dox-command:releases
cmd_releases() {
	local site env
	while (( $# )); do
		arg=$1 ; shift
		case ${arg} in
		(-*) bad_usage_no_opts ;;
		(*)
			if [[ -z ${site} ]]; then  site=${arg}
			elif [[ -z ${env} ]]; then env=${arg}
			else bad_usage_extra "$arg"
			fi
			;;
		esac
	done

	setup
	site=${site:-$DEPLOYMENT_SITE}
	env=${env:-$DEPLOYMENT_ENVIRONMENT}

	if [[ -n ${env} ]]; then
		for rel in $(releases_for_environment ${site} ${env}); do
			vers=$(cat ${DEPLOYMENT_ROOT}/${site}/${env}/.global/releases/${rel}/version)
			printf "%s/%s\n" ${rel} ${vers}
		done
		return
	fi

	if [[ -n ${site} ]]; then
		for rel in $(releases_for_site ${site}); do
			vers=$(cat ${DEPLOYMENT_ROOT}/global/releases/${rel}/version)
			printf "%s/%s\n" ${rel} ${vers}
		done
		return
	fi

	bad_usage
	exit 1
}
: <<'dox-command:add-release'
USAGE
@~include=usage{"args":"<name> [<version> [<url>]]"}

DESCRIPTION
	 Adds release definitions to the global configurations for the specified
	 release and optionally, its version.

ARGUMENTS
	name
		This is the name of the release

	version (optional)
		The version of the release that is to be used.  If not specified, it will
		default to `latest`.  The valid values are:
		
			`latest`:  use the latest version that is already available on the BOSH
								 director.  this may not be the latest version that exists for
								 this release at its source.

			`track`:   use the version specified in the Genesis Index, which tracks
								 accepted release versions.

			<version>: A cardinal or SemVer value for the exact release you want to
								 use, without any prefix such as 'v'

	url
		Specify the URL where the release is found, including the schema and the
		version.  For example:
		  https://bosh.io/d/github.com/myorg/mystuff-boshrelease?v=1.2.3

SEE ALSO
@~include=related{"items":["concept:Releases","command:releases","command:set release","command:use release"]}
@~scope=common,releases
dox-command:add-release

cmd_add_release() {
	local release version url

	while (( $# )); do
		arg=$1 ; shift
		case ${arg} in
		(-*) bad_usage_no_opts ;;
		(*)
			if [[ -z ${release} ]]; then   release=${arg}
			elif [[ -z ${version} ]]; then version=${arg}
			elif [[ -z ${url} ]]; then     url=${arg}
			else bad_usage_extra "$arg"
			fi
			;;
		esac
	done
	[[ -n ${release} ]] || bad_usage_missing "name"
	version=${version:-latest}

	setup
	if [[ -d ${DEPLOYMENT_ROOT}/global/releases/${release} ]]; then
		echo >&2 "Release ${release} already exists in global/releases/"
		exit 1
	fi
	mkdir -p ${DEPLOYMENT_ROOT}/global/releases/${release}
	echo ${version} > ${DEPLOYMENT_ROOT}/global/releases/${release}/version

	if [[ -n ${url} ]]; then
		echo ${url} > ${DEPLOYMENT_ROOT}/global/releases/${release}/url
	fi

	case ${version} in
	(latest)
		echo "Using the latest version of ${release} available on your BOSH director"
		;;
	(track)
		echo "Using the latest version of ${release} available via the Genesis Index"
		;;
	(*)
		echo "Using v${version} of ${release}"
		;;
	esac
	exit 0
}

: <<'dox-command:set-release'
USAGE
@~include=usage{"args":"<name> [<version> [<url>]]"}

DESCRIPTION
	Updates the specified release to the specified version at the global level.

ARGUMENTS
	name
		This is the name of the release

	version (optional)
		The version of the release that is to be used.  If not specified, it will
		default to `latest`.  The valid values are:
		
			`latest`:  use the latest version that is already available on the BOSH
								 director.  this may not be the latest version that exists for
								 this release at its source.

			`track`:   use the version specified in the Genesis Index, which tracks
								 accepted release versions.

			<version>: A cardinal or SemVer value for the exact release you want to
								 use, without any prefix such as 'v'

	url
		Specify the URL where the release is found, including the schema and the
		version.  For example:
		  https://bosh.io/d/github.com/myorg/mystuff-boshrelease?v=1.2.3

SEE ALSO
@~include=related{"items":["concept:Releases","command:releases","command:add release","command:use release"]}
	name
@~scope=common,releases
dox-command:set-release
cmd_set_release() {
	local release version

	while (( $# )); do
		arg=$1 ; shift
		case ${arg} in
		(-*)
			bad_usage
			;;
		(*)
			if [[ -z ${release} ]]; then   release=${arg}
			elif [[ -z ${version} ]]; then version=${arg}
			elif [[ -z ${url} ]]; then     url=${arg}
			else bad_usage_extra "$arg"
			fi
			;;
		esac
	done
	[[ -n ${release} ]] || bad_usage_missing "name"
	version=${version:-track}

	setup
	mkdir -p ${DEPLOYMENT_ROOT}/global/releases/${release}
	rm -rf   ${DEPLOYMENT_ROOT}/global/releases/${release}/*
	echo ${version} > ${DEPLOYMENT_ROOT}/global/releases/${release}/version

	[[ -n ${url} ]] && echo ${url} > ${DEPLOYMENT_ROOT}/global/releases/${release}/url

	case ${version} in
	(latest)
		echo "Using the latest version of ${release} available on your BOSH director"
		;;
	(track)
		echo "Using the latest version of ${release} available via the Genesis Index"
		;;
	(*)
		echo "Using v${version} of ${release}"
		;;
	esac
	exit 0
}

bad_set() {
	local arg=${1}
	cat >&2 <<EOF
USAGE: genesis set release
EOF
	exit 1
}

: <<'dox-command:use-release'
USAGE
@~include=usage{"args":"<name>"}

DESCRIPTION
	 When inside a site or environment directory, takes the provided release
	 name, and configures the site to include the release when deploying to
	 environments in that site.

ARGUMENTS
	name
		This is the name of the release to use.  Do not include the version.

SEE ALSO
@~include=related{"items":["concept:Releases","command:releases","command:add release","command:set release"]}

@~scope=common,releases
dox-command:use-release
cmd_use_release() {
	local release

	while (( $# )); do
		arg=$1 ; shift
		case ${arg} in
		(-*) bad_usage_invalid_opt "$arg" ;;
		(*)
			[[ -z ${release} ]] || bad_usage_extra "$arg" "name" "$release"
			release=${arg}
			;;
		esac
	done
	[[ -n ${release} ]] || bad_usage_missing "release name"

	must_be_in_a_site
	if [[ ! -d ${DEPLOYMENT_ROOT}/global/releases/${release} ]]; then
		echo >&2 "Release ${release} is not defined globally."
		echo >&2 "(Do you need to \`genesis add release ${release}' first?)"
		exit 1
	fi

	relfile=${DEPLOYMENT_SITE_DIR}/site/releases
	if grep -q "^${release}$" $relfile >/dev/null 2>&1; then
		echo "Site ${DEPLOYMENT_SITE} is already set to use release ${release}"
	else
		echo "${release}" >> $relfile
		echo "Site ${DEPLOYMENT_SITE} is now using release ${release}"
	fi
	exit 0
}

: <<'dox-concept:Stemcells'
DESCRIPTION
	Talk about stemcells

COMMANDS
@~include=topic{"category":"command","scope":"stemcells","desc":"inline","leader":"  <<SCRIPT_NAME>> "}
@~scope=stemcells
dox-concept:Stemcells

: <<'dox-command:stemcells'
USAGE
	<<SCRIPT_NAME>> stemcells [<site> [<env>]]

DESCRIPTION
	Lists the stemcell name + version in use by the specified site or
	environment.  If no arguments are specified, you must be in a
	site/environment directory.
	
ARGUMENTS
	site (optional)
		if this is the sole argument, the stemcell used by the named site will be
		displayed.  This is identical to the behaviour when run in a site directory
		with no arguments.

		Note: If in an environment directory, and just the site argument is
		supplied, it will display the stemcell for the environment of the same name
		as the current environment directory under the given site.
					
	env (optional)
		will show the stemcell used by the specified environment under the given
		site.  This is identical to if no arguments are given when run from an
		environment directory.

SEE ALSO
@~include=related{"items":["concept:Stemcells","command:use stemcell"]}
@~scope=common,stemcells
dox-command:stemcells

cmd_stemcells() {
	local site env
	while (( $# )); do
		arg=$1 ; shift
		case ${arg} in
		(-*) bad_usage_no_opts ;;
		(*)
			if [[ -z ${site} ]]; then  site=${site}
			elif [[ -z ${env} ]]; then env=${arg}
			else bad_usage_extra "$arg"
			fi
			;;
		esac
	done

	setup
	site=${site:-$DEPLOYMENT_SITE}
	env=${env:-$DEPLOYMENT_ENVIRONMENT}
	local path=""
	if [[ -n ${env} ]]; then
		path="${DEPLOYMENT_ROOT}/${site}/${env}/.site/stemcell"
	elif  [[ -n ${site} ]]; then
		path="${DEPLOYMENT_ROOT}/${site}/site/stemcell"
	else
		bad_usage_missing "site and/or env, or not in correct directory"
	fi

	if [[ -f "${path}/alias" ]] ; then # v2 Style
		local sc_alias="$(cat ${path}/alias)"
		local name
		if [[ -f "${path}/os" ]] ; then
			name="OS:$(cat ${path}/os)"
		else
			name="$(cat ${path}/name)"
		fi
		
		printf "%s/%s (v2 Manifest alias: %s)\n" "$name" $(cat "${path}/version") "$sc_alias"
	elif [[ -f "${path}/name" ]] ; then # v1 Style
		printf "%s/%s\n" $(cat ${path}/name) $(cat ${path}/version)
	else
		echo "ERROR: No stemcell found."
		exit 2
	fi
}
: <<'dox-command:use-stemcell'
USAGE
@~include=usage{"args":"[--alias <alias> [--os]] <name> [<version>]"}

DESCRIPTION
	When inside a site or environment directory, takes the provided stemcell
	name, and updates the site directory to use that stemcell. You can
	optionally specify the version of the stemcell to be used as a second
	argument after the stemcell name.

	For v1 manifests that do not use cloud config, you only specify name and
	optionally version.
	
	To generate v2-compatible manifests, you must also specify --alias <alias>
	and optionally the --os option.

ARGUMENTS
	name
		This is the full name of the stemcell, or a shorthand of the name (see the
		table below).  If the --os option is specified, this name is the name of
		the os (ie ubuntu-trusty)

	--os
		This changes the meaning of the name argument, from the name of the stem-
		cell to the name of the OS.  This can only be used if you also specify the
		--alias option.

	--alias <alias>
		Used to specify the stemcell alias as used by v2-style manifests to refer
		to a stemcell specified in the cloud config on the BOSH Director.

	version
		The version of the stemcell to be used.  If omitted, it will default to 
		`latest`.  Other valid versions are an explicit numerical version or
		`track` to indicate the most recent version found in the Genesis Index.
		Note: you cannot track against OS, only named stemcells.

STEMCELL SHORTHAND NAMES
	aws:       bosh-aws-xen-hvm-ubuntu-trusty-go_agent
	azure,
	hyperv:    bosh-azure-hyperv-ubuntu-trusty-go_agent
	openstack: bosh-openstack-kvm-ubuntu-trusty-go_agent
	vcloud:    bosh-vcloud-esxi-ubuntu-trusty-go_agent
	vsphere:   bosh-vsphere-esxi-ubuntu-trusty-go_agent
	warden,
	bosh-lite: bosh-warden-boshlite-ubuntu-trusty-go_agent"

SEE ALSO
@~include=related{"items":"concept:Stemcells"}

@~scope=common,stemcells
dox-command:use-stemcell
cmd_use_stemcell() {
	local name version sc_alias os

	while (( $# )); do
		arg=$1 ; shift
		case ${arg} in
		(--alias)
			sc_alias=$1; shift;
			echo >&2 "alias='$sc_alias'"
			if [[ "${sc_alias:0:1}" == "-" || -z "$sc_alias" ]] ; then
				bad_usage "no alias name provided with --alias option"
			fi
			;;
		(--os)
			os=true
			;;
		(-*)
			bad_usage_invalid_opt "$arg"
			;;
		(*)
			if [[ -z ${name} ]]; then
				name=${arg}
			elif [[ -z ${version} ]]; then
				version=${arg}
			else
				bad_usage
			fi
			;;
		esac
	done

	[[ $os && -z $sc_alias ]] && bad_usage "Cannot specify --os without --alias <alias>"
	[[ $os && "${name}" == "track" ]] && bad_usage "Cannot track against OS"
	[[ -n ${name} ]] || bad_usage_missing "name"
	version=${version:-latest}

	must_be_in_a_site

	# FIXME: check if bosh-init type deployments can specify alias/os (currently assuming not)
	if [[ "$DEPLOYMENT_TYPE" == 'bosh-init' && -n "$sc_alias" ]] ; then
		bad_usage "bosh-init manifests cannot use v2-style manifests"
	fi

	# resolve aliases
	case ${name} in
		(aws)              name="bosh-aws-xen-hvm-ubuntu-trusty-go_agent"     ;;
		(azure|hyperv)     name="bosh-azure-hyperv-ubuntu-trusty-go_agent"    ;;
		(openstack)        name="bosh-openstack-kvm-ubuntu-trusty-go_agent"   ;;
		(vcloud)           name="bosh-vcloud-esxi-ubuntu-trusty-go_agent"     ;;
		(vsphere)          name="bosh-vsphere-esxi-ubuntu-trusty-go_agent"    ;;
		(warden|bosh-lite) name="bosh-warden-boshlite-ubuntu-trusty-go_agent" ;;
	esac

	echo "Site ${DEPLOYMENT_SITE} stemcell:"
	mkdir -p ${DEPLOYMENT_SITE_DIR}/site/stemcell
	rm       "${DEPLOYMENT_SITE_DIR}/site/stemcell/*" >/dev/null 2>&1
	local name_file="name"
	if [[ -n "$sc_alias" ]] ; then
		echo "  - v2 manifest alias '$sc_alias'"
		echo "${sc_alias}" > "${DEPLOYMENT_SITE_DIR}/site/stemcell/alias"
		[[ $os ]] && name_file="os"
	fi
	echo "${name}"    > "${DEPLOYMENT_SITE_DIR}/site/stemcell/$name_file"
	echo "${version}" > "${DEPLOYMENT_SITE_DIR}/site/stemcell/version"
	echo "  - ${name_file} '${name}'";
	case ${version} in
	(latest)
		echo "  - using the latest version on BOSH director"
		;;
	(track)
		echo "  - tracking the latest version via the Genesis Index"
		;;
	(*)
		echo "  - version ${version}"
		;;
	esac
	exit 0
}

: <<'dox-command:build'
USAGE
@~include=usage{"args":"[<manifest-file>]"}

DESCRIPTION
	Compiles all of the YAML templates down to a single BOSH manifest for the
	current environment.

ARGUMENTS
  manifest-file (optional, default: manifest.yml)
		The file into which the manifest YAML document is written.

@~scope=make
dox-command:build
cmd_build() {
	local target
	while (( $# )); do
		arg=$1 ; shift
		case ${arg} in
		(-*) bad_usage_invalid_opt "$arg"	;;
		(*)
			[[ -z ${target} ]] || bad_usage_extra "$arg" "manifest-file" "$target"
			target=${arg}
			;;
		esac
	done
	target=${target:-manifest.yml}
	must_be_in_an_environment
	mkdir -p ${DEPLOYMENT_ENV_DIR}/manifests
	build_manifest > ${DEPLOYMENT_ENV_DIR}/manifests/${target}
	exit 0
}

: <<'dox-concept:Cached-Definitions'
DESCRIPTION
	Stablizes deployment manifests by caching global and site definitions.

	As explained in the Structure concept documents, genesis organizes the parts
	of the manifest definitions into those that apply globally, site-wide and to
	a specific environment.  However, since deployments are capable of changing
	over time (upgrades, bug fixes, expanded functionality), how do you ensure
	changes propagate correctly

COMMANDS
@~include=topic{"category":"command","scope":"refresh","desc":"inline","leader":"  <<SCRIPT_NAME>> "}

SEE ALSO
@~include=related{"items":["concept:Structure","concept:Makefiles","concept:CI"]}
@~scope=makefile
dox-concept:Cached-Definitions

: <<'dox-partial:refresh'
USAGE 
@~include=usage{"args":"[(global|site|all|makefile|readme)]"}

DESCRIPTION
	Refresh the cached copies of site and/or global definitions inside the current
	environment directory.  Can also be used to recreate the Makefile and readme
	files after a Genesis upgrade.  If run without a subcommand, it will default
	to 'all'.
dox-partial:refresh

: <<'dox-command:refresh-all'
USAGE
@~include=usage{"cmd":"refresh [all]"}

DESCRIPTION
	Refresh (or create) the cached copies of site and global definitions inside
	the current environment directory.  This is the default action if no refresh
	subcommand is specified.

@~group=refresh
@~scope=make
dox-command:refresh-all
cmd_refresh_all() {
	[[ -z $1 ]] || bad_usage_no_args

	must_be_in_an_environment
	echo "Refreshing site definitions for ${DEPLOYMENT_SITE}/${DEPLOYMENT_ENVIRONMENT}"
	refresh_site   ${DEPLOYMENT_SITE} ${DEPLOYMENT_ENVIRONMENT}
	echo "Refreshing global definitions for ${DEPLOYMENT_SITE}/${DEPLOYMENT_ENVIRONMENT}"
	refresh_global ${DEPLOYMENT_SITE} ${DEPLOYMENT_ENVIRONMENT}
	exit 0
}

: <<'dox-command:refresh-global'
USAGE
@~include=usage

DESCRIPTION
	Create or refresh the files in the .global cached directory in the current
	environment directory from the files in the ../../global directory.

@~group=refresh
@~scope=make
dox-command:refresh-global
cmd_refresh_global() {
	[[ -z $1 ]] || bad_usage_no_args

	must_be_in_an_environment
	echo "Refreshing global definitions for ${DEPLOYMENT_SITE}/${DEPLOYMENT_ENVIRONMENT}"
	refresh_global ${DEPLOYMENT_SITE} ${DEPLOYMENT_ENVIRONMENT}
	exit 0
}

: <<'dox-command:refresh-site'
USAGE
@~include=usage

DESCRIPTION
	Create or refresh the files in the .site cached directory in the current
	environment directory from the files in the ../site directory.

@~group=refresh
@~scope=make
dox-command:refresh-site
cmd_refresh_site() {
	[[ -z $1 ]] || bad_usage_no_args

	must_be_in_an_environment
	echo "Refreshing site definitions for ${DEPLOYMENT_SITE}/${DEPLOYMENT_ENVIRONMENT}"
	refresh_site ${DEPLOYMENT_SITE} ${DEPLOYMENT_ENVIRONMENT}
	exit 0
}

: <<'dox-command:refresh-makefile'
USAGE
@~include=usage

DESCRIPTION
	Rebuild the Makefile for an environment, which can be useful to bring old
	deployments in-line with newer versions of Genesis.

@~group=refresh
@~scope=makefile
dox-command:refresh-makefile
cmd_refresh_makefile() {
	[[ -z $1 ]] || bad_usage_no_args

	must_be_in_an_environment
	echo "Refreshing Makefile for ${DEPLOYMENT_SITE}/${DEPLOYMENT_ENVIRONMENT}"
	create_makefile "${DEPLOYMENT_ENV_DIR}/Makefile"
}

: <<'dox-command:refresh-readmes'
USAGE
@~include=usage

DESCRIPTION
	Rebuild the various README files for the top-level and 'global' directories,
	and all sites and environments, which can be useful to bring old deployments
	in-line with newer versions of Genesis.

@~group=refresh
@~scope=make
dox-command:refresh-readmes
cmd_refresh_readmes() {
	[[ -z $1 ]] || bad_usage_no_args

	setup
	echo "Refreshing README for the whole repository"
	rm -f ${DEPLOYMENT_ROOT}/README*
	create_root_readme >${DEPLOYMENT_ROOT}/README.md

	echo "Refreshing README for global definitions"
	create_global_readme >${DEPLOYMENT_ROOT}/global/README
	for site in $(all_sites); do
		echo "  Refreshing README for site '${site}'"
		create_site_readme ${site} >${DEPLOYMENT_ROOT}/${site}/README
		for env in $(all_environments_for ${site}); do
			echo "    Refreshing README for environment '${site}/${env}'"
			create_environment_readme ${site} ${env} >${DEPLOYMENT_ROOT}/${site}/${env}/README
		done
	done
}

: <<'dox-command:deploy'
USAGE
@~include=usage

DESCRIPTION
	When run from inside of an environment directory, builds and deploys your
	BOSH manifest. A redacted copy is left in the repo for posterity. The copy
	deployed is non-redacted.

@~group=build
@~scope=make
dox-command:deploy
cmd_deploy() {
	[[ -z $1 ]] || bad_usage_no_args

	must_be_in_an_environment
	preflight_deployment

	case ${DEPLOYMENT_TYPE} in
	(normal)
		(VAULT_ADDR= REDACT=y cmd_build manifest.yml) || exit 3
		(            REDACT=  cmd_build .deploy.yml)  || exit 4
		[[ -n $DEBUG_LEAVE_THE_CREDS_THERE ]] || \
			trap "rm -f ${DEPLOYMENT_ENV_DIR}/manifests/.deploy.yml" QUIT TERM INT EXIT

		bosh -d ${DEPLOYMENT_ENV_DIR}/manifests/.deploy.yml deploy
		exit $?
		;;

	(bosh-init)
		(VAULT_ADDR= REDACT=y cmd_build manifest.yml) || exit 3
		(            REDACT=  cmd_build .deploy.yml)  || exit 4
		[[ -n $DEBUG_LEAVE_THE_CREDS_THERE ]] || \
			trap "rm -f ${DEPLOYMENT_ENV_DIR}/manifests/.deploy.yml" QUIT TERM INT EXIT

		if [[ ! -f "${DEPLOYMENT_ENV_DIR}/manifests/.deploy-state.json" ]]; then
			echo "No existing genesis-created bosh-init statefile detected. Please help genesis find it."
			read -e -p "Path to existing bosh-init statefile (leave blank for new deployments): " statefile
			while [[ -n "${statefile}" && ! -f "${statefile}" ]]; do
				echo "Invalid path."
				read -e -p "Path to existing bosh-init statefile (leave blank for new deployments): " statefile
			done
			if [[ -n "${statefile}" ]]; then
				mv "${statefile}" ${DEPLOYMENT_ENV_DIR}/manifests/.deploy-state.json
			fi
		fi

		bosh-init deploy ${DEPLOYMENT_ENV_DIR}/manifests/.deploy.yml
		exit $?
		;;
	esac
}

### CI SUPPORT FUNCTIONS

ci_smoke_test() {
	local smoke_test=$(spruce json $(ci_pipeline_yaml) | jq -r '.smoke_test')

	if [[ ${smoke_test} != 'null' ]]; then
		echo ${smoke_test}
	fi
}

ci_environment_type() {
	local site=${1:?ci_environment_type() - no site given}
	local env=${2:?ci_environment_type() - no environment given}

	local alpha=$(spruce json $(ci_pipeline_yaml) | jq -r ".alpha")
	if [[ "${site}/${env}" == $alpha ]]; then
		echo "alpha"
		return
	fi

	local beta=$(spruce json $(ci_pipeline_yaml) | jq -r ".sites[\"${site}\"].beta")
	if [[ "${env}" == $beta ]]; then
		echo "beta"
		return
	fi

	# otherwise, is it automatically updatable?
	local auto=$(spruce json $(ci_pipeline_yaml) | jq -r ".sites[\"${site}\"].auto[\"${env}\"] // \"\"")
	if [[ -n ${auto} ]]; then
		echo "gamma"
	else
		echo "omega"
	fi
}

ci_alpha_environment() {
	spruce json $(ci_pipeline_yaml) | jq -r ".alpha"
}

ci_beta_environment_for() {
	local site=${1:?ci_beta_environment_for() - no site given}
	local env=$(spruce json $(ci_pipeline_yaml) | jq -r ".sites[\"${site}\"].beta // \"\"")
	if [[ -n ${env} ]]; then
		echo "${site}/${env}"
	fi
}


ci_parent_environment_for() {
	local site=${1:?ci_parent_environment_for() - no site given}
	local env=${2:?ci_parent_environment_for() - no env given}
	local parent=$(spruce json $(ci_pipeline_yaml) | jq -r ".sites[\"${site}\"][\"${env}\"].parent // \"\"")

	if [[ -n ${parent} ]]; then
		echo "${site}/${parent}"
	else
		ci_beta_environment_for ${site}
	fi
}

ci_gamma_environments_for() {
	local site=${1:?ci_gamma_environments_for() - no site given}
	local beta=$(ci_beta_environment_for ${site})
	local alpha=$(ci_alpha_environment)
	for env in $(all_environments_for $site); do
		if [[ "${site}/${env}" == "${beta}" || "${site}/${env}" == "${alpha}" ]]; then
			continue
		fi
		local auto=$(spruce json $(ci_pipeline_yaml) | jq -r ".sites[\"${site}\"].auto[\"${env}\"] // \"\"")
		if [[ -n ${auto} ]]; then
			echo ${site}/${env}
		fi
	done
}

ci_name() {
	tr / - <<<"$1"
}

ci_check_configuration() {
	setup
	local rc=0

	mkdir -p ${DEPLOYMENT_ROOT}/ci
	if [[ ! -f ${DEPLOYMENT_ROOT}/ci/boshes.yml ]]; then
		cat >${DEPLOYMENT_ROOT}/ci/boshes.yml <<EOF
---
auth: (( param "Please define your BOSH directors in ci/boshes.yml (and remove this line)" ))
aliases:
  target: (( param "Please define aliases for your BOSH directors (uuid -> addr)" ))

# BOSH directors are specified by \`url: username / password\`
# (just like in ~/.bosh_config's auth section), i.e.:
#
#aliases:
#  target:
#    DIRECTOR-UUID: https://ip.ad.dr.ess:25555
#auth:
#  https://ip.ad.dr.ess:25555:
#    username: admin
#    password: (( vault "this/should/probably/be/in/vault" ))
#
EOF
	fi
	if [[ ! -f ${DEPLOYMENT_ROOT}/ci/settings.yml ]]; then
		cat >${DEPLOYMENT_ROOT}/ci/settings.yml <<EOF
--- {}
# This is where you will configure your Genesis CI deployment pipeline
# (everything goes under 'meta')
#
#meta:
#  # This is the name of your pipeline
#  name: $DEPLOYMENT_NAME
#
#  # This is the name of your fly target
#  target: proto
#
#  # A map of name:value environment variables
#  # that will be made available to the script
#  env:
#    VAULT_ADDR: https://va.ul.t.ip:8200
#  # VAULT_SKIP_VERIFY: 1
#
#  github:
#    owner: github-user
#    repo:  repository-name
#
#    private_key: |
#      ssh-private-key
#      (PEM-encoded)
#
#    # Optional branch to track for changes.
#    # (defaults to "master")
#    #branch: master
#
#  slack:
#    webhook: https://slack/web/hook/url
#    channel: '#name' # or '@user'
#
#    # Optional name/icon to use for posting the notification.
#    #username: runwaybot
#    #icon: http://ip.ad.dr.ess/of/icon.gif
#
EOF
	fi

	local alpha=""
	ensure_ci_configuration
	for site in $(all_pipeline_sites); do
		local beta=""
		local numenvs=0
		for env in $(all_environments_for ${site}); do
			local type="$(ci_environment_type ${site} ${env})"
			case ${type} in
			(alpha)
				if [[ -n "${alpha}" ]]; then
					echo >&2 "Multiple alpha environments detected: ${alpha} and ${site}/${env}"
					rc=1
				fi
				alpha="${site}/${env}"
				;;

			(beta)
				if [[ -n "${beta}" ]]; then
					echo >&2 "Multiple beta environments detected for ${site}: ${beta} and ${site}/${env}."
					rc=1
				fi
				beta="${site}/${env}"
				;;
			(*)
				numenvs=$(( numenvs + 1 ))
				;;
			esac
		done

		if [[ -z "${beta}" && $numenvs -gt 0 ]]; then
			echo >&2 "No beta environment found for ${site}."
			rc=1
		fi
	done

	if [[ -z "${alpha}" ]]; then
		echo >&2 "No alpha environment found."
		rc=1
	fi

	if [[ ${GENESIS_CI_ALLOW_TRACK} != "true" ]]; then
		for site in $(all_sites); do
			if [[ $(cat ${site}/site/stemcell/version) == "track" ]]; then
				echo >&2 "Stemcell for site '${site}' is set to version 'track'. If desired, set GENESIS_CI_ALLOW_TRACK=true to override."
				rc=1
			fi
		done

		pushd global/releases >/dev/null
			for release in *; do
				if [[ $(cat ${release}/version) == "track" ]]; then
					echo >&2 "Release '${release}' is set to version 'track'. If desired, set GENESIS_CI_ALLOW_TRACK=true to override."
					rc=1
				fi
			done
		popd > /dev/null
	fi

	if [[ $rc -ne 0 ]]; then
		echo >&2 "Configuration issues with CI found.  Please address the above."
		exit 1
	fi
}

ci_update() {
	# emulate:
	#   echo "some: change" | spruce merge -i $(ci_pipeline_yaml)

	ensure_ci_configuration

	need_a_workdir
	cat > ${WORKDIR}/update.yml
	ensure_yaml_file ${WORKDIR}/update.yml

	if spruce merge "$@" $(ci_pipeline_yaml) ${WORKDIR}/update.yml > ${WORKDIR}/.ci.yml; then
		mv ${WORKDIR}/.ci.yml $(ci_pipeline_yaml)
	fi
}

ci_pipeline_yaml() {
	if [[ -n ${CI_PIPELINE:-} ]]; then
		echo ${DEPLOYMENT_ROOT}/.ci.yml
	else
		echo ${DEPLOYMENT_ROOT}/.ci.${CI_PIPELINE}.yml
	fi
}


need_ci_git_access() {
	[ -z ${GIT_USERNAME} ] && GIT_USERNAME="Concourse Bot"
	[ -z ${GIT_EMAIL}    ] && GIT_EMAIL="concourse@$(hostname -f)"
	if [[ -z $(git config --global user.email) ]]; then
		git config --global user.email ${GIT_EMAIL}
	fi
	if [[ -z $(git config --global user.name) ]]; then
		git config --global user.name ${GIT_USERNAME}
	fi

	if [[ ! -f ~/.ssh/key && -n ${CI_PRIVATE_KEY} ]]; then
		mkdir -p ~/.ssh
		cat > ~/.ssh/key <<EOF
${CI_PRIVATE_KEY}
EOF
		chmod 0400 ~/.ssh/key
		eval $(ssh-agent) >/dev/null 2>&1
		trap "kill $SSH_AGENT_PID" 0

		cat >~/.ssh/askpass <<EOF
#!/bin/sh
echo "Looks like there is something wrong with your SSH private key (for accessing the repository)" >&2
exit 1
EOF
		chmod 0755 ~/.ssh/askpass
		SSH_ASKPASS=~/.ssh/askpass DISPLAY= ssh-add ~/.ssh/key >/dev/null
	fi

	if [[ ! -f ~/.ssh/config ]]; then
		mkdir -p ~/.ssh
		cat > ~/.ssh/config <<EOF
StrictHostKeyChecking no
LogLevel quiet
EOF
		chmod 0600 ~/.ssh/config
	fi
}

ci_commit() {
	local msg=${1:?ci_commit() - no commit message given}
	if [[ -n $(git status --porcelain) ]]; then
		need_ci_git_access
		git add -A
		git status
		git --no-pager diff --cached
		git commit -m "${msg}"
	fi
}

: <<'dox-concept:CI'
DESCRIPTION
  When making a change to a deployment, you want to make sure it causes the
  least impact and has the highest chance of catching an issue early.  Genesis
  provides an integrated CI/CD solution that is built on Concourse to ensure
  that changes to your deployments can propagate through your environments
  safely.

  Changes come to the manifest from the sources:  global changes that impact
  all deployments, site changes that only impact all environments in that site
  and changes that are isolated to a specific environment.

  Changes at the global level are called alpha changes.  These can be tested on
  a single isolated environment to ensure that they can be deployed with golden
  configuration for site and env.

  Changes at the site level are called beta changes.  They are applied on top
  of the last known-good alpha chagnes that passed.  One environment for the
  site is picked as a `beta environment` on which the deployment is tested.

  Environment changes need to be applied to the target environment, and will be
  applied over the known-good beta changes.

WORKFLOW
  The CI pipeline is created as follows:

                   .-------.
  global changes ->| alpha |--+--+--+
                   '-------'  |  |  |
      .-SITE-C----------------|--|--v---------------------------------------.
    .-SITE-B------------------|--v----------------------------------------. |
  .-SITE-A--------------------|-----------------------------------------. | |
  |                  .--------'                                         | | |
  |                  |  .---------.                                     | | |
  |                  '->| beta:   |---.                                 | | |
  | site changes ------>| SITE-A/ |-. |  .---------.        .---------. | | |
  | 'sandbox' changes ->| sandbox | | +->| notify: |- - - ->| manual: | | | |
  |                     '---------' +-|->| SITE-A/ |- - - ->| SITE-A/ | | | |
  | 'dev' changes ------------------|-|->| dev     |- - - ->| dev     | | | |
  |                                 | |  '---------'        '---------' | | |
  |                                 | |  .---------.        .---------. | | |
  |                                 | '->| auto    |---+--->| auto:   | | | |
  |                                 '--->| SITE-A/ |-+-|--->| SITE-A/ | | | |
  | 'qa' changes ----------------------->| qa      | | | .->| live    | | | |
  |                                      '---------' | | |  '---------' | | |
  | 'live' changes ----------------------------------|-|-'              | | |
  |                                 .----------------' |                | | |
  |                                 | .----------------'                | | |
  |                                 | |  .---------.        .---------. | | |
  |                                 ' '->| notify: |- - - ->| manual: | | | |
  |                                 '--->| SITE-A/ |- - - ->| SITE-A/ | | | |
  | 'prod' changes --------------------->| prod    |- - - ->| prod    | | |-'
  |                                      '---------'        '---------' |-'
  '---------------------------------------------------------------------'

  In the example pipeline above, there are three sites: SITE-A, SITE-B and
  SITE-C.  Let's walk through what happens:

	alpha
  * Any changes to /global will trigger a deployment on the alpha environment.
		A successful deployment will be used as a triggering input for the beta
		environments on each site.  We will focus on SITE-A, but all sites will
		operate the same way.

	beta:SITE-A/sandbox
	* A successful deployment on the alpha site will trigger a deployment on 
		beta: SITE-A/sandbox environment using the global changes that just passed
		and the last known good SITE-A site changes as well.

	* Any changes to SITE-A/site will also trigger a deployment on
		beta:SITE-A/sandbox, which will use the last passed global changes as well.

	* A change to the SITE-A/sandbox directory will also trigger a deployment on
		beta:SITE-A/sandbox environment using the last known good global and site
		changes.  However, a successful deployment will NOT trigger any downstream
		deployments.

	REMAINING ENVIRONMENTS

	The four remaining environments in SITE-A are dev, qa, live and prod.  They
	are configured as:
		qa:   'auto' environment.
		dev:  'manual' environment.
		live: 'auto' environment, with SITE-A/qa as parent.
		prod: 'manual' environment, with SITE-A/qa as parent.

	notify:SITE-A/dev + manual:SITE-A/dev
	* Because 'dev' is manual, the successful deployment of beta:SITE-A/sandbox
		does not trigger the deployment on SITE-A/dev.  Instead, it sends out a
		notification that SITE-A/dev is ready to be deployed.  This notification
		will instruct the receiver to visit the Concourse link for SITE-A/dev and
		click the (+) button, which will manually start the deployment.

	* A change to SITE-A/dev environment directory will also trigger a
		notification instead of starting the deployment.

	auto:SITE-A/qa
	* Because 'qa' is auto, a deployment will be triggered by a successful 
		deployment of beta/SITE-A/sandbox that was due to global or site changes.

	* Changes to SITE-A/qa directory will also trigger a deployment on 
		auto:SITE-A/qa, but its success will not trigger further downstream 
		deployments.

	auto:SITE-A/live
	* This operates similar to SITE-A/qa, but instead of being triggered by a
		successful deployment of beta:SITE-A/sandbox, it is triggered by a
		successful deployment of auto:SITE-A/qa (for site or global changes).

	notify:SITE-A/prod + manual:SITE-A/prod
	* Similar to SITE-A/dev in behaviour, except its notification istriggered on
		a successful deployment due to global or site changes on auto:SITE-A/qa

SEE ALSO
@~include=topic{"category":"command","desc":"inline","leader":"  ","partial":"ci"}
dox-concept:CI

: <<'dox-partial:ci'

beta
	Sets the role to beta.  Beta environments are run after alpha environments
	pass, or when site-specific changes are introduced.  You must have one beta
	environment for each site in your pipeline.

auto
	Set the role to auto.  Auto environments run automatically once the beta
	environment for the site passes.  You can have any number of auto
	environments.

manual
	Set the role to manual.  When the proceeding environment passes, a
	notification will be sent out that the enviroment can be run, with a link
	to the environment task in Concourse.  You can have any number of manual
	environments.

<site>/<env>
	You can optionally specify which environment it the target of this command
	by specifying the path of the environment.  If ommitted, the current
	environment is the target.
DESCRIPTION
  Manages the CI pipeline configurations.
dox-partial:ci

### CI API Commands

: <<'dox-command:ci-alpha'
USAGE
@~include=usage{"args":"[-p|--pipeline <name>] [<site>/<env>]"}

DESCRIPTION
	Sets the specified or current environment as the alpha enviroment in the
	specified or default pipeline.
	
ARGUMENTS
	-p|--pipeline <name>
		the name of the pipeline to be configured.  Defaults to the deployment name

	<site>/<env>
		This is the path to the environment relative to the deployment root
		directory.  If this command is issued within an environment directory, it
		defaults to the current directory; otherwise, it is required.

SEE ALSO:
@~include=related{"items":["concept:CI","command:ci-beta","command:ci-auto","command:ci-manual","command:ci-parent","command:ci-repipe","command:ci-flow"]}
@~scope=ci
dox-command:ci-alpha
cmd_ci_alpha() {
	local site_env

	while (( $# )); do
		arg=$1 ; shift
		case ${arg} in
		(-*) bad_usage_no_opts ;;
		(*)
			[[ -z ${site_env} ]] || bad_usage_extra "$arg" "<site>/<env>" "$site_env"
			site_env=${arg}
			;;
		esac
	done

	setup
	if [[ -z "${site_env}" ]]; then
		must_be_in_an_environment
		site_env="${DEPLOYMENT_SITE}/${DEPLOYMENT_ENVIRONMENT}"
	fi

	check_environment $site_env
	local site=${site_env%%/*}
	local env=${site_env##*/}
	ci_update <<EOF
---
alpha: ${site_env}
sites:
  ${site}:
    auto:
      ${env}: y
EOF
}

: <<'dox-command:ci-beta'
USAGE
@~include=usage{"args":"[-p|--pipeline <name>] [<site>/<env> [... <siteN>/<envN>]]"}

DESCRIPTION
	Sets the specified or current environment as the beta enviroment for its
	associated site in the specified or default pipeline.
	
ARGUMENTS
	-p|--pipeline <name>
		the name of the pipeline to be configured.  Defaults to the deployment name

	<site>/<env>
		This is the path to the environment relative to the deployment root
		directory.  If this command is issued within an environment directory, it
		defaults to the current directory; otherwise, it is required.

		You can specify 0 or more <site>/<env> pairs in a single call.

SEE ALSO:
@~include=related{"items":["concept:CI","command:ci-alpha","command:ci-auto","command:ci-manual","command:ci-parent","command:ci-repipe","command:ci-flow"]}
@~scope=ci
dox-command:ci-beta
cmd_ci_beta() {

	site_envs=()
	while (( $# )); do
		arg=$1 ; shift
		case ${arg} in
		(-*) bad_usage_no_opts ;;
		(*)  site_envs+=($arg) ;;
		esac
	done

	setup
	if [[ ${#site_envs} -eq 0 ]]; then
		must_be_in_an_environment
		site_envs+=("${DEPLOYMENT_SITE}/${DEPLOYMENT_ENVIRONMENT}")
	fi
	for site_env in "${site_envs[@]}"; do
		check_environment $site_env
		local site=${site_env%%/*}
		local env=${site_env#*/}
		ci_update <<EOF
---
sites:
  ${site}:
    beta: ${env}
    auto:
      ${env}: y
EOF
	done
}


: <<'dox-command:ci-auto'
USAGE
@~include=usage{"args":"[-p|--pipeline <name>] [<site>/<env> [... <siteN>/<envN>]]"}

DESCRIPTION
	Sets the specified or current environment as an automatically triggered
	enviroment within its associated site in the specified or default pipeline.
	
ARGUMENTS
	-p|--pipeline <name>
		the name of the pipeline to be configured.  Defaults to the deployment name

	<site>/<env>
		This is the path to the environment relative to the deployment root
		directory.  If this command is issued within an environment directory, it
		defaults to the current directory; otherwise, it is required.

		You can specify 0 or more <site>/<env> pairs in a single call.

SEE ALSO:
@~include=related{"items":["concept:CI","command:ci-alpha","command:ci-beta","command:ci-manual","command:ci-parent","command:ci-repipe","command:ci-flow"]}
@~scope=ci
dox-command:ci-auto
cmd_ci_auto() {
	site_envs=()
	while (( $# )); do
		arg=$1 ; shift
		case ${arg} in
		(-*) bad_usage_no_opts ;;
		(*)  site_envs+=($arg) ;;
		esac
	done

	setup
	if [[ ${#site_envs} -eq 0 ]]; then
		must_be_in_an_environment
		site_envs+=("${DEPLOYMENT_SITE}/${DEPLOYMENT_ENVIRONMENT}")
	fi
	for site_env in "${site_envs[@]}"; do
		check_environment $site_env
		local site=${site_env%%/*}
		local env=${site_env##*/}
		ci_update <<EOF
---
sites:
  ${site}:
    auto:
      ${env}: y
EOF
	done
}

: <<'dox-command:ci-manual'
USAGE
@~include=usage{"args":"[-p|--pipeline <name>] [<site>/<env> [... <siteN>/<envN>]]"}

DESCRIPTION
	Sets the specified or current environment as an manually triggered
	enviroment within its associated site in the specified or default pipeline.
	
ARGUMENTS
	-p|--pipeline <name>
		the name of the pipeline to be configured.  Defaults to the deployment name

	<site>/<env>
		This is the path to the environment relative to the deployment root
		directory.  If this command is issued within an environment directory, it
		defaults to the current directory; otherwise, it is required.

		You can specify 0 or more <site>/<env> pairs in a single call.

SEE ALSO:
@~include=related{"items":["concept:CI","command:ci-alpha","command:ci-beta","command:ci-auto","command:ci-parent","command:ci-repipe","command:ci-flow"]}
@~scope=ci
dox-command:ci-manual
cmd_ci_manual() {
	site_envs=()
	while (( $# )); do
		arg=$1 ; shift
		case ${arg} in
		(-*) bad_usage_no_opts ;;
		(*)  site_envs+=($arg) ;;
		esac
	done

	setup
	if [[ ${#site_envs} -eq 0 ]]; then
		must_be_in_an_environment
		site_envs+=("${DEPLOYMENT_SITE}/${DEPLOYMENT_ENVIRONMENT}")
	fi
	for site_env in "${site_envs[@]}"; do
		check_environment $site_env
		local site=${site_env%%/*}
		local env=${site_env##*/}
		case "$(ci_environment_type ${site} ${env})" in
		(alpha)
			cat >&2 <<EOF
${site}/${env} is currently the Alpha CI environment.

Alpha environments are automatically updated in response to changes made to global/,
new BOSH releases, stemcells, etc.

If you want to require manual approval for updates to ${site}/${env},
please first select a different Alpha environment.
EOF
			exit 2
			;;

		(beta)
			cat >&2 <<EOF
${site}/${env} is currently the Beta CI environment for ${site}.

Beta environments are automatically updated in response to changes made to global/,
${site}/site/, new BOSH releases, stemcells, etc.

If you want to require manual approval for updates to ${site}/${env},
please first select a different Beta environment for ${site}.
EOF
			exit 2
			;;
		esac
		ci_update --prune "sites[${site}].auto[${env}]" </dev/null
	done
}

: <<'dox-command:ci-parent'
USAGE
@~include=usage{"args":"[-p|--pipeline <name>] [<site>/<env>] <parent_env>"}

DESCRIPTION
	Sets the parent environment for specified or current environment in the
	specified or default pipeline.  If no parent is set, the beta environment
	for the site is assumed.
	
ARGUMENTS
	-p|--pipeline <name>
		the name of the pipeline to be configured.  Defaults to the deployment name

	<site>/<env>
		This is the path to the environment relative to the deployment root
		directory.  If this command is issued within an environment directory, it
		defaults to the current directory; otherwise, it is required.

SEE ALSO:
@~include=related{"items":["concept:CI","command:ci-alpha","command:ci-beta","command:ci-auto","command:ci-manual","command:ci-repipe","command:ci-flow"]}
@~scope=ci
dox-command:ci-parent
cmd_ci_parent() {
	local target parent_env
	while (( $# )); do
		arg=$1 ; shift
		case ${arg} in
		(-*) bad_usage_invalid_opt "$arg" ;;
		(*/*)
			[[ -z $target_site ]] || bad_usage_extra "$arg" "site/env" "$target_site/$target_env"
			target="${arg}"
			;;	
		(*)
			[[ -z $parent_env ]] || bad_usage_extra "$arg" "parent-env" $parent_env
			parent_env="${arg}"
			;;
		esac
	done

	setup
	local target_site=${target%%/*}
	local target_env=${target#*/}

	target_site=${target_site:-$DEPLOYMENT_SITE}
	target_env=${target_env:-$DEPLOYMENT_ENVIRONMENT}
	[[ -n $target_env ]] || bad_usage "<site>/<env> must be specified when not in an environment directory"

	# FIXME: need way to clear parent; currently passing in empty parent results
  #        in error
	check_environment ${target}
	check_environment "${target_site}/${parent_env}"

	# FIXME: would be better if it was "parent" => {<target_env> => <parent_env>}
	#        but that would require fixing other bits of code and existing files.
	ci_update <<EOF
---
sites:
	${target_site}:
		${target_env}:
			parent: ${parent_env}
EOF
}
: <<'dox-command:ci-smoke-test'
USAGE
@~include=usage{"args":"[-p|--pipeline <name>] <errand>"}

DESCRIPTION
	Sets the smoke test errand for the specified or default pipeline.
	
ARGUMENTS
	-p|--pipeline <name>
		the name of the pipeline to be configured.  Defaults to the deployment name

	<errand>
		This is the name of the errand to run as a smoke test.

SEE ALSO:
@~include=related{"items":["concept:CI","command:ci-repipe","command:ci-flow"]}
@~scope=ci
dox-command:ci-smoke-test

cmd_ci_smoke_test() {
	local errand_name=${1}
	while (( $# )); do
		arg=$1 ; shift
		case ${arg} in
		(-*) bad_usage_invalid_opt "$arg" ;;
		(*)
			[[ -z $errand_name ]] || bad_usage_extra "$arg" "errand" "$errand_name"
			errand_name="${arg}"
			;;
		esac
	done
	[[ -z ${errand_name} ]] && bad_usage_missing 'errand'

	setup
	ci_update <<EOF
---
smoke_test: ${errand_name}
EOF
}

ci_repipe_proto_job() {
	local job_name=${1:?ci_repipe_proto_job() - no job name given}

	cat <<EOF
jobs:
  - name: ${job_name}
    public: true
    serial: true
    plan:
      - aggregate:
          - get: world-changes
            resource: (( param "looks like genesis forgot to override the resource name" ))
          - get: local-changes
            resource: (( param "looks like genesis forgot to override the resource name" ))
      - task: (( param "looks like genesis forgot to override the task name" ))
        config:
          platform: linux
          image_resource:
            type: docker-image
            source:
              repository: starkandwayne/concourse
              tag: latest
          inputs:
            - name: world-changes
            - name: local-changes
          outputs:
            - name: out
          run:
            path: world-changes/bin/genesis
            args: [ci, stage1]
          params:
            .: (( inject meta.env ))

            CI_VAULT_APP_ID:   concourse
            CI_VAULT_USER_ID:  (( concat meta.name "-pipeline" ))

            CI_SITE_ENV:    (( param "looks like genesis forgot to override the CI_SITE_ENV variable" ))
            CI_BRANCH:      (( grab resources.git.source.branch ))
            CI_PRIVATE_KEY: (( grab resources.git.source.private_key ))

            LOCAL_CHANGES:  local-changes
            WORLD_CHANGES:  world-changes
            WORKING_DIR:    out/git

            CI_BOSHES: |
EOF
	need_a_vault
	spruce merge ${DEPLOYMENT_ROOT}/ci/boshes.yml | sed -e 's/^/              /' || exit $?
}

ci_repipe_smoke_test() {
	local job_name=${1:?ci_repipe_smoke_test() - no job name given}
	local errand_name=${2:?ci_repipe_smoke_test() - no errand name given}

	cat <<EOF
jobs:
  - name: ${job_name}
    plan:
      - (( append ))
      - task: smoke-test
        config:
          platform: linux
          image_resource:
            type: docker-image
            source:
              repository: starkandwayne/concourse
              tag: latest
          inputs: [{name: out}]
          run:
            path: out/git/bin/genesis
            args: [ci, stage-smoke-test]
          params:
            .: (( inject meta.env ))

            WORKING_DIR: out/git
            CI_SITE_ENV: ${site_env}
            ERRAND_NAME: ${errand_name}
            CI_VAULT_APP_ID:   concourse
            CI_VAULT_USER_ID:  (( concat meta.name "-pipeline" ))
            CI_BOSHES: |
EOF
	need_a_vault
	spruce merge ${DEPLOYMENT_ROOT}/ci/boshes.yml | sed -e 's/^/              /' || exit $?
}


ci_repipe_build_base() {
	need_a_workdir

	cat >${WORKDIR}/pipeline.yml <<EOF
---
meta:
  name: (( param "Please name this deployment pipeline (in ci/settings.yml)" ))
  env: {}

  github:
    uri:          (( concat "git@github.com:" meta.github.owner "/" meta.github.repo ))
    owner:        (( param "Please specify the name of the user / organization that owns the Github repository (in ci/settings.yml)" ))
    repo:         (( param "Please specify the name of the Github repository (in ci/settings.yml)" ))
    branch:       master
    private_key:  (( param "Please generate an SSH Deployment Key for this repo and specify it in ci/settings.yml" ))

  slack:
    webhook:  (( param "Please provide a Slack Integration WebHook (in ci/settings.yml)" ))
    channel:  (( param "Please specify the channel (#name) or user (@user) to send messages to (in ci/settings.yml)" ))
    username: runwaybot
    icon:     http://cl.ly/image/3e1h0H3H2s0P/concourse-logo.png

resources:
  - name: git
    type: git
    source:
      uri:         (( grab meta.github.uri ))
      branch:      (( grab meta.github.branch ))
      private_key: (( grab meta.github.private_key ))

  - name: notification
    type: slack-notification
    source:
      url:      (( grab meta.slack.webhook ))



resource_types:
  - name: slack-notification
    type: docker-image
    source:
      repository: cfcommunity/slack-notification-resource

groups:
  - name: '*'
    jobs:
      - stemcells

  - name: upkeep
    jobs:
      - stemcells

jobs:
  - name: stemcells
    public: true
    serial: true
    plan:
      - aggregate:
        - get: git
      - task: update
        config:
          inputs:
            - name: git
          outputs:
            - name: out
          platform: linux
          image_resource:
            type: docker-image
            source:
              repository: starkandwayne/concourse
          run:
            path: git/bin/genesis
            args: [ ci, stemcells ]
          params:
            STEMCELLS: stemcells
            REPO_OUT:  out/git
      - put: git
        params:
          rebase: true
          repository: out/git
EOF
}

ci_repipe_build_environments() {
	local alpha_env=$(ci_alpha_environment)
	local alpha_name=$(ci_name ${alpha_env})
	local alpha_site=${alpha_env%%/*}

	need_a_workdir
	workdir="${WORKDIR}/repipe"
	mkdir -p ${workdir}
	cat <<EOF >${workdir}/09-all.yml
---
groups:
  - name: '*'
    jobs:
      - (( append ))
EOF
	cat <<EOF >${workdir}/08-groups.yml
---
groups:
  - name: '*'
  - name: α
    jobs:
      - $alpha_name

  - name: β
    jobs:
      - $alpha_name
EOF

	local rc=0
	for site in $(all_pipeline_sites); do
		if [[ ! -f ${DEPLOYMENT_ROOT}/${site}/site/stemcell/name ]]; then
			echo >&2 "Site ${site} has no defined stemcell"
			rc=1
		fi
	done
	if [[ $rc -ne 0 ]]; then
		exit $rc
	fi


	for site in $(all_pipeline_sites); do
		local site_name=$(ci_name ${site})
		local beta_env=$(ci_beta_environment_for ${site})
		local beta_name=$(ci_name ${beta_env})

		if [[ -n ${beta_name} ]]; then
			echo "      - ${beta_name}" >> ${workdir}/08-groups.yml
		fi

		local stemcell_alias=
		local stemcell_name=$(cat ${DEPLOYMENT_ROOT}/${site}/site/stemcell/name 2>/dev/null)
		case $stemcell_name in
		(*vsphere*) stemcell_alias=vsphere-stemcell ;;
		(*aws*hvm*) stemcell_alias=aws-hvm-stemcell ;;
		(*aws*)     stemcell_alias=aws-stemcell     ;;
		(*warden*)  stemcell_alias=warden-stemcell  ;;
		("")        stemcell_alias=empty            ;;
		(*)         stemcell_alias=${stemcell_name} ;;
		esac
		cat >${workdir}/77-${stemcell_alias}.yml <<EOF
---
resources:
  - name: ${stemcell_alias}
    type: bosh-io-stemcell
    source: { name: ${stemcell_name} }

jobs:
  - name: stemcells
    plan:
      - (( inline ))
      - aggregate:
        - (( append ))
        - get: ${stemcell_alias}
          trigger: true
          params: { tarball: true }
      - task: update
        config:
          inputs:
            - (( append ))
            - name: ${stemcell_alias}
              path: stemcells/${stemcell_name}
EOF

		if [[ -n ${beta_name} ]]; then
			cat >${workdir}/10-${site}.yml <<EOF
---
groups:
  - name: $site_name
    jobs:
      - $alpha_name # alpha
      - $beta_name  # beta
EOF
		fi

		local smoke_test=$(ci_smoke_test)

		for env in $(all_environments_for ${site}); do
			local env_type=$(ci_environment_type ${site} ${env})
			local env_name=$(ci_name ${env})
			local site_env=${site}/${env}
			local site_env_name=$(ci_name ${site_env})
			local parent_env=$(ci_parent_environment_for ${site} ${env})
			local parent_env_name=$(ci_name ${parent_env})

			cat >>${workdir}/09-all.yml <<EOF
      - $site_env_name
EOF

			if [[ -n ${smoke_test} ]]; then
				ci_repipe_smoke_test ${site_env_name} ${smoke_test} > ${workdir}/59-${site_env_name}.yml
			fi

			ci_repipe_proto_job ${site_env_name} > ${workdir}/50-${site_env_name}.yml || exit 5
			case ${env_type} in
			(alpha)
				cat >${workdir}/51-${site_env_name}.yml <<EOF
---
resources:
  # changes that trigger the alpha environment

  ##########################################################################
  #
  #   global-changes      Changes made to the global/ definitions,
  #                       (and the alpha environment's site, for continuity)
  #
  - name: global-changes
    .: (( inject resources.git ))
    source:
      paths:
        - bin/genesis
        - global

  ##########################################################################
  #
  #   {env}-changes     Changes that only affect the current environment
  #                     (i.e. property changes, re-IPing, creds, etc.)
  #
  - name: ${alpha_name}-changes
    .: (( inject resources.git ))
    source:
      paths:
        - ${alpha_site}/site
        - ${alpha_env}/*.yml

  ##########################################################################
  #
  #   α-changes         Changes that come from previous steps in the
  #                     pipeline, from a successful build in alpha.
  #                     (this will trigger beta builds)
  #
  - name: α-changes
    .: (( inject resources.git ))
    source:
      paths:
        - ${alpha_env}/.global

jobs:
  # alpha environment
  - name: ${site_env_name}
    plan:
      - (( inline ))
      - aggregate:
        - (( merge on get ))

        - get: world-changes
          resource: global-changes
          trigger: true

        - get: local-changes
          resource: ${alpha_name}-changes
          trigger: true

      - task: ${site_env_name}
        config:
          params:
            CI_SITE_ENV: ${site_env}
        # PUT to the beta inputs
      - put: α-changes
        params: { repository: out/git, rebase: true }
EOF
				;;

			(beta)
				cat >${workdir}/51-${site_env_name}.yml <<EOF
---
resources:
  # changes that trigger the beta environment

  ##########################################################################
  #
  #   {site}-changes    Changes that only affect the current environment
  #                     (i.e. property changes, re-IPing, creds, etc.)
  #
  - name: ${site}-changes
    .: (( inject resources.git ))
    source:
      paths:
        - ${site}/site
        - ${beta_env}/*.yml

  ##########################################################################
  #
  #   {site}-β-changes  Changes that come from previous steps in the
  #                     pipeline, from a successful build in alpha.
  #
  - name: ${site}-β-changes
    .: (( inject resources.git ))
    source:
      paths:
        - ${beta_env}/.site
        - ${beta_env}/.global

jobs:
  # beta environment
  - name: ${site_env_name}
    plan:
      - (( inline ))
      - aggregate:
        - (( merge on get ))

        - get: world-changes
          resource: α-changes
          trigger: true
          passed: [${alpha_name}]

        - get: local-changes
          resource: ${site}-changes
          trigger: true

      - task: ${site_env_name}
        config:
          params:
            CI_SITE_ENV: ${site_env}
        # PUT to the gamma inputs
      - put: ${site}-β-changes
        params: { repository: out/git, rebase: true }
EOF
				;;

			(gamma)
				cat >>${workdir}/10-${site}.yml <<EOF
      - $site_env_name # gamma
EOF
				cat >${workdir}/51-${site_env_name}.yml <<EOF
---
resources:
  # changes that trigger the gamma environment

  ##########################################################################
  #
  #   {env}-changes     Changes that only affect the current environment
  #                     (i.e. property changes, re-IPing, creds, etc.)
  #
  - name: ${site_env_name}-changes
    .: (( inject resources.git ))
    source:
      paths:
        - ${site_env}/*.yml

jobs:
  # gamma environment
  - name: ${site_env_name}
    plan:
      - (( inline ))
      - aggregate:
        - (( merge on get ))

        - get: world-changes
          resource: ${site}-β-changes
          trigger: true
          passed: [${parent_env_name}]

        - get: local-changes
          resource: ${site_env_name}-changes
          trigger: true

      - task: ${site_env_name}
        config:
          params:
            CI_SITE_ENV: ${site_env}
        # PUT to git
      - put: git
        params: { repository: out/git, rebase: true }
EOF
				;;

			(omega)
				cat >>${workdir}/09-all.yml <<EOF
      - ${site_env_name}-notif
EOF
				cat >>${workdir}/10-${site}.yml <<EOF
      - $site_env_name # omega
      - ${site_env_name}-notif
EOF
				cat >${workdir}/51-${site_env_name}.yml <<EOF
---
resources:
  # changes that trigger the omega environment

  ##########################################################################
  #
  #   {env}-changes     Changes that only affect the current environment
  #                     (i.e. property changes, re-IPing, creds, etc.)
  #
  - name: ${site_env_name}-changes
    .: (( inject resources.git ))
    source:
      paths:
        - ${site_env}/*.yml

jobs:
  # omega environment
  - name: ${site_env_name}-notif
    plan:
      - aggregate:
        - get: world-changes
          resource: ${site}-β-changes
          passed: [${parent_env_name}]
          trigger: true

        - get: local-changes
          resource: ${site_env_name}-changes
          trigger: true

      - task: draft-message
        config:
          platform: linux
          image_resource:
            type: docker-image
            source:
              repository: starkandwayne/concourse
              tag: latest
          inputs:
            - name: world-changes
            - name: local-changes
          outputs:
            - name: out
          run:
            path: world-changes/bin/genesis
            args: [ci, draft-message]
          params:
            LOCAL_CHANGES:  local-changes
            WORLD_CHANGES:  world-changes
            CI_SITE_ENV:    ${site_env}
            DRAFT_FILE:     out/notif
      - put: notification
        params:
          text_file: out/notif
          username: (( grab meta.slack.username ))
          channel:  (( grab meta.slack.channel ))
          icon_url: (( grab meta.slack.icon ))

  - name: ${site_env_name}
    plan:
      - (( inline ))
      - aggregate:
        - (( merge on get ))

        - get: world-changes
          resource: ${site}-β-changes
          passed: [${site_env_name}-notif]
          trigger: false

        - get: local-changes
          resource: ${site_env_name}-changes
          passed: [${site_env_name}-notif]
          trigger: false

      - task: ${site_env_name}
        config:
          params:
            CI_SITE_ENV: ${site_env}
        # PUT to git
      - put: git
        params: { repository: out/git, rebase: true }
EOF
				;;
			esac
		done
	done
}

ci_repipe_merge() {
	target=${1:-pipeline.yml}
	mkdir -p ${DEPLOYMENT_ROOT}/ci

	need_command spruce
	spruce $SPRUCE_OPTS merge --prune meta \
	       ${WORKDIR}/pipeline.yml \
	       ${WORKDIR}/repipe/*.yml \
	       $(actual_yaml_files ${DEPLOYMENT_ROOT}/ci/settings.yml) > ${DEPLOYMENT_ROOT}/ci/${target}
}

: <<'dox-command:ci-repipe'
USAGE
@~include=usage{"args":"[-p|--pipeline <name>] [-d|--draft]"}

DESCRIPTION
  Generate the given or default CI pipeline and push it to Concourse.

ARGUMENTS
	-p|--pipeline <name>
		the name of the pipeline to be configured.  Defaults to the deployment name

  -d|--draft
		Don't push the pipeline, instead output it to STDOUT

SEE ALSO
@~include=related{"items":["concept:CI","command:ci-alpha","command:ci-beta","command:ci-auto","command:ci-manual","command:ci-parent","command:ci-flow"]}
@~scope=ci
dox-command:ci-repipe
cmd_ci_repipe() {

  local draft=""
	while (( $# )); do
		arg=$1 ; shift
		case ${arg} in
		(-d|--draft) draft=1 ;;
		(-*)         bad_usage_invalid_opt "$arg" ;;
		(*)          bad_usage_extra       "$arg" ;;
		esac
	done

	setup
	ci_check_configuration
	need_a_workdir
	need_a_vault

	ci_repipe_build_base
	VAULT_ADDR= REDACT=y ci_repipe_build_environments || exit 2
	VAULT_ADDR= REDACT=y ci_repipe_merge pipeline.yml || exit 3

	            REDACT=  ci_repipe_build_environments || exit 4
	            REDACT=  ci_repipe_merge .deploy.yml  || exit 5
	[[ -n $DEBUG_LEAVE_THE_CREDS_THERE ]] || \
		trap "rm -f ${DEPLOYMENT_ROOT}/ci/.deploy.yml" QUIT TERM INT EXIT

	CI_TARGET_NAME=$(spruce json ${DEPLOYMENT_ROOT}/ci/settings.yml | jq -r '.meta.target // ""')
	CI_PIPELINE=$(   spruce json ${DEPLOYMENT_ROOT}/ci/settings.yml | jq -r '.meta.name // ""')

	echo
	if [[ -z $draft ]] ; then
		echo "Configuring pipeline at ${CI_TARGET_NAME} (${CI_TARGET_URL})"
		fly -t ${CI_TARGET_NAME:-concourse} set-pipeline -p ${CI_PIPELINE:-pipeline} -c ${DEPLOYMENT_ROOT}/ci/.deploy.yml
		exit $?
	else
		cat "${DEPLOYMENT_ROOT}/ci/.deploy.yml"
	fi
}


: <<'dox-command:ci-flow'
USAGE
@~include=usage{"args":"[-p|--pipeline <name>] [-d|--draft]"}

DESCRIPTION
	Generate the given or default CI pipeline and push it to Concourse.

ARGUMENTS
	-p|--pipeline <name>
		the name of the pipeline to be configured.  Defaults to the deployment name

SEE ALSO
@~include=related{"items":["concept:CI","command:ci-alpha","command:ci-beta","command:ci-auto","command:ci-manual","command:ci-parent","command:ci-repipe"]}
@~scope=ci
dox-command:ci-flow
cmd_ci_flow() {
	[[ -z $1 ]] || bad_usage

	setup
	# FIXME: ascii diagram!
	cat $(ci_pipeline_yaml)
}

# Commands that are used by Concourse pipelines themselves

cmd_ci_stemcells() {
	[[ -z $1 ]] || bad_usage "ci stemcells"

	if [[ -z ${STEMCELLS} ]]; then
		echo >&2 "!! ERROR: Your Concourse Pipeline seems to be MISCONFIGURED !!"
		echo >&2
		echo >&2 "The \$STEMCELLS environment variable was not set."
		echo >&2
		echo >&2 "This environment variable tells genesis where to find the"
		echo >&2 "downloaded stemcells, for checksumming and version querying."
		exit 2
	fi
	if [[ ! -d ${STEMCELLS} ]]; then
		echo >&2 "!! ERROR: Your Concourse Pipeline seems to be MISCONFIGURED !!"
		echo >&2
		echo >&2 "The \$STEMCELLS environment variable seems to be incorrect."
		echo >&2
		echo >&2 "Failed to find stemcell path '${STEMCELLS}',"
		echo >&2 "starting from '$(pwd)'..."
		exit 2
	fi

	REPO_IN=$(cd $(dirname $BASH_SOURCE[0])/..; pwd)
	for dir in ${STEMCELLS}/*; do
		local name=${dir##*/}
		local vers=$(cat ${dir}/version)
		local sha1=$(cat ${dir}/stemcell.tgz | sha1sum | awk '{print $1}')
		local url=$(cat ${dir}/url)

		pushd ${REPO_IN} >/dev/null
			for site in */site; do
				if [[ $(cat ${site}/stemcell/name 2>/dev/null) == ${name} ]]; then
					echo ${vers} > ${site}/stemcell/version
					echo ${sha1} > ${site}/stemcell/sha1
					echo ${url} > ${site}/stemcell/url
				fi
			done
		popd >/dev/null
	done

	pushd ${REPO_IN} >/dev/null
		ci_commit "upgrade stemcells via pipeline"
	popd >/dev/null
	[ -n ${REPO_OUT} ] && cp -a ${REPO_IN} ${REPO_OUT}/
	exit 0
}

cmd_ci_stage1() {
	[[ -z $1 ]] || bad_usage "ci stage1"

	if [[ -z ${WORKING_DIR} ]]; then
		echo >&2 "!! ERROR: Your Concourse Pipeline seems to be MISCONFIGURED !!"
		echo >&2
		echo >&2 "The \$WORKING_DIR environment variable was not set."
		echo >&2
		echo >&2 "This environment variable tells genesis where to find the"
		echo >&2 "committed changes to this deployment manifest, so that Concourse"
		echo >&2 "can push the updatees back to origin properly."
		exit 2
	fi

	cp -a ${LOCAL_CHANGES} ${WORKING_DIR}
	if [[ ! -d ${WORKING_DIR} ]]; then
		echo >&2 "Failed to copy the git working copy from"
		echo >&2 "${LOCAL_CHANGES}"
		echo >&2 "to"
		echo >&2 "${WORKING_DIR}"
		echo >&2
		exit 2
	fi

	line
	echo "Pulling in latest copy of ${CI_BRANCH}"
	echo "(this avoids spurious git conflicts later)"
	echo
	pushd ${WORKING_DIR}/${CI_SITE_ENV} >/dev/null
		need_ci_git_access
		git pull origin ${CI_BRANCH} # in case we want to test...
	popd

	line
	echo "Invoking stage2 of the Genesis CI pipeline"
	echo
	exec ${WORKING_DIR}/bin/genesis ci stage2
}

cmd_ci_stage2() {
	[[ -z $1 ]] || bad_usage "ci stage2"

	line
	echo "Setting up .bosh_config with values from ci/boshes.yml"
	echo
	cat >~/.bosh_config<<EOF
${CI_BOSHES}
EOF
	ls -l ~/.bosh_config
	echo

	local target=$(spruce json ${WORKING_DIR}/${CI_SITE_ENV}/director.yml | jq -r '.director_uuid')
	line
	echo "Targeting BOSH director ${target}"
	echo
	bosh target ${target}

	if [[ $? != 0 ]]; then
		echo "Could not target BOSH director"
		exit 1
	fi

	line
	echo "Probing environment for information..."
	# figure out our environment type
	pushd ${WORKING_DIR}/${CI_SITE_ENV} >/dev/null
		CI_SITE=$(setup; must_be_in_an_environment; echo $DEPLOYMENT_SITE)
		CI_ENV=$( setup; must_be_in_an_environment; echo $DEPLOYMENT_ENVIRONMENT)

		local env_type=$(setup; must_be_in_an_environment;
			ci_environment_type ${DEPLOYMENT_SITE} ${DEPLOYMENT_ENVIRONMENT})

		local alpha_env=$(setup; must_be_in_an_environment;
			ci_alpha_environment)

		local beta_env=$(setup; must_be_in_an_environment;
			ci_beta_environment_for ${CI_SITE})
	popd
	echo "        CI_SITE_ENV: ${CI_SITE_ENV}"
	echo "            CI_SITE: ${CI_SITE}"
	echo "             CI_ENV: ${CI_ENV}"
	echo "   Environment Type: ${env_type}"
	echo "  Alpha Environment: ${alpha_env}"
	echo "   Beta Environment: ${beta_env}"
	echo

	line
	echo "Updating .site and .global copies from known good values"

	rm -rf ${WORKING_DIR}/${CI_SITE_ENV}/.global
	rm -rf ${WORKING_DIR}/${CI_SITE_ENV}/.site
	case ${env_type} in
	(alpha)
		echo "... in ALPHA environment"
		echo
		echo "copy world/global -> ${CI_SITE_ENV}/.global"
		echo "copy local/${CI_SITE}/site -> ${CI_SITE_ENV}/.site"
		echo
		cp -a ${WORLD_CHANGES}/global                ${WORKING_DIR}/${CI_SITE_ENV}/.global
		cp -a ${LOCAL_CHANGES}/${CI_SITE}/site       ${WORKING_DIR}/${CI_SITE_ENV}/.site
		;;
	(beta)
		echo "... in BETA environment"
		echo
		echo "copy world/${alpha_env}/.global -> ${CI_SITE_ENV}/.global"
		echo "copy world/${CI_SITE}/site -> ${CI_SITE_ENV}/.site"
		echo
		cp -a ${WORLD_CHANGES}/${alpha_env}/.global  ${WORKING_DIR}/${CI_SITE_ENV}/.global
		cp -a ${LOCAL_CHANGES}/${CI_SITE}/site       ${WORKING_DIR}/${CI_SITE_ENV}/.site
		;;
	(*)
		echo
		echo "copy world/${beta_env}/.global -> ${CI_SITE_ENV}/.global"
		echo "copy world/${beta_env}/.site -> ${CI_SITE_ENV}/.site"
		cp -a ${WORLD_CHANGES}/${beta_env}/.global   ${WORKING_DIR}/${CI_SITE_ENV}/.global
		cp -a ${WORLD_CHANGES}/${beta_env}/.site     ${WORKING_DIR}/${CI_SITE_ENV}/.site
		;;
	esac

	pushd ${WORKING_DIR}/${CI_SITE_ENV} >/dev/null
		setup
		must_be_in_an_environment

		line
		echo "Generating manifest (live.yml)..."
		echo
		set -e
		need_a_vault
		preflight_deployment
		(VAULT_ADDR= REDACT=y cmd_build live.yml)    || exit 3
		(            REDACT=  cmd_build .deploy.yml) || exit 4

		local target=$(spruce json ${DEPLOYMENT_ENV_DIR}/manifests/live.yml | jq -r '.director_uuid')
		line
		echo "Deploying to BOSH director ${target}"
		echo
		bosh target ${target}
		bosh deployment ${DEPLOYMENT_ENV_DIR}/manifests/.deploy.yml
		bosh -n deploy

		line
		echo "Committing changes to git repository..."
		echo
		if [[ -z ${GIT_MESSAGE} ]]; then
			GIT_MESSAGE="[${CI_SITE_ENV}] deployed via pipeline"
		fi
		ci_commit "${GIT_MESSAGE}"
		set +e
	popd >/dev/null

	line
	echo "COMPLETE"

	exit 0
}

cmd_ci_stage_smoke_test() {
	if [[ -z ${WORKING_DIR} ]]; then
		echo >&2 "!! ERROR: Your Concourse Pipeline seems to be MISCONFIGURED !!"
		echo >&2
		echo >&2 "The \$WORKING_DIR environment variable was not set."
		exit 2
	fi

	echo "Setting up .bosh_config with values from ci/boshes.yml"
	echo
	cat >~/.bosh_config<<EOF
${CI_BOSHES}
EOF
	ls -l ~/.bosh_config
	echo

	local target=$(spruce json ${WORKING_DIR}/${CI_SITE_ENV}/director.yml | jq -r '.director_uuid')
	line
	echo "Targeting BOSH director ${target}"
	echo
	bosh target ${target}

	line
	pushd ${WORKING_DIR}/${CI_SITE_ENV} >/dev/null
		setup
		must_be_in_an_environment

		line
		echo "Generating manifest (live.yml)..."
		echo
		set -e
		need_a_vault
		preflight_deployment
		(VAULT_ADDR= REDACT=y cmd_build live.yml)    || exit 3
		(            REDACT=  cmd_build .deploy.yml) || exit 4

		local target=$(spruce json ${DEPLOYMENT_ENV_DIR}/manifests/live.yml | jq -r '.director_uuid')
		line
		echo "Running Errand ${ERRAND_NAME} on BOSH director ${target}"
		echo
		bosh target ${target}
		bosh deployment ${DEPLOYMENT_ENV_DIR}/manifests/.deploy.yml
		bosh -n run errand ${ERRAND_NAME}
		set +e
	popd >/dev/null
}

cmd_ci_draft_message() {
	[[ -z $1 ]] || bad_usage "ci draft-message"

	(
		echo "[${CI_SITE_ENV}] Deployment changes are ready to go!"
		echo
		echo "World:"
		echo "\`\`\`"
		(cd $WORLD_CHANGES && git log -n1)
		echo "\`\`\`"
		echo
		echo "Local:"
		echo "\`\`\`"
		(cd $LOCAL_CHANGES && git log -n1)
		echo "\`\`\`"
	)>${DRAFT_FILE}
}

cmd_ci_check() {
	[[ -z $1 ]] || bad_usage "ci check"

	ci_check_configuration
}

bad_ci() {
	local cmd=${1}
	cat >&2 <<EOF
USAGE:  genesis ci [-p pipeline] alpha [site/env]
        genesis ci [-p pipeline] beta [site/env [site/env ...]]
        genesis ci [-p pipeline] auto [site/env [site/env ...]]
        genesis ci [-p pipeline] manual [site/env [site/env ...]]
        genesis ci [-p pipeline] smoke-test <errand>
        genesis ci [-p pipeline] repipe
        genesis ci [-p pipeline] flow
        genesis ci [-p pipeline] check
EOF
	exit 1
}

: <<'dox-command:bosh'
USAGE
	<<SCRIPT_NAME>> bosh <args...>

DESCRIPTION
	Run a bosh command against a freshly generated non-redacted BOSH manifest
	from the current environment directory.  

	For configurations that don't make use of Vault, this is equivalent of
	building the manifest and adding '-d manifests/manifests.yml' to the BOSH
	command.  When vault operators are present in the source yml files, this is
	the only way run BOSH command using a manifest since the one built in the
	manifests directory will have all vault values redacted.

	Similarly, it provides an alternative method for running `make deploy` with
	further arguments, such as --recreate.

	All BOSH commands are available, but may not necessarily benefit from the
	manifest re-generation step.

ARGUMENTS
	The arguments expected for this command are exactly what you'd specify for a
	normal bosh CLI command, less the -d option which this adds for you.  See 
	`bosh help <command>` for help on the desired bosh command.

EXAMPLES
  Rebuild the worker/1 job:
  $ genesis bosh -t prod recreate worker 1

  SSH into etcd/0 instance
  $ genesis bosh ssh etcd/0

  Dry-run of a deploy while showing all changes:
  $ genesis bosh deploy --dry-run --no-redact

SEE ALSO
@~include=related{"items":["concept:Makefiles","concept:Vault-Secrets"]}
dox-command:bosh
cmd_bosh() {
	# NOTE: cmd_bosh specifically avoids argv inspection
	must_be_in_an_environment

	case ${DEPLOYMENT_TYPE} in
	(normal)
		skip_preflight
		(REDACT= cmd_build .deploy.yml) || exit 3
		[[ -n $DEBUG_LEAVE_THE_CREDS_THERE ]] || \
			trap "rm -f ${DEPLOYMENT_ENV_DIR}/manifests/.deploy.yml" QUIT TERM INT EXIT

		bosh -d ${DEPLOYMENT_ENV_DIR}/manifests/.deploy.yml $@
		exit $?
		;;

	(bosh-init)
		echo >&2 "BOSH-init deployments do not currently support the \`bosh' command"
		exit 1
		;;
	esac
}

cmd_dump() {
	[[ -z $1 ]] || bad_usage "dump"

	setup
	printf "name: %s\n" ${DEPLOYMENT_NAME}
	printf "type: %s\n" ${DEPLOYMENT_TYPE}
	printf "root: %s\n" ${DEPLOYMENT_ROOT}
	printf "site: %s\n" ${DEPLOYMENT_SITE}
	printf "env:  %s\n" ${DEPLOYMENT_ENVIRONMENT}
	exit 0
}

checksum() {
	if [[ -z $(command -v sha1sum) ]]; then
		shasum "$@"
	else
		sha1sum "$@"
	fi
}

: <<'dox-command:help'
NAME
	help - Display help on genesis concepts and commands

USAGE
@~include=usage{"args":[" ","--topics","--<category>","[--<category>] <topic>"]}

DESCRIPTION
	Get help on how to use `genesis`.

	With no arguments, will print this help message.  By specifying a category,
	the list of topics in that category will be specified.  The available
	categories are:
@~include=categories{"leader":"    * "}

  You can also specify --topics to get a list of all topics in all categories.

	For detailed help on a given topic, you can specify that topic as an argument
	to the help command.  For topics that are composed of multiple words, do
	*not* wrap the topic in quotes.  In the rare case that the topic appears in
	multiple categories, you can specify the category type as an double-hyphenated
	option.
dox-command:help

cmd_help() {
	local category=""
	local topic=""
	while (( $# )); do
		arg="$1"; shift
		case "${arg}" in
		(*-) bad_usage_no_opts ;;
		(--*) [[ -z "$category" ]] && category="${arg:2}" || bad_usage "Can only specify one category" ;;
		(*)  topic="${topic:+"${topic}-"}${arg}" ;;
		esac
	done

	local result=$(__dox_get_help "$category" "$topic")
	if [[ $? -ne 0 ]] ; then
		echo >&2 "ERROR: Could not fetch help - fatal internal error"
		exit 1
	fi

	local pager="cat"
	# TODO: The following pages if output is bigger than the current screen - is
	#				this a good idea?
	#local rows="$(stty -a | head -1 | tr ';' "\n" | grep rows | sed -e 's/^[^0-9]*\([0-9]\{1,\}\).*$/\1/')"
	#[[ "$rows" -gt 1 && "$(echo "$result" | wc -l)" -ge "$rows" ]] && pager="less"
	echo "$result"$'\n' | $pager
}

bad_usage() {
  local msg="${1:-bad usage}" callee=${2:-${FUNCNAME[1]}}

  local callee_bits=( ${callee//_/ } )
  local category="${callee_bits[0]}"
  local name=( "${callee_bits[@]:1}" )
  local cmd=$(IFS='-'; echo "${name[*]}")

  [[ "$category" == "cmd" ]] && category="command"
  local content="$(__dox_get_usage "$cmd" "$category")"
  local prefix="[$SCRIPT_NAME${name:+ ${name[@]}}] "
  echo >&2 $'\n'"$(__dox_reflow_text "ERROR: ${msg}" "${prefix//?/ }" "$prefix")"
  echo >&2 "$(__dox_process_content "USAGE"$'\n'"${content}")"
  echo >&2 $'\n'"For more details, run \`$0 help <command>\` for the desired command."$'\n'
  exit 1
}
bad_usage_invalid_opt() { bad_usage "invalid option '$1'"; }
bad_usage_no_args()     { bad_usage "does not take any options or arguments"; }
bad_usage_no_opts()     { bad_usage "does not take any options"; }
bad_usage_missing()     { bad_usage "required argument for $1 not provided"; }
bad_usage_extra()       { bad_usage "extraneous argument '${1}'${2:+"; $2 already provided as '$3'"}"; }

bad_usage_partial() {
	local cmd="$1" subcmd="$2"
	if [[ -n "$subcmd" ]] ; then
		bad_usage "invalid subcommand '${subcmd}'${cmd:+" for command '${cmd}'"}" "partial_${cmd}"
	else
		bad_usage "missing subcommand for '${cmd}' command" "partial_${cmd}"
	fi
}

check_opt_usage() {
	if [[ -z "$2" || "${2:0:1}" != '-' ]] ; then
		bad_usage "missing value for option $1" "${FUNCNAME[1]}"
	fi
}

__dox_get_help() {
  local category="$1" topic="$2"
	[[ -z "${topic}" && -z "${category}" ]] && { category="command"; topic="help"; }
	if [[ -z "${topic}" ]] ; then
		[[ "$category" == 'topics' ]] && { category='' ; } # --topics is a meta-topic of all topics
		IFS=$'\n' read -rd '' -a categories <<< "$(__dox_get_topics '' "$category" | sed 's/:.*//' | sort | uniq )"
		echo ""
		if [[ "${#categories[@]}" -eq 0 ]] ; then
			echo >&2 $'\n'"[$SCRIPT_NAME help] ERROR: No help category matching '$category'"
			echo >&2 $'\n''For information on available help topics, run `'"$0"' help --topics`'
			exit 2
		fi
		for category in "${categories[@]}" ; do
			[[ "${category}" == "partial" ]] && continue 
			local _header="Available '${category}' help topics:"
			echo "${_header}"$'\n'"${_header//?/-}"
			__dox_generate_topic_includes '{"category":"'$category'","desc":"inline","leader":"  * "}'
			echo ""
		done
		exit 0
	fi

	local topic_list=( $(__dox_get_topics "$topic" "$category" ) )
	if [[ "${#topic_list[@]}" -eq 0 ]] ; then
		# Check for aliases
		if grep '^@~alias=\(.*,\)\{0,\}'"$topic"'\(,.*\)\{0,\}' $0 >/dev/null 2>&1; then
			topic_list=( $(__dox_get_topics '' "$category" '' "$topic" ) )
		fi
	fi
	if [[ ${#topic_list[@]} -eq 1 ]] ; then
		# Only one potential match
		IFS=':' read category topic <<< "${topic_list[0]}"
	elif [[ ${#topic_list[@]} -eq 0 ]] ; then
		__dox_not_found
	else
		local exact_match
		exact_match=( $(printf -- '%s\n' "${topic_list[@]}" | grep ':'"$topic"'$') )
		if [[ ${#exact_match[@]} -eq 1 ]] ; then
			IFS=':' read category topic <<< "${exact_match[0]}"
		else
			__dox_ambiguous_topic "$topic" "${topic_list[@]}"
			return 2
		fi
	fi

	if [[ "$category" == 'partial' ]] ; then
		__dox_ambiguous_topic "$topic"
		return 0
	else
		category="${category:-command}"
		local content="$(__dox_get_content "${topic}" "${category}")"
		__dox_process_content "$content"
	fi
	return 0
}
__dox_get_content() {
	#echo >&2 "======"$'\n'"DEBUG: called '${FUNCNAME[0]}' with "$'\n'" --($@)--"$'\n'"^^^^^^"
	local topic="$1" category="${2:-'command'}"
	local pattern="$(echo "dox-${category}:${topic}" | tr " " "-")"
	# Check if content is present
	if grep "^: <<'$pattern'\$" $0 >/dev/null 2>&1 && grep "^$pattern\$" $0 >/dev/null 2>&1; then
		# FIXME: changing all tabs to 2 spaces; ideally this should only change leading tabs
		local content="$(sed \
			-e 's/	/  /g;'"/^: <<'$pattern'/,/^$pattern\$/"'!d;//d' \
			-e "s:<<[S]CRIPT_NAME>>:$SCRIPT_NAME:g" \
			$0 )"
		
		# Process usage includes
		declare -a uses
		IFS=$'\n'	read -rd '' -a uses <<< "$(__dox_get_meta "$content" 'include' 'usage')"
		local _line
		for _line in "${uses[@]}" ; do
			local opts="${_line:5}"
			local usage="$(__dox_generate_usage "$topic" "${opts:-"{}"}" )"
			content="$( __dox_replace_line "$content" "@~include=${_line}" "$usage" )"
		done
		echo "$content"
	fi
}

__dox_get_usage() {
	local topic="$1" category="${2:-'command'}"
	local content="${3:-"$(__dox_get_content "$topic" "$category")"}"
	local usage="$(__dox_parse_section "$content" 'USAGE')"
	if [[ -z "$usage" && "$category" == "partial" ]] ; then
		usage='@~include=topic{"category":"command","desc":"usage","leader":"  ","partial":"'"${topic}"'"}'
	fi
	echo "$usage" | grep -v '^@~alias'
	
}

__dox_process_content() {
	local _tail=$'\n'" "
	local content="$1${_tail}"

	# Process meta details
	declare -a includes
	IFS=$'\n' read -rd '' -a includes <<< "$(__dox_get_meta "$content" include)"
	local _tag
	for _tag in "${includes[@]}"; do
		local replacement=""
		case "${_tag%\{*}" in
			(topic)      replacement="$(__dox_generate_topic_includes "${_tag:5}")" ;;
			(categories) replacement="$(__dox_generate_category_list "${_tag:10}")" ;;
      (related)    replacement="$(__dox_generate_related_list "${_tag:7}")" ;;
			(*)          replacement='' ;;
		esac
		content="$( __dox_replace_line "$content" "@~include=${_tag}" "$replacement" )"
	done
	echo $'\n'"$( __dox_trim "${content}")"$'\n'
}

__dox_replace_line() {
	# Args: content, line, replacement
	while IFS= read -r line; do
		if [[ "$line" == "$2" ]] ; then
#			[[ -z "$3" ]] && continue
			line="$3"
		fi
		echo "$line"
	done <<< "$1"
}

__dox_not_found() {
	echo >&2 $'\n'"[$SCRIPT_NAME help] ERROR: No help topic matching '${argv[@]:1}'"
	echo >&2 $'\n''For information on available help topics, run `'"$0"' help --topics`'
	exit 2
}	

__dox_ambiguous_topic() {
	local topic=$1 ; shift
	local _args=( "$@" )
	local content="$(__dox_get_content $topic 'partial')"

	# We only use the description and usage from partials
	local _usage="$(__dox_get_usage $topic 'partial' "$content")"
	local _desc="$(__dox_parse_section "$content" DESCRIPTION)"
	[[ -n "$_desc" ]] || { _desc="  This is a partial command stub which requires further arguments." ; }

	content="$(cat<<EOF
USAGE
$_usage

DESCRIPTION
$_desc

@~include=topic{"category":"concept","desc":"block","leader":"  ","partial":"${topic}"}

COMMANDS
@~include=topic{"category":"command","desc":"inline","leader":"  ","partial":"${topic}"}

  For more details, run \`$SCRIPT_NAME help <command>\` for the desired command.
EOF)"

	__dox_process_content "$content"
}

__dox_get_meta() {
	local content="$1" key=${2:-'.*'} sep="=${3:+"${3}\\b"}" filter=${2:+"$2="}
	echo "$content" | grep '^@~'"$key$sep" | sed 's/^@~'"$filter"'//'
}

__dox_get_meta_option() {
	local meta_str="$1" option="$2"
	opt_line="$(echo "$meta_str" | sed 's/^[^{]*\(.*\)[^}]*$/\1/')"
	case "$(echo "$opt_line" | jq -r ".$option | type")" in
		(array)
			i=0; while value="$(echo "$opt_line" | jq -er ".${option}[${i}]")" ; do
				echo $value
				((i++))
			done
			;;
		(null) return 1;;
		(*)    echo "$opt_line" | jq  -er ".$option" ;;
	esac
}

__dox_get_sections() {
	echo "$1" | grep '^[A-Z][-A-Z0-1 ]*'
}

__dox_parse_section() {
	local content="$1" subject="$2"
	local output
	if [[ -n "$subject" ]] ; then
		_found=false
		_nl=""
		while IFS= read -r line; do
			[[ "${line}" =~ ^${subject} ]] && { _found=true ; continue ; }
			[[ ${_found} == true ]]  || { continue ; }
			[[ "${line}" =~ ^[^[:space:]@] ]] && { break ; }
			[[ "${line}" =~ ^$ ]] && { _nl="${_nl}"$'\n' ; continue ; }
			echo "${_nl}${line}" ; _nl=""
		done <<< "$content"
	fi
}

__dox_get_topics() {
	#echo >&2 "======"$'\n'"DEBUG: called '${FUNCNAME[0]}' with "$'\n'" --($@)--"$'\n'"^^^^^^"
	local topic="${1:-.*}" category="${2:-.*}" scope="$3" alias="$4"
	local candidates=( $(grep '^: <<'"'dox-${category}:${topic}\(-.*\)\?'\$" $0 | sed 's/.*'".dox-//;s/.\$//") )
	for candidate in "${candidates[@]}" ; do
		if [[ -n $scope ]] ; then
			IFS=':' read category topic <<< "$candidate"
			if __dox_get_content $topic $category | grep '@~scope=\(.*,\)\{0,\}'"$scope"'\(,.*\)\{0,\}' 2>&1 > /dev/null ; then
				echo $candidate
			fi
		elif [[ -n $alias ]] ; then
			IFS=':' read category topic <<< "$candidate"
			if __dox_get_content $topic $category | grep '@~alias=\(.*,\)\{0,\}'"$alias"'\(,.*\)\{0,\}' 2>&1 > /dev/null ; then
				echo $candidate
			fi
		else
			echo $candidate
		fi
	done
}

__dox_generate_topic_includes() {
	local opts="$1"
	local scope="$(__dox_get_meta_option "${opts}" scope)"
	local category="$(__dox_get_meta_option "${opts}" category)"
	local partial="$(__dox_get_meta_option "${opts}" partial)"
	local leader="$(__dox_get_meta_option "${opts}" leader)"
	local desc="$(__dox_get_meta_option "${opts}" desc)"
	local items=( $(__dox_get_topics "$partial" "$category" "$scope") )
	
	local item
	if [[ "${desc}" == "inline" ]] ; then
		local indent=0
		for item in "${items[@]}" ; do
			local _header="${leader}${item#*:}: "
			[[ "${indent}" -ge "${#_header}" ]] || { indent="${#_header}" ; }
		done
		local padding="$(seq -f ' ' -s '' $indent)"
	fi

	for item in "${items[@]}" ; do
		local _header="${leader}""$(echo "${item#*:}" | sed -e 's/-/ /g')"":"
		case "${desc}" in
			(inline)
				local _desc
				_desc="$( __dox_parse_section "$(__dox_get_content "${item#*:}" "${item%%:*}" )"  DESCRIPTION )"
				__dox_reflow_text "${_desc%%$'\n'$'\n'*}" "$padding" "${_header}${padding:${#_header}}"
				echo ""
				;;
			(block)
				echo "${_header}"
				local _desc
				_desc="$( __dox_parse_section "$(__dox_get_content "${item#*:}" "${item%%:*}" )"  DESCRIPTION )"
				__dox_reflow_text "${_desc%%$'\n'$'\n'*}" "${leader}  "
				echo ""
				;;
			(usage)
				_desc="$( __dox_parse_section "$( __dox_get_content "${item#*:}" "${item%%:*}" )" USAGE | grep -v '^@~')"
				while read -r line ; do echo "${leader}${line}" ; done <<< "$_desc"
				;;
			(*)
				echo "${_header/%:/}"
				;;
		esac
	done
}

__dox_generate_category_list() {
	local opts="$1"
	local leader="$( __dox_get_meta_option "${opts}" "leader" )"
	local items=("commands" "concepts") # hardcoded for now
	for category in "${items[@]}" ; do
		echo "${leader}${category}"
	done
}

__dox_generate_related_list() {
	local opts="$1"
	local desc=''
	local category
  declare -a items
	IFS=$'\n' items=( $( __dox_get_meta_option "${opts}" "items" ) )
	unset IFS
	for topic in "${items[@]}" ; do
		category="${topic%%:*}"
		if [[ "$category" == "$topic" ]] ; then
			category=""
		else
			topic="${topic#*:}"
		fi
		_desc="$( __dox_parse_section "$(__dox_get_content "$topic" "$category")" DESCRIPTION "" )"
		[[ -n "$_desc" ]] || continue
		echo "  $topic${category:+" ($category)"}:"
		__dox_reflow_text "${_desc%%$'\n'$'\n'*}" "    "
		echo ""
	done
}

__dox_generate_usage() {
	local topic="$1"
	local opts="$2"
	local args
	local leader="$(__dox_get_meta_option "${opts}" "leader" )"
	local cmd="$(__dox_get_meta_option "${opts}" "cmd" )"

	#FIXME: this doesn't allow empty strings as a valid arg, necessitating using ' ' for no args
	IFS=$'\n' args=( $(__dox_get_meta_option "${opts}" "args" ) )
	unset IFS
	leader="${leader:-"  "}"
	cmd="${cmd:-"$(echo "$topic" | tr "-" " ")"}"

	[[ ${#args[@]} -gt 0 ]] || args+='' # default with no arguments
	local arg_set
	for arg_set in "${args[@]}" ; do
		echo "${leader}${0} ${cmd} ${arg_set}"
	done
}

__dox_reflow_text() {
	local content="$(echo ${1} | expand -t 2)"
	local leader="$2"
	local header="$3"
	local width=$(( 79 - ${#leader} ))
	unset IFS
	while read -r line ; do
		echo "${header:-$leader}${line}"
		header=""
	done <<< "$(set +x; echo ${content} | fold -s -w $width)"
}
__dox_trim() {
	# trims unused meta, whitespace off end and collapse inner multiple blank lines
	content="$( echo "$1" | grep -v '^@~.*')"
	i=${#content}
	while (( i-- )) ; do [[ "${content:$i:1}" =~ ^[[:space:]]$ ]] || { break ; } ; done
	echo "${content:0:$(( ++i ))}" | cat -s
}


####################################################
# multi-call interace

main() {
	unset IFS
	local cmd=${1:-info} ; shift
	case ${cmd} in
		(ping)                   exit 0 ;;
		(version)                cmd_version $* ;;
		(help)                   cmd_help $* ;;
		(info)                   cmd_help --overview genesis ;;
		(update)                 cmd_update $* ;;
		(new)
			local arg=${1:-} ; shift
			case ${arg} in
				(deployment)         cmd_new_deployment $* ;;
				(site)               cmd_new_site $* ;;
				(env|environment)    cmd_new_environment $* ;;
				(*)                  bad_usage_partial "${cmd}" ${arg} ;;
			esac
			;;
		(stemcell|stemcells)     cmd_stemcells $* ;;
		(release|releases)       cmd_releases $* ;;
		(add)
			local arg=${1:-} ; shift
			case ${arg} in
				(release)            cmd_add_release $* ;;
				(*)                  bad_usage_partial "${cmd}" ${arg} ;;
			esac
			;;
		(set)
			local arg=${1:-} ; shift
			case ${arg} in
				(release)            cmd_set_release $* ;;
				(*)                  bad_usage_partial "${cmd}" ${arg} ;;
			esac
			;;
		(use)
			local arg=${1:-} ; shift
			case ${arg} in
			(release)              cmd_use_release $* ;;
			(stemcell)             cmd_use_stemcell $* ;;
			(*)                    bad_usage_partial "${cmd}" ${arg} ;;
			esac
			;;
		(refresh)
			local arg=${1:-all} ; shift
			case ${arg} in
				(global)             cmd_refresh_global $* ;;
				(site)               cmd_refresh_site $* ;;
				(all)                cmd_refresh_all $* ;;
				(makefile|makefiles) cmd_refresh_makefile $* ;;
				(readme|readmes)     cmd_refresh_readmes $* ;;
				(*)                  bad_usage_partial "${cmd}" ${arg} ;;
			esac
			;;
		(build)                  REDACT=y cmd_build $* ;;
		(deploy)                 cmd_deploy ;;
		(embed)                  cmd_embed ;;
		(ci)
			TERM=dumb
			# Buildout command before parsing opts and args
			local ci_cmd=""
			local ci_partial=""
			while [[ $# -gt 0 && -z "$ci_cmd" ]] ; do
				potential="${potential:+"$potential "}$1"
				case "$potential" in
					(alpha|beta|auto|manual|repipe|flow|smoke-test)   ci_cmd="$potential" ;;
					(parent|"draft-messages"|stemcells)    ci_cmd="$potential" ;;
					("stage1"|"stage2"|"stage-smoke-test") ci_cmd="$potential" ;; 
					(*) 
						# In future, partials may be valid commands (ie stage 1 and stage 1
						# smoke test) so if we have a partial that can also be a command,
						# check here before delaring bad usage. (also why we don't shift
						# until after we test)
						bad_usage_partial "ci${ci_partial:+ $ci_partial}" "$1"
						;;
				esac
				shift
			done
			[[ -n $ci_cmd ]] || bad_usage_partial "ci${ci_partial:+ $ci_partial}" ""

			# Check for common pipeline arg
			declare -a ci_args
			CI_PIPELINE=${CI_PIPELINE:-}
			while [[ $# -gt 0 ]]; do
				local arg=${1:-} ; shift
				case ${arg} in
					(-p|--pipeline) CI_PIPELINE="${1:-}"; shift ;;
					(*)             ci_args+=("$arg") ;;
				esac
			done
			set -- "${ci_args[@]}"
			
			# Process sub-commands
			$(echo "cmd_ci_${ci_cmd}" | tr "-" "_") $*
			;;
		(dump)                   cmd_dump ;;
		(bosh)                   cmd_bosh $* ;;
		(*)                      bad_usage_partial "" "$cmd" ;;
	esac
}

[ -n "${CI_DEBUG}" ] && set -x
# look for some help flags
declare -a argv
while (( $# != 0 )); do
	case ${1} in
	(-h|-\?|--help) argv=( help    ${argv[@]}        ) ;;
	(-v|--version)  argv=( version ${argv[@]}        ) ;;
	(*)             argv=(         ${argv[@]} "${1}" ) ;;
	esac
	shift
done
set -- ${argv[@]}
main $@

# fin
