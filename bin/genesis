#!/bin/bash
VERSION="(development build)"

USERNAME=$(whoami)
CANON_REPO=https://github.com/starkandwayne/genesis

GENESIS_INDEX=${GENESIS_INDEX:-https://genesis.starkandwayne.com}
GENESIS_INDEX=${GENESIS_INDEX%/}
if [[ ${GENESIS_INDEX} = "no" ]]; then
	GENESIS_INDEX=
fi

####################################################
# common functions used by other parts of Genesis

WORKDIR=""
need_a_workdir() {
	if [[ -z ${WORKDIR} ]]; then
		WORKDIR=$(mktemp -d -t genesis.XXXXXX)
		trap "rm -rf ${WORKDIR}" INT TERM QUIT EXIT
	fi
}

find_toplevel_root() {
	(while [[ $(pwd) != "/" && ! -d global/ && ! -f .deployment ]]; do
		cd ..
	 done
	 if [[ -d global || -f .deployment ]]; then
		pwd
	 fi)
}

all_sites() {
	setup
	for dir in ${DEPLOYMENT_ROOT}/*/; do
		site=${dir%%/}
		site=${site##*/}

		if [[ "${site}" != "global" && -d "${dir}/site" ]]; then
			echo ${site}
		fi
	done
}

all_environments_for() {
	local site=${1:?all_environments_for() - no site name provided}
	setup
	for dir in ${DEPLOYMENT_ROOT}/${site}/*/; do
		env=${dir%%/}
		env=${env##*/}

		if [[ -f "${dir}/Makefile" ]]; then
			echo ${env}
		fi
	done
}

check_site() {
	local path=${1:?is_site() - no site argument provided}
	if [[ ! -d "${DEPLOYMENT_ROOT}/${path}" ]]; then
		echo >&2 "${path} not found"
		exit 1
	fi
	if [[ ! -d "${DEPLOYMENT_ROOT}/${path}/site" ]]; then
		echo >&2 "${path} does not look like a valid site"
		exit 2
	fi
}

check_environment() {
	local path=${1:?check_environment() - no site/environment argument provided}
	if [[ ! -d "${DEPLOYMENT_ROOT}/${path}" ]]; then
		echo >&2 "${path} not found"
		exit 1
	fi
	if [[ ! -f "${DEPLOYMENT_ROOT}/${path}/Makefile" ]]; then
		echo >&2 "${path} does not look like a valid environment"
		exit 2
	fi
}

line() {
	echo
	echo "########################################################################"
	echo
}

version_checker() {
	if [[ $1 == $2 ]]
	then
		return 0
	fi
	local IFS=.
	local i actual=($1) expected=($2)
	# fill empty fields in actual with zeros
	for ((i=${#actual[@]}; i<${#expected[@]}; i++))
	do
		actual[i]=0
	done
	actual_numeric=0
	expected_numeric=0
	for ((i=0; i<${#actual[@]}; i++))
	do
		if [[ -z ${expected[i]} ]]
		then
			# fill empty fields in expected with zeros
			expected[i]=0
		fi
		actual_numeric=$((actual_numeric+${actual[i]}*1000**(${#actual[@]}-i)))
		expected_numeric=$((expected_numeric+${expected[i]}*1000**(${#expected[@]}-i)))
	done


	if [[ ${actual_numeric} -lt ${expected_numeric} ]]; then
		return 1
	fi
	return 0
}

setup() {
	if [[ ${DEPLOYMENT_ROOT:-unset} != "unset" ]]; then
		return
	fi

	DEPLOYMENT_ROOT=$(find_toplevel_root)
	if [[ -z ${DEPLOYMENT_ROOT:-} ]]; then
		echo >&2 "Unable to determine Genesis DEPLOYMENT_ROOT"
		exit 3
	fi

	if [[ -f ${DEPLOYMENT_ROOT}/.genesis_deps ]]; then
		errors=""
		while IFS='' read -r line || [[ -n "$line" ]]; do
			cmd=$(echo $line | perl -pe 's|^(.*?):.*$|$1|')
			ver=$(echo $line | perl -pe 's|^.*?: *(.*)$|$1|')
			if [[ -z $(command -v ${cmd}) ]]; then
				errors="This genesis deployment requires the '${cmd}' command\n${errors}"
				continue
			fi
			if [[ ${ver} != "null" && ${ver} != '~' ]]; then
				dev_version=$(${cmd} -v 2>&1 | perl -pe 's/.*development.*/DEV/')
				if [[ ${dev_version} == "DEV" ]]; then
					echo "Treating 'development' version as up-to-date with ${ver}"
					continue
				fi
				current_version=$(${cmd} -v 2>&1 | perl -pe 's|.*?(\d+\.\d+(\.\d+)*).*|$1|')
				if [[ -z ${current_version} || $(echo ${current_version} | egrep '[^0-9\.]') ]]; then
					errors="This genesis deployment requires ${cmd} version ${ver}, but the current version could not be parsed\n${errors}"
					echo ${current_version}
					continue
				fi
				if ! version_checker ${current_version} ${ver}; then
					errors="This genesis deployment requires ${cmd} version ${ver} (found ${current_version})\n${errors}"
					continue
				fi
			fi
		done < ${DEPLOYMENT_ROOT}/.genesis_deps
		if [[ -n ${errors} ]]; then
			echo -e ${errors}
			exit 1
		fi
	fi

	# What type of deployment is this?
	#
	#    normal    - A normal deployment
	#    bosh      - A BOSH deployment (currently-favored type)
	#    bosh-init - A bosh-init BOSH deployment
	#
	DEPLOYMENT_TYPE=normal
	if [[ -f "${DEPLOYMENT_ROOT}/.deployment" ]]; then
		DEPLOYMENT_TYPE=$(cat "${DEPLOYMENT_ROOT}/.deployment")
	fi

	case ${DEPLOYMENT_TYPE} in
	(bosh) DEPLOYMENT_TYPE=bosh-init ;;
	(normal|bosh-init) ;;
	(*) echo >&2 "Unrecognized deployment type: ${DEPLOYMENT_TYPE}"
	    exit 3 ;;
	esac

	DEPLOYMENT_SITE=""
	DEPLOYMENT_ENVIRONMENT=""

	local relpath=${PWD##$DEPLOYMENT_ROOT/}
	if [[ ${relpath#global} == ${relpath} ]]; then
		# not in /global
		local site=${relpath%%/*}
		if [[ -n ${site} && -d "${DEPLOYMENT_ROOT}/${site}" && -d "${DEPLOYMENT_ROOT}/${site}/site" ]]; then
			DEPLOYMENT_SITE=${site}

			relpath=${relpath#$site/}
			local env=${relpath%%/*}
			if [[ -n ${env} && ${env} != "site" && -d "${DEPLOYMENT_ROOT}/${site}/${env}" ]]; then
				DEPLOYMENT_ENVIRONMENT=${env}
			fi
		fi
	fi

	SPRUCE_OPTS=""
	if [[ -n "${SPRUCE_TRACE}" ]]; then
		SPRUCE_OPTS="--debug --trace"
	elif [[ -n "${SPRUCE_DEBUG}" ]]; then
		SPRUCE_OPTS="--debug"
	fi

	DEPLOYMENT_NAME="${DEPLOYMENT_ROOT##*/}"
	DEPLOYMENT_NAME="${DEPLOYMENT_NAME%%-deployment*}"
	DEPLOYMENT_SITE_DIR="${DEPLOYMENT_ROOT}/${DEPLOYMENT_SITE}"
	DEPLOYMENT_ENV_DIR="${DEPLOYMENT_ROOT}/${DEPLOYMENT_SITE}/${DEPLOYMENT_ENVIRONMENT}"
}

actual_yaml_files() {
	for i in $*; do
		[ -f $i ] && echo $i
		shift # FIXME: do we need this?
	done
}

ensure_yaml_file() {
	local path=${1:?ensure_yaml_file() - no path given}
	if [[ ! -s $path ]]; then
		echo "--- {}" > $path
	fi
}

ensure_ci_configuration() {
	ensure_yaml_file "${DEPLOYMENT_ROOT}/.ci.yml"
}

ALL_VAULTED=""
need_a_vault() {
	if [[ -z ${ALL_VAULTED} ]]; then
		ALL_VAULTED=yes
		if [[ -n ${VAULT_ADDR} ]]; then
			echo "Authenticating to Vault at ${VAULT_ADDR}"
			if [[ -z $(command -v vault) ]]; then
				echo >&2 "\`vault' command not found in your \$PATH"
				echo >&2 "  ($PATH)"
				echo >&2 "You may need to install Vault in your task image"
				exit 1
			fi
			echo

			if [[ -n ${CI_SITE_ENV} ]]; then
				touch      ~/.vault
				chmod 0400 ~/.vault
				creds='{"user_id":"'${CI_VAULT_USER_ID:-concourse}'","app_id":"'${CI_VAULT_APP_ID:-generic-app}'"}'
				if ! curl -Ls ${VAULT_ADDR}/v1/auth/app-id/login --data "${creds}" > ~/.vault; then
					echo >&2 "Failed to authenticate to the Vault app-id backend:"
					cat >&2 ~/.vault
					exit 2
				fi

				VAULT_TOKEN=$(cat ~/.vault | jq -r '.auth.client_token')
				rm ~/.vault
				if ! vault status; then
					echo >&2 "Failed to authenticate to Vault at ${VAULT_ADDR}; bailing..."
					exit 2
				fi
			fi

			echo
			echo "Testing Vault authentication by retrieving secret/handshake"
			if ! vault read secret/handshake; then
				echo >&2 "Failed to retrieve secret/handshake; assuming authentication failed..."
				exit 3
			fi
			echo

		else
			echo >&2 "No VAULT_ADDR found in environment; skipping authentication step"
		fi
	fi
}


####################################################
# checks and validating functions

need_command() {
	local cmd=${1:?need_command() - no command name given}

	if [[ ! -x "$(command -v $cmd)" ]]; then
		echo >&2 "${cmd} is not installed."
		if [[ "${cmd}" == "spruce" ]]; then
			echo >&2 "Please download it from https://github.com/geofffranks/spruce/releases"
		fi
		exit 2
	fi
}

check_site_name() {
	local site=${1:?check_site_name() - no site name provided}

	cleaned=$(echo -n ${site} | sed -e 's/[^a-z0-9_-]//')
	if [[ ${cleaned} != ${site} ]]; then
		echo >&2 "Error: Site name '${site}' contains invalid characters"
		exit 2
	fi
}

check_environment_name() {
	local env=${1:?check_environment_name() - no env name provided}

	case ${env} in
	(site|global)
		echo >&2 "Error: Environment name '${env}' is reserved"
		exit 2
		;;
	esac

	cleaned=$(echo -n ${env} | sed -e 's/[^a-z0-9_-]//')
	if [[ ${cleaned} != ${env} ]]; then
		echo >&2 "Error: Environment name '${env}' contains invalid characters"
		exit 2
	fi
}

must_be_in_a_site() {
	setup
	if [[ -z ${DEPLOYMENT_SITE} ]]; then
		echo >&2 "Error: Must be in a site directory to run this command"
		exit 2
	fi
}

must_be_in_an_environment() {
	setup
	if [[ -z ${DEPLOYMENT_ENVIRONMENT} ]]; then
		echo >&2 "Error: must be in an environment directory to run this command"
		exit 2
	fi
}

####################################################
# helper functions

env_root() {
	site=${1:?env_root() - No site given}
	name=${2:?env_root() - No environment given}

	setup
	echo "${DEPLOYMENT_ROOT}/${site}/${name}"
}

switch_to() {
	local site=${1}
	local name=${2}

	if [[ -z ${site} ]]; then
		cd ${DEPLOYMENT_ROOT}/global
	elif [[ -z ${name} ]]; then
		cd ${DEPLOYMENT_ROOT}/${site}/site
	else
		cd ${DEPLOYMENT_ROOT}/${site}/${name}
	fi

	unset DEPLOYMENT_ROOT
	setup
}

create_makefile() {
	path=${1:?create_makefile() - No path given}

	cat > ${path} <<EOF
# genesis, available at ${CANON_REPO}

save_VAULT_ADDR := \$(VAULT_ADDR)
VAULT_ADDR =
REDACT = yes

root_path := \$(realpath \$(dir \$(abspath \$(lastword \$(MAKEFILE_LIST))))../..)
ifdef USE_SYSTEM_GENESIS
	PATH := \$(PATH)
else
	PATH := \$(root_path)/bin:\$(PATH)
endif

help: check
	@PATH=\$(PATH) genesis help makefile

version:
	@PATH=\$(PATH) echo "using \$\$(which genesis)"
	@PATH=\$(PATH) genesis version

manifest: check
	@REDACT=yes PATH=\$(PATH) genesis build

deploy: check
	@REDACT= VAULT_ADDR=\$(save_VAULT_ADDR) PATH=\$(PATH) genesis deploy

refresh: check
	@PATH=\$(PATH) genesis refresh

check:
	@PATH=\$(PATH) genesis ping >/dev/null 2>&1 || (echo >&2 "You need to install Genesis first (see ${CANON_REPO})" && exit 1)

.PHONY: help check manifest deploy refresh version
EOF
}

create_root_readme() {
	cat <<EOF
${DEPLOYMENT_NAME} Deployments
==============================

This repository contains the YAML templates that make up a series of
${DEPLOYMENT_NAME} BOSH deployments, using the format prescribed by the
[Genesis][1] utility.

The configuration is broken up into three logical strata: _global_,
_site_, and _environment_.  _Global_ defines the universal aspects of any
deployment, including overall job structure, constituent BOSH releases,
and invariant (or default) properties.  Each _site_ represents a single
IaaS (an AWS VPC, a vSphere cluster, etc.), and further refines the global
configuration for that infrastructure.  Each _environment_ represents a
single BOSH deployment, with specific network numbering, credentials,
domain names, etc.

For more information, see the READMEs scattered throughout this repository,
and check out \`genesis help\`.  You can download the Genesis program from
[Github][1]

Quickstart
----------

To create a new site:

    genesis new site NAME

To create a new environment

    cd site-name/
    genesis new environment NAME

To build the full BOSH manifest for an environment:

    cd site-name/env-name
    make manifest

... and then deploy it:

    cd site-name/env-name
    make deploy




[1]: ${CANON_REPO}
EOF
}

create_global_readme() {
	case ${DEPLOYMENT_TYPE} in
	(normal) # {{{
		cat <<EOF
Global Definitions

This directory contains templates that describe the common elements of this
deployments, to be shared (and possibly overridden) by sites and environments.
The templates are merged in the following order:

  global/jobs.yml             Specify what jobs will make up the canonical
                              deployment, and what templates to apply to them.

  global/deployment.yml       Define the global structure of all deployments
                              with the correct param calls to remind template
                              writers to override the correct things.

  global/properties.yml       Define the properties (global or per-job) for this
                              deployment.


NOTE: If you make changes to the templates in here, they will automatically
propagate to any newly-created environments, but you will need to run a
refresh for existing environments to receive those updates.
EOF
		;; # }}}
	(bosh-init) # {{{
		cat <<EOF
Global Definitions

This directory contains templates that describe the common elements of BOSH
deployments, to be shared (and possibly overridden) by sites and environments.
The templates are merged in the following order:

  global/jobs.yml             Specify what jobs will make up the BOSH deployment,
                              and what templates to apply to them.

  global/deployment.yml       Define the global structure of all BOSH deployments
                              with the correct param calls to remind template
                              writers to override the correct things.

  global/properties.yml       Define the properties (global or per-job) for the
                              BOSH deployment.


NOTE: If you make changes to the templates in here, they will automatically
propagate to any newly-created environments, but you will need to run a
refresh for existing environments to receive those updates.
EOF
		;; # }}}
	esac
}

create_site_readme() {
	local site=${1:?create_site_readme() - no site given}

	case ${DEPLOYMENT_TYPE} in
	(normal) # {{{
		cat <<EOF
Site Definitions (${site})

This directory contains templates that describe the infrastructure-specific
settings and site-wide properties.  The templates are merged in the following order:

  site/disk-pools.yml         If you need to, you can put disk pool
                              definitions in this file.

  site/update.yml             Specify job update parameters here, which can
                              change based on the cloud provider in use,
                              and its performance characteristics.

  site/jobs.yml               Here you can modify the list of jobs defined
                              at the global level, remove jobs (by setting
                              their instances: count to 0), and supply any
                              additional, site-wide job properties.

  site/networks.yml           Define what networks to use for all the
                              environments in this site (although you may
                              want to defer the actual numbering to the
                              environment level.

  site/resource-pools.yml     Set up the resource pools to use for job
                              virtual machines, and apply their cloud
                              properties (i.e. availability zones)

  site/properties.yml         Define properties (both globally and per-job),
                              that are specific to this environment.  These will
                              most likely override global properties.


NOTE: If you make changes to the templates in here, they will automatically
propagate to any newly-created environments, but you will need to run a
refresh for existing environments to receive those updates.
EOF
		;; # }}}
	(bosh-init) # {{{
		cat <<EOF
Site Definitions (${site})

This directory contains templates that describe the infrastructure-specific
settings and site-wide properties.  The templates are merged in the following order:

  site/disk-pools.yml         If you need to, you can put disk pool
                              definitions in this file.

  site/jobs.yml               Here you can modify the list of jobs defined
                              at the global level, remove jobs (by setting
                              their instances: count to 0), and supply any
                              additional, site-wide job properties.

  site/networks.yml           Define what networks to use for all the
                              environments in this site (although you may
                              want to defer the actual numbering to the
                              environment level.

  site/resource-pools.yml     Set up the resource pools to use for job
                              virtual machines, and apply their cloud
                              properties (i.e. availability zones)

  site/properties.yml         Define properties (both globally and per-job),
                              that are specific to this environment.  These will
                              most likely override global properties.


NOTE: If you make changes to the templates in here, they will automatically
propagate to any newly-created environments, but you will need to run a
refresh for existing environments to receive those updates.
EOF
# site/README
		;; # }}}
	esac
}

create_environment_readme() {
	local site=${1:?create_environment_readme() - no site given}
	local name=${2:?create_environment_readme() - no environment given}

	case ${DEPLOYMENT_TYPE} in
	(normal) # {{{
		cat <<EOF
Environment Definitions (${site}/${name})

This directory contains templates that describe the environment-specific
settings of a single deployment.  These templates will be combined with
the global and site templates to produce a single BOSH manifest for deployment
purposes.  The templates are merged in the following order:

  monitoring.yml              Configure whatever (external) monitoring system you
                              want to track the performance and health of your
                              deployment.

  networking.yml              Configure the network numbering for this deployment.

  director.yml                Identify the BOSH director UUID for this deployment.

  scaling.yml                 Define the scaling properties for this deployment,
                              including things like the number of instances, sizes
                              of persistent disks, resource pool limits, etc.

  properties.yml              Define properties (both globally and per-job),
                              that are specific to this environment.  These will
                              most likely override global and site properties.

  credentials.yml             Define passwords and credentials here, so that they
                              are centralized.  Keep in mind that commiting these
                              into version control incurs some security risk.

  cloudfoundry.yml            For deployments that integrate with Cloud Foundry
                              installations (i.e. as service brokers), you can
                              specify the integration details here, including
                              things like the CF API, credentials, domains, etc.

  name.yml                    Specify the name of this deployment.


This directory also contains a Makefile that makes it easier to build
the final BOSH manifest from all of the constituent templates.
Run \`make' to see some help, or \`make manifest' to just rebuild.
EOF
		;; # }}}
	(bosh-init) # {{{
		cat <<EOF
Environment Definitions (${site}/${name})

This directory contains templates that describe the environment-specific
settings of a single bosh-init deployment.  These templates will be combined
with the global and site templates to produce a single manifest suitable for
deployment via \`bosh-init'.  The templates are merged in the following order:

  networking.yml              Configure the network numbering for this BOSH.

  properties.yml              Define properties (both globally and per-job),
                              that are specific to this environment.  These will
                              most likely override global and site properties.

  credentials.yml             Define passwords and credentials here, so that they
                              are centralized.  Keep in mind that commiting these
                              into version control incurs some security risk.

  name.yml                    Specify the name of this deployment.


This directory also contains a Makefile that makes it easier to build
the final manifest from all of the constituent templates.
Run \`make' to see some help, or \`make manifest' to just rebuild.
EOF
		;; # }}}
	esac
}

create_normal_deployment() {
	setup
	echo "normal" > ${DEPLOYMENT_ROOT}/.deployment
	mkdir -p ${DEPLOYMENT_ROOT}/global
	mkdir -p ${DEPLOYMENT_ROOT}/global/releases

	create_root_readme   >${DEPLOYMENT_ROOT}/README.md
	create_global_readme >${DEPLOYMENT_ROOT}/global/README

	cat > ${DEPLOYMENT_ROOT}/global/deployment.yml <<EOF
---
name: (( param "Please define the deployment name in the environment templates" ))

update:
  canaries: 1
  max_in_flight: 1
  serial: true
EOF
	for file in jobs properties; do
		cat > ${DEPLOYMENT_ROOT}/global/${file}.yml <<EOF
--- {}
EOF
	done
}

create_bosh_init_deployment() {
	setup
	echo "bosh-init" > ${DEPLOYMENT_ROOT}/.deployment
	mkdir -p ${DEPLOYMENT_ROOT}/global
	mkdir -p ${DEPLOYMENT_ROOT}/global/releases

	create_root_readme   >${DEPLOYMENT_ROOT}/README.md
	create_global_readme >${DEPLOYMENT_ROOT}/global/README

	cat > ${DEPLOYMENT_ROOT}/global/deployment.yml <<EOF
---
name: (( param "Please specify a name for your BOSH deployment" ))

releases: (( param "bosh-init deployments require a list of BOSH releases to deploy" ))

resource_pools: (( param "Please define one or more resource pools for your BOSH deployment" ))
disk_pools:     (( param "Please define one or more disk pools for your BOSH deployment" ))
networks:       (( param "Please define one or more networks for your BOSH deployment" ))

cloud_provider:
  template: (( param "Please define the Cloud Provider to use for your BOSH deployment" ))
  properties: (( param "Please define the configuration for your BOSH Cloud Provider" ))
EOF
	for file in jobs properties; do
		cat > ${DEPLOYMENT_ROOT}/global/${file}.yml <<EOF
--- {}
EOF
	done
}

refresh_global() {
	setup
	local site=${1:?refresh_global() - no site given}
	local env=${2:?refresh_global() - no environment given}
	local root="${DEPLOYMENT_ROOT}/${site}/${env}"

	local saved=0
	if [[ -d ${root}/.global ]]; then
		saved=1
		mv ${root}/.global ${root}/.global.old
	fi

	cp -a ${DEPLOYMENT_ROOT}/global ${root}/.global
	if [[ $? != 0 ]]; then
		if [[ ${saved} == 1 ]]; then
			mv ${root}/.global.old ${root}/.global
		fi
		echo >&2 "Error: failed to refresh global for ${site}/${env}"
		exit 2
	fi

	rm -fr ${root}/.global.old
}

create_normal_site() {
	setup
	local site=${1:?create_normal_site() - no site provided}

	check_site_name ${site}

	mkdir -p ${DEPLOYMENT_ROOT}/${site}
	mkdir -p ${DEPLOYMENT_ROOT}/${site}/site
	mkdir -p ${DEPLOYMENT_ROOT}/${site}/site/stemcell

	create_site_readme ${site} >${DEPLOYMENT_ROOT}/${site}/site/README

	cat > ${DEPLOYMENT_ROOT}/${site}/site/disk-pools.yml <<EOF
---
disk_pools: []
EOF
	cat > ${DEPLOYMENT_ROOT}/${site}/site/update.yml <<EOF
---
update:
  canary_watch_time: 1000-60000
  update_watch_time: 1000-60000
  max_in_flight: 1
EOF
	for file in networks resource-pools jobs properties; do
		cat > ${DEPLOYMENT_ROOT}/${site}/site/${file}.yml <<EOF
--- {}
EOF
	done

	(cd ${DEPLOYMENT_ROOT}/global/releases ; ls -1) > ${DEPLOYMENT_ROOT}/${site}/site/releases
}

create_bosh_init_site() {
	setup
	local site=${1:?create_normal_site() - no site provided}

	check_site_name ${site}

	mkdir -p ${DEPLOYMENT_ROOT}/${site}
	mkdir -p ${DEPLOYMENT_ROOT}/${site}/site

	create_site_readme ${site} >${DEPLOYMENT_ROOT}/${site}/site/README

	cat > ${DEPLOYMENT_ROOT}/${site}/site/disk-pools.yml <<EOF
---
disk_pools: []
EOF
	for file in networks resource-pools jobs properties; do
		cat > ${DEPLOYMENT_ROOT}/${site}/site/${file}.yml <<EOF
--- {}
EOF
	done

	(cd ${DEPLOYMENT_ROOT}/global/releases ; ls -1) > ${DEPLOYMENT_ROOT}/${site}/site/releases

	echo "Created BOSH (bosh-init) site ${site}:"
	tree "${DEPLOYMENT_ROOT}/${site}"
	echo
	echo
}

refresh_site() {
	setup
	local site=${1:?refresh_site() - no site given}
	local env=${2:?refresh_site() - no environment given}
	local root="${DEPLOYMENT_ROOT}/${site}/${env}"

	local saved=0
	if [[ -d ${root}/.site ]]; then
		saved=1
		mv ${root}/.site ${root}/.site.old
	fi

	cp -a ${DEPLOYMENT_ROOT}/${site}/site ${root}/.site
	if [[ $? != 0 ]]; then
		if [[ ${saved} == 1 ]]; then
			mv ${root}/.site.old ${root}/.site
		fi
		echo >&2 "Error: failed to refresh site for ${site}/${env}"
		exit 2
	fi

	rm -fr ${root}/.site.old
}

create_normal_environment() {
	setup
	local site=${1:?create_normal_environment() - no site provided}
	local name=${2:?create_normal_environment() - no environment name provided}
	local root=$(env_root ${site} ${name})

	check_site_name ${site}
	check_environment_name ${name}

	if [[ ! -d "${DEPLOYMENT_ROOT}/${site}" ]]; then
		create_normal_site ${site}
	fi

	mkdir -p ${root}
	create_makefile ${root}/Makefile
	create_environment_readme ${site} ${name} >${root}/README

	for file in cloudfoundry credentials director monitoring properties networking scaling; do
		cat > ${root}/${file}.yml <<EOF
--- {}
EOF
	done

	local director_uuid
	director_uuid=$(bosh status --uuid)
	if [[ "$?" -eq 0 ]] ; then
		cat <<EOF > ${root}/director.yml
---
director_uuid: ${director_uuid}
EOF
	fi

	VAULT_PREFIX=secret/${site}/$name/${DEPLOYMENT_NAME}
	DEPLOYMENT_SITE=${site}
	DEPLOYMENT_ENVIRONMENT=${name}
	ENVIRONMENT_ROOT=${DEPLOYMENT_ROOT}/${DEPLOYMENT_SITE}/${DEPLOYMENT_ENVIRONMENT}

	cat <<EOF > ${root}/name.yml
---
name: ${site}-${name}-${DEPLOYMENT_NAME}
meta:
  vault_prefix: ${VAULT_PREFIX}
EOF

	if [[ -d ${DEPLOYMENT_ROOT}/.env_hooks ]]; then
		for file in ${DEPLOYMENT_ROOT}/.env_hooks/*; do
			if [[ -f ${file} && -x ${file} ]]; then
				echo "Running env setup hook: ${file}"
				export VAULT_PREFIX DEPLOYMENT_NAME DEPLOYMENT_SITE DEPLOYMENT_ENVIRONMENT DEPLOYMENT_ROOT ENVIRONMENT_ROOT
				${file}
				local rc=$?
				if [[ $rc -ne 0 ]]; then
					echo "Setup script bailed (exit ${rc})."
					echo "Tearing down ${DEPLOYMENT_SITE}/${DEPLOYMENT_ENVIRONMENT} environment..."
					rm -rf ${ENVIRONMENT_ROOT}
					exit 1
				fi
			fi
		done
	fi

	refresh_global ${site} ${name}
	refresh_site   ${site} ${name}

	echo "Created environment ${site}/${name}:"
	tree ${root}
	echo
	echo
}

create_bosh_init_environment() {
	setup
	local site=${1:?create_bosh_init_environment() - no site provided}
	local name=${2:?create_bosh_init_environment() - no environment name provided}
	local root=$(env_root ${site} ${name})

	check_site_name ${site}
	check_environment_name ${name}

	if [[ ! -d "${DEPLOYMENT_ROOT}/${site}" ]]; then
		create_bosh_init_site ${site}
	fi

	mkdir -p ${root}
	create_makefile ${root}/Makefile
	create_environment_readme ${site} ${name} >${root}/README

	for file in credentials name properties networking; do
		cat > ${root}/${file}.yml <<EOF
--- {}
EOF
	done

	VAULT_PREFIX=secret/${site}/$name/${DEPLOYMENT_NAME}
	DEPLOYMENT_SITE=${site}
	DEPLOYMENT_ENVIRONMENT=${name}
	ENVIRONMENT_ROOT=${DEPLOYMENT_ROOT}/${DEPLOYMENT_SITE}/${DEPLOYMENT_ENVIRONMENT}

	cat <<EOF > ${root}/name.yml
---
name: ${site}-${name}-${DEPLOYMENT_NAME}
meta:
  vault_prefix: ${VAULT_PREFIX}
EOF

	if [[ -d ${DEPLOYMENT_ROOT}/.env_hooks ]]; then
		for file in ${DEPLOYMENT_ROOT}/.env_hooks/*; do
			if [[ -f ${file} && -x ${file} ]]; then
				echo "Running env setup hook: ${file}"
				export VAULT_PREFIX DEPLOYMENT_NAME DEPLOYMENT_SITE DEPLOYMENT_ENVIRONMENT DEPLOYMENT_ROOT ENVIRONMENT_ROOT=${DEPLOYMENT_ROOT}/${DEPLOYMENT_SITE}/${DEPLOYMENT_ENVIRONMENT}
				${file}
			fi
		done
	fi

	refresh_global ${site} ${name}
	refresh_site   ${site} ${name}

	echo "Created environment ${site}/${env}:"
	tree ${root}
	echo
	echo
}

releases_from() {
	local file=${1:?releases_from() - file not provided}
	cat ${file} | sed 's/\s*#.*//'
}

releases_for_site() {
	setup
	local site=${1:?releases_for_environment() - no site name provided}

	releases_from "${DEPLOYMENT_ROOT}/${site}/site/releases"
}

releases_for_environment() {
	setup
	local site=${1:?releases_for_environment() - no site name provided}
	local name=${2:?releases_for_environment() - no environment name provided}

	releases_from "${DEPLOYMENT_ROOT}/${site}/${name}/.site/releases"
}

normal_site_metadata() {
	must_be_in_an_environment
	if [[ ! -f "${DEPLOYMENT_ENV_DIR}/.site/stemcell/name" ]]; then
		echo >&2 "Error: no stemcell name specified for site"
		exit 2
	fi
	local stemcell_name=$(cat "${DEPLOYMENT_ENV_DIR}/.site/stemcell/name")

	if [[ ! -f "${DEPLOYMENT_ENV_DIR}/.site/stemcell/version" ]]; then
		echo >&2 "Error: no stemcell version specified for site"
		exit 2
	fi
	local stemcell_version=$(cat "${DEPLOYMENT_ENV_DIR}/.site/stemcell/version")

	local stemcell_url=""
	if [[ -f "${DEPLOYMENT_ENV_DIR}/.site/stemcell/url" ]]; then
		stemcell_url=$(cat "${DEPLOYMENT_ENV_DIR}/.site/stemcell/url")
	fi
	local stemcell_sha1=""
	if [[ -f "${DEPLOYMENT_ENV_DIR}/.site/stemcell/sha1" ]]; then
		stemcell_sha1=$(cat "${DEPLOYMENT_ENV_DIR}/.site/stemcell/sha1")
	fi

	if [[ ! -f "${DEPLOYMENT_ENV_DIR}/.site/releases" ]]; then
		echo >&2 "Error: no releases listed for site"
		exit 2
	fi

	local releases=$(releases_from "${DEPLOYMENT_ENV_DIR}/.site/releases")
	for rel in ${releases}; do
		if [[ ! -d "${DEPLOYMENT_ENV_DIR}/.global/releases/${rel}" ]]; then
			echo >&2 "Error: release '${rel}' not defined globally"
			exit 2
		fi
		if [[ ! -f "${DEPLOYMENT_ENV_DIR}/.global/releases/${rel}/version" ]]; then
			echo >&2 "Error: no version specified for '${rel}'"
			exit 2
		fi
	done

	cat <<EOF
---
meta:
  stemcell:
    name: ${stemcell_name}
    version: ${stemcell_version}
EOF
	if [[ -n ${stemcell_url} ]]; then
		echo "    url: ${stemcell_url}"
	fi
	if [[ -n ${stemcell_sha1} ]]; then
		echo "    sha1: ${stemcell_sha1}"
	fi
	echo "releases:"

	for rel in ${releases}; do
		local release_version=$(cat ${DEPLOYMENT_ENV_DIR}/.global/releases/${rel}/version)
		local release_url=""
		if [[ -f ${DEPLOYMENT_ENV_DIR}/.global/releases/${rel}/url ]]; then
			release_url=$(cat ${DEPLOYMENT_ENV_DIR}/.global/releases/${rel}/url)
		fi
		local release_sha1=""
		if [[ -f ${DEPLOYMENT_ENV_DIR}/.global/releases/${rel}/sha1 ]]; then
			release_sha1=$(cat ${DEPLOYMENT_ENV_DIR}/.global/releases/${rel}/sha1)
		fi

		echo "  - name: ${rel}"
		echo "    version: ${release_version}"
		if [[ -n ${release_url} ]]; then
			echo "    url: \"${release_url}\""
		fi
		if [[ -n ${release_sha1} ]]; then
			echo "    sha1: \"${release_sha1}\""
		fi
	done
}

build_normal_manifest() {
	must_be_in_an_environment
	need_command spruce

	normal_site_metadata > ${DEPLOYMENT_ENV_DIR}/.begin.yml
	(cd ${DEPLOYMENT_ENV_DIR}
	 spruce $SPRUCE_OPTS merge --prune meta \
	    .begin.yml \
	    $(actual_yaml_files \
	        .begin.yml \
	        \
	        .global/jobs.yml \
	        .global/deployment.yml \
	        .global/properties.yml \
	        \
	        .site/disk-pools.yml \
	        .site/update.yml \
	        .site/jobs.yml \
	        .site/networks.yml \
	        .site/resource-pools.yml \
	        .site/properties.yml \
	        \
	        monitoring.yml \
	        networking.yml \
	        director.yml \
	        scaling.yml \
	        properties.yml \
	        credentials.yml \
	        cloudfoundry.yml \
	        name.yml))

	rc=$?

	rm -f ${DEPLOYMENT_ENV_DIR}/.begin.yml

	if [[ $rc != 0 ]]; then
		echo >&2 "Failed to merge templates; bailing..."
		exit 5
	fi
}

bosh_init_site_metadata() {
	must_be_in_an_environment
	if [[ ! -f "${DEPLOYMENT_ENV_DIR}/.site/stemcell/url" ]]; then
		echo >&2 "Error: no stemcell URL listed for site"
		exit 2
	fi
	local stemcell_url=$(cat "${DEPLOYMENT_ENV_DIR}/.site/stemcell/url")
	if [[ ! -f "${DEPLOYMENT_ENV_DIR}/.site/stemcell/sha1" ]]; then
		echo >&2 "Error: no stemcell sha1 listed for site"
		exit 2
	fi
	local stemcell_sha1=$(cat "${DEPLOYMENT_ENV_DIR}/.site/stemcell/sha1")

	if [[ ! -f "${DEPLOYMENT_ENV_DIR}/.site/releases" ]]; then
		echo >&2 "Error: no releases listed for site"
		exit 2
	fi
	local releases=$(releases_from "${DEPLOYMENT_ENV_DIR}/.site/releases")

	for rel in ${releases}; do
		if [[ ! -d "${DEPLOYMENT_ENV_DIR}/.global/releases/${rel}" ]]; then
			echo >&2 "Error: release '${rel}' not defined globally"
			exit 2
		fi
		if [[ ! -f "${DEPLOYMENT_ENV_DIR}/.global/releases/${rel}/url" ]]; then
			echo >&2 "Error: no url specified for '${rel}'"
			exit 2
		fi
		if [[ ! -f "${DEPLOYMENT_ENV_DIR}/.global/releases/${rel}/sha1" ]]; then
			url=$(cat "${DEPLOYMENT_ENV_DIR}/.global/releases/${rel}/url")
			echo >&2 "retrieving ${url}"
			sha1=$(curl -LSs "${url}" | checksum | sed -e 's/ .*//')
			if [[ -z "${sha1}" ]]; then
				echo >&2 "Error: failed to download and verify ${rel} release"
				echo >&2 "       (from $url)"
				exit 2
			fi
			echo "$sha1" > "${DEPLOYMENT_ENV_DIR}/.global/releases/${rel}/sha1"
		fi
	done

	cat <<EOF
---
meta:
  stemcell:
    url: ${stemcell_url}
    sha1: ${stemcell_sha1}
releases:
EOF
	for rel in ${releases}; do
		echo "  - name: ${rel}"
		echo "    url:  $(cat ${DEPLOYMENT_ENV_DIR}/.global/releases/${rel}/url)"
		echo "    sha1: $(cat ${DEPLOYMENT_ENV_DIR}/.global/releases/${rel}/sha1)"
	done
}

build_bosh_init_manifest() {
	must_be_in_an_environment
	need_command spruce

	bosh_init_site_metadata > ${DEPLOYMENT_ENV_DIR}/.begin.yml
	(cd ${DEPLOYMENT_ENV_DIR}
	 spruce $SPRUCE_OPTS merge --prune meta \
	    $(actual_yaml_files \
	        .begin.yml \
	        \
	        .global/jobs.yml \
	        .global/deployment.yml \
	        .global/properties.yml \
	        \
	        .site/disk-pools.yml \
	        .site/jobs.yml \
	        .site/networks.yml \
	        .site/resource-pools.yml \
	        .site/properties.yml \
	        \
	        networking.yml \
	        properties.yml \
	        credentials.yml \
	        name.yml))
	rc=$?

	rm -f ${DEPLOYMENT_ENV_DIR}/.begin.yml

	if [[ $rc != 0 ]]; then
		echo >&2 "Failed to merge templates; bailing..."
		exit 5
	fi
}


####################################################
# multi-call handlers

cmd_help() {
	local topic=""
	while (( $# )); do
		arg=$1 ; shift
		case ${arg} in
		(-*)
			echo >&2 "USAGE: genesis help <topic>"
			exit 1
			;;
		(*)
			if [[ -n ${topic} ]]; then
				topic="${topic} "
			fi
			topic="${topic}${arg}"
		esac
	done

	case ${topic:-usage} in
	(usage|help)
		cat >&2 <<EOF
USAGE: genesis <command> [arguments]

Common commands:

    genesis new deployment      Create a new deployment directory, with all the
                                necessary files for deploying with Genesis.

    genesis new site            Set up the files and directories for a new site.

    genesis new environment     Set up the files and directories for a new environment.

    genesis build               When run from inside of an environment directory,
                                paste together all of the template files, in order
                                and pop out a manifest file.

    genesis diff                When run from inside of an environment directory,
                                show a semantic diff of the generated manifest for that
                                environment, against some other manifest file.

    genesis refresh             Refresh the cached copies of site and/or global
                                definitions inside the current environment directory.
                                Can also be used to recreate the Makefile after a
                                Genesis upgrade.

    genesis bosh                Generates a deployable manifest (which may have secrets
                                in it) and then runs the \`bosh\` CLI with remaining
                                arguments.  Useful for recreating workers.

    genesis help                Peruse the help!  Give it a topic argument, or the name
                                of another command to get more detailed information.
                                Documentation!

EOF
		exit 0
		;;
	(new)
		cat >&2 <<EOF
USAGE: genesis new deployment [options] NAME
       genesis new site [options] SITE
       genesis new environment SITE ENVIRONMENT

Creates new things, with all the right files in all the right places.

EOF
		exit 0
		;;
	(new\ deployment)
		cat >&2 <<EOF
USAGE: genesis new deployment [options] NAME
       genesis new deployment --template TEMPLATE [NAME]

  Create a new deployment, complete with all the correct templates in
  global/, and a base configuration.  This will create a sub-directory
  in the current working directory, named <NAME>-deployments, and set
  it up with git version control.

  OPTIONS

    -t, --type <type>

        Generate a different type of deployment.  Valid values are
        'bosh-init' and 'normal' (the default is 'normal').

    -T, --template <name>

        Base the deployment off of an upstream Genesis template, by
        cloning a repository from github.com and using that.

        Templates can be specified as qualified name containing the
        Github org/user and repository name, i.e. "jhunt/bolo", or
        as a simple name, i.e. "shield", which will be inferred to
        belong to the starkandwayne organization.

EOF
		exit 0
		;;
	(new\ site)
		cat >&2 <<EOF
USAGE: genesis new site [options] NAME

  Create a new site with the given name, and set up the necessary
  directories and blank template files for defining the parts of a
  BOSH manifest that map to infrastructural and site-wide things.

  OPTIONS

    -T, --template <name>

        Base the new site off of a site template.

        This generally only works if you generated the deployment
        from an upstream Genesis template (via '--template')

EOF
		exit 0
		;;
	(new\ environment)
		cat >&2 <<EOF
USAGE: genesis new environment SITE NAME

  Create a new environment with the given name, in the specified
  site, and set up the directories and template files for local,
  environment-specific things.

EOF
		exit 0
		;;
	(build)
		cat >&2 <<EOF
USAGE: genesis build

Compiles all of the YAML templates down to a single BOSH manifest
for the current environment.

EOF
		exit 0
		;;
	(refresh)
		cat >&2 <<EOF
USAGE: genesis refresh [(global|site|all|makefile|readme)]

Copies current definitions of the global templates and/or the
current site into the current environment.  By default, copies both.

The argument 'makefile' only rebuilds the Makefile for an environment,
which can be useful to bring old deployments in-line with newer versions
of Genesis.

Similarly, 'readme' only recreates the various README files for the top-level,
the global/ directories, and all sites and environments.

EOF
		exit 0
		;;
	(makefile)
		cat >&2 <<EOF
When Genesis provisions a new environment, it creates a Makefile that
provides some easy "shortcut" command invocation targets to simplify
the manifest generation process.

  $ make manifest           #  Build a new manifest for the environment
                            #  by merging the template YAML files together.

  $ make deploy             # Build the manifest and attempt to deploy it.
                            # (This safely handles Vault'd credentials)

  $ make refresh            #  Pull in fresh copies of global and site YAML
                            #  templates (into .global/ and .site/).

Since this is a real Makefile, you can combine the two actions:

  $ make refresh manifest   #  Refresh global / site configuration and then
                            #  build an up-to-date deployment manifest.

EOF
		exit 0
		;;
	(bosh)
		cat >&2 <<EOF
USAGE: genesis bosh [...]

Generates a deployable manifest (which may contain credentials or other
secrets) and then passes the remaining arguments off to the \`bosh\` CLI.

For example, to rebuild the worker/1 job:

    $ genesis bosh -t prod recreate worker 1

All other BOSH commands are available, but may not necessarily benefit
from the manifest re-generation step.

EOF
		exit 0
		;;
	# FIXME: ci
	(*)
		cat >&2 <<EOF
Unrecognized help topic '${topic}'.
Try one of these:

    genesis help usage
    genesis help <command>

EOF
		exit 0
		;;
	esac
	exit 1
}

cmd_new_deployment() {
	local dtype="normal"
	local root=$(pwd)
	local name=""
	local template=""

	while (( $# )); do
		arg=$1 ; shift
		case ${arg} in
		(-t|--type)
			dtype=$1
			shift
			;;
		(-T|--template)
			template=$1
			shift
			;;
		(-r|--root)
			root=$1
			shift
			;;
		(*)
			name=${arg%-deployment*}
			shift
			;;
		esac
	done

	if [[ -n ${template} ]]; then
		if [[ ${template} != ?*/?* ]]; then
			template="starkandwayne/${template}"
		fi
		template="${template%%-deployment*}-deployment"

		if [[ -z ${name} ]]; then
			name=${template##*/}
			name=${name%%-deployment*}
		fi
	fi
	if [[ -z ${name:-} ]]; then
		echo >&2 "USAGE: genesis new deployment [options] name"
		exit 1
	fi

	if [[ ! -d ${root} ]]; then
		echo >&2 "Error: root directory ${root} does not exist"
		exit 1
	fi

	if [[ -d "${root}/${name}-deployments" ]]; then
		echo >&2 "Error: target directory ${root}/${name}-deployments already exists!"
		exit 1
	fi

	if [[ -n ${template} ]]; then
		local url=https://github.com/${template}
		set -e
		echo "cloning from template ${url}"
		git clone --origin upstream ${url} ${root}/${name}-deployments
		cd ${root}/${name}-deployments
		git config --remove-section branch.master

		cmd_embed
		git add bin/genesis

		create_root_readme   >README.md
		create_global_readme >global/README

		git add .
		git commit -m "Initial clone of templated ${name} deployment"
		exit 0
	fi

	case ${dtype} in
	(bosh) dtype=bosh-init ;;
	(normal|bosh-init) ;;
	(*)
		echo >&2 "Error: unrecognized deployment type '${dtype}'"
		exit 1
		;;
	esac

	DEPLOYMENT_TYPE=${dtype}
	DEPLOYMENT_NAME=${name}
	DEPLOYMENT_ROOT="${root}/${name}-deployments"
	mkdir ${DEPLOYMENT_ROOT}

	case ${DEPLOYMENT_TYPE} in
	(normal)
		create_normal_deployment
		;;
	(bosh-init)
		create_bosh_init_deployment
		;;
	esac

	cmd_embed >/dev/null

	cat > ${DEPLOYMENT_ROOT}/.gitignore <<EOF
.begin.yml
.deploy.yml
EOF

	if git symbolic-ref HEAD 2>&1 | grep -qE 'fatal: Not a git repository|fatal: Unable to read current working directory'; then
		(cd ${DEPLOYMENT_ROOT}
		 git init
		 git add .
		 git commit -m "Initial commit of ${name}-deployments")
	fi
	exit 0
}

cmd_new_site() {
	local name=""
	local template=""

	while (( $# )); do
		arg=$1 ; shift
		case ${arg} in
		(-T|--template)
			template=$1
			shift
			;;
		(*)
			name=${arg}
			;;
		esac
	done

	if [[ -z ${name} ]]; then
		echo >&2 "USAGE: genesis new site [options] name"
		exit 1
	fi

	setup
	if [[ -d "${DEPLOYMENT_ROOT}/${name}" ]]; then
		echo "Site ${name} already exists"
		exit 0
	fi

	if [[ -n ${template} ]]; then
		if [[ ! -d ${DEPLOYMENT_ROOT}/.templates/${template} ]]; then
			echo >&2 "Site template '${template}' not found..."
			exit 2
		fi

		mkdir -p ${DEPLOYMENT_ROOT}/${name}
		cp -a ${DEPLOYMENT_ROOT}/.templates/${template} ${DEPLOYMENT_ROOT}/${name}/site
		create_site_readme ${name} >${DEPLOYMENT_ROOT}/${name}/README
		echo "Created site ${name} (from template ${template}):"

	else
		case ${DEPLOYMENT_TYPE} in
		(normal)
			create_normal_site ${name}
			;;
		(bosh-init)
			create_bosh_init_site ${name}
			;;
		esac
		echo "Created site ${name}:"
	fi

	tree "${DEPLOYMENT_ROOT}/${name}"
	echo
	echo
	exit 0
}

cmd_new_environment() {
	local site=${1:-}
	local name=${2:-}

	setup
	if [[ -n ${DEPLOYMENT_SITE} && -z ${name} ]]; then
		name=${site}
		site=${DEPLOYMENT_SITE}
	fi

	case ${DEPLOYMENT_TYPE} in
	(normal)
		create_normal_environment ${site} ${name}
		;;
	(bosh-init)
		create_bosh_init_environment ${site} ${name}
		;;
	esac
	exit 0
}

bad_new() {
	local arg=${1}
	cat >&2 <<EOF
USAGE: genesis new deployment
       genesis new (site|environment)
EOF
	exit 1
}

check_index() {
	local type=${1:?check_index() - no type given}
	local name=${2:?check_index() - no name given}
	local version=${3:?check_index() - no version given}

	local root=""
	case ${type} in
	(stemcell)
		root=${DEPLOYMENT_SITE_DIR}/site/stemcell
		;;
	(release)
		root=${DEPLOYMENT_ROOT}/global/releases/${name}
		;;
	(*)
		echo >&2 "Invalid type '${type}' given to check_index.  Please file a bug"
		exit 2
		;;
	esac


	if [[ -n ${GENESIS_INDEX} ]]; then
		need_a_workdir
		echo "  checking ${GENESIS_INDEX} for details on ${type} ${name}/${version}"
		if [[ ${version} == "latest" ]]; then
			curl -Lsk ${GENESIS_INDEX}/v1/${type}/${name}/latest       > ${WORKDIR}/index
		else
			curl -Lsk ${GENESIS_INDEX}/v1/${type}/${name}/v/${version} > ${WORKDIR}/index
		fi

		for thing in url sha1 version; do
			v=$(jq -r .${thing} <${WORKDIR}/index)
			if [[ -n ${v} ]]; then
				echo "${v}" > ${root}/${thing}
			fi
		done
	fi
}

cmd_add_release() {
	local release=${1:?USAGE: genesis add relese NAME [VERSION] [URL]}
	local version=${2:-latest}
	local url=${3:-}

	setup
	if [[ -d ${DEPLOYMENT_ROOT}/global/releases/${release} ]]; then
		echo >&2 "Release ${release} already exists in global/releases/"
		exit 1
	fi
	mkdir -p ${DEPLOYMENT_ROOT}/global/releases/${release}
	echo ${version} > ${DEPLOYMENT_ROOT}/global/releases/${release}/version

	if [[ -n ${url} ]]; then
		echo ${url} > ${DEPLOYMENT_ROOT}/global/releases/${release}/url
	else
		check_index release ${release} ${version}
	fi

	if [[ ${version} == "latest" ]]; then
		echo "Using the latest version of ${release}"
	else
		echo "Using v${version} of ${release}"
	fi

	exit 0
}

bad_add() {
	local arg=${1}
	cat >&2 <<EOF
USAGE: genesis add release
EOF
	exit 1
}

cmd_set_release() {
	local release=${1:?USAGE: genesis set relese NAME VERSION}
	local version=${2:-latest}

	setup
	mkdir -p ${DEPLOYMENT_ROOT}/global/releases/${release}
	echo ${version} > ${DEPLOYMENT_ROOT}/global/releases/${release}/version
	if [[ ${version} == "latest" ]]; then
		echo "Using the latest version of ${release}"
	else
		echo "Using v${version} of ${release}"
	fi
	exit 0
}

bad_set() {
	local arg=${1}
	cat >&2 <<EOF
USAGE: genesis set release
EOF
	exit 1
}

cmd_use_release() {
	release=${1:?USAGE: genesis use release NAME}

	must_be_in_a_site
	if [[ ! -d ${DEPLOYMENT_ROOT}/global/releases/${release} ]]; then
		echo >&2 "Release ${release} is not defined globally."
		echo >&2 "(Do you need to \`genesis add release ${release}' first?)"
		exit 1
	fi

	relfile=${DEPLOYMENT_SITE_DIR}/site/releases
	if grep -q "^${release}$" $relfile >/dev/null 2>&1; then
		echo "Site ${DEPLOYMENT_SITE} is already set to use release ${release}"
	else
		echo "${release}" >> $relfile
		echo "Site ${DEPLOYMENT_SITE} is now using release ${release}"
	fi
	exit 0
}

cmd_use_stemcell() {
	name=${1:?USAGE: genesis use stemcell NAME VERSION}
	version=${2:-latest}

	must_be_in_a_site

	# resolve aliases
	case ${name} in
	(aws)
		name="bosh-aws-xen-hvm-ubuntu-trusty-go_agent"
		;;
	(azure|hyperv)
		name="bosh-azure-hyperv-ubuntu-trusty-go_agent"
		;;
	(openstack)
		name="bosh-openstack-kvm-ubuntu-trusty-go_agent"
		;;
	(vcloud)
		name="bosh-vcloud-esxi-ubuntu-trusty-go_agent"
		;;
	(vsphere)
		name="bosh-vsphere-esxi-ubuntu-trusty-go_agent"
		;;
	(warden|bosh-lite)
		name="bosh-warden-boshlite-ubuntu-trusty-go_agent"
		;;
	esac

	echo "${name}"    > ${DEPLOYMENT_SITE_DIR}/site/stemcell/name
	echo "${version}" > ${DEPLOYMENT_SITE_DIR}/site/stemcell/version

	check_index stemcell ${name} ${version}

	if [[ ${version} == "latest" ]]; then
		echo "Site ${DEPLOYMENT_SITE} is now using the latest version of stemcell ${name}"
	else
		echo "Site ${DEPLOYMENT_SITE} is now using stemcell ${name} v${version}"
	fi
	exit 0
}

bad_use() {
	local arg=${1}
	cat >&2 <<EOF
USAGE: genesis use release
       genesis use stemcell
EOF
	exit 1
}

cmd_stemcells() {
	setup

	local site=${1:-$DEPLOYMENT_SITE}
	local env=${2:-$DEPLOYMENT_ENVIRONMENT}

	if [[ -n ${env} ]]; then
		name=$(cat ${DEPLOYMENT_ROOT}/${site}/${env}/.site/stemcell/name)
		vers=$(cat ${DEPLOYMENT_ROOT}/${site}/${env}/.site/stemcell/version)
		printf "%s/%s\n" ${name} ${vers}
		return
	fi

	if [[ -n ${site} ]]; then
		name=$(cat ${DEPLOYMENT_ROOT}/${site}/site/stemcell/name)
		vers=$(cat ${DEPLOYMENT_ROOT}/${site}/site/stemcell/version)
		printf "%s/%s\n" ${name} ${vers}
		return
	fi

	cat >&2 <<EOF
USAGE: genesis stemcells <site> [<env>]

(you can also \`cd\` into a site or environment directory
 and just run \`genesis stemcells\` without any arguments)
EOF
	exit 1
}

cmd_releases() {
	setup

	local site=${1:-$DEPLOYMENT_SITE}
	local env=${2:-$DEPLOYMENT_ENVIRONMENT}

	if [[ -n ${env} ]]; then
		for rel in $(releases_for_environment ${site} ${env}); do
			vers=$(cat ${DEPLOYMENT_ROOT}/${site}/${env}/.global/releases/${rel}/version)
			printf "%s/%s\n" ${rel} ${vers}
		done
		return
	fi

	if [[ -n ${site} ]]; then
		for rel in $(releases_for_site ${site}); do
			vers=$(cat ${DEPLOYMENT_ROOT}/global/releases/${rel}/version)
			printf "%s/%s\n" ${rel} ${vers}
		done
		return
	fi

	cat >&2 <<EOF
USAGE: genesis releases <site> [<env>]

(you can also \`cd\` into a site or environment directory
 and just run \`genesis releases\` without any arguments)
EOF
	exit 1
}

cmd_build() {
	must_be_in_an_environment

	target=${1:-manifest.yml}
	mkdir -p ${DEPLOYMENT_ENV_DIR}/manifests

	case ${DEPLOYMENT_TYPE} in
	(normal)
		build_normal_manifest > ${DEPLOYMENT_ENV_DIR}/manifests/${target}
		;;
	(bosh-init)
		build_bosh_init_manifest > ${DEPLOYMENT_ENV_DIR}/manifests/${target}
		;;
	esac
	exit 0
}

cmd_diff() {
	must_be_in_an_environment
	# FIXME: we should totes run spruce diff here
	exit 0
}

cmd_refresh_global() {
	must_be_in_an_environment
	echo "Refreshing global definitions for ${DEPLOYMENT_SITE}/${DEPLOYMENT_ENVIRONMENT}"
	refresh_global ${DEPLOYMENT_SITE} ${DEPLOYMENT_ENVIRONMENT}
	exit 0
}

cmd_refresh_site() {
	must_be_in_an_environment
	echo "Refreshing site definitions for ${DEPLOYMENT_SITE}/${DEPLOYMENT_ENVIRONMENT}"
	refresh_site ${DEPLOYMENT_SITE} ${DEPLOYMENT_ENVIRONMENT}
	exit 0
}

cmd_refresh_all() {
	must_be_in_an_environment
	echo "Refreshing site definitions for ${DEPLOYMENT_SITE}/${DEPLOYMENT_ENVIRONMENT}"
	refresh_site   ${DEPLOYMENT_SITE} ${DEPLOYMENT_ENVIRONMENT}
	echo "Refreshing global definitions for ${DEPLOYMENT_SITE}/${DEPLOYMENT_ENVIRONMENT}"
	refresh_global ${DEPLOYMENT_SITE} ${DEPLOYMENT_ENVIRONMENT}
	exit 0
}

cmd_refresh_makefile() {
	must_be_in_an_environment
	echo "Refreshing Makefile for ${DEPLOYMENT_SITE}/${DEPLOYMENT_ENVIRONMENT}"
	create_makefile "${DEPLOYMENT_ENV_DIR}/Makefile"
}

cmd_refresh_readmes() {
	setup
	echo "Refreshing README for the whole repository"
	rm -f ${DEPLOYMENT_ROOT}/README*
	create_root_readme >${DEPLOYMENT_ROOT}/README.md

	echo "Refreshing README for global definitions"
	create_global_readme >${DEPLOYMENT_ROOT}/global/README
	for site in $(all_sites); do
		echo "  Refreshing README for site '${site}'"
		create_site_readme ${site} >${DEPLOYMENT_ROOT}/${site}/README
		for env in $(all_environments_for ${site}); do
			echo "    Refreshing README for environment '${site}/${env}'"
			create_environment_readme ${site} ${env} >${DEPLOYMENT_ROOT}/${site}/${env}/README
		done
	done
}

bad_refresh() {
	local arg=${1}
	cat >&2 <<EOF
USAGE: genesis refresh (all|global|site|makefile|readme)

Refreshes the global and/or site definitions inside of a single environment,
by copying in the definitions from upstream.

The argument 'makefile' only rebuilds the Makefile for an environment,
which can be useful to bring old deployments in-line with newer versions
of Genesis.

Similarly, 'readme' only recreates the various README files for the top-level,
the global/ directories, and all sites and environments.
EOF
	exit 1
}

cmd_deploy() {
	must_be_in_an_environment
	case ${DEPLOYMENT_TYPE} in
	(normal)
		(VAULT_ADDR= REDACT=y cmd_build manifest.yml) || exit 3
		(            REDACT=  cmd_build .deploy.yml)  || exit 4
		[[ -n $DEBUG_LEAVE_THE_CREDS_THERE ]] || \
			trap "rm -f ${DEPLOYMENT_ENV_DIR}/manifests/.deploy.yml" QUIT TERM INT EXIT

		bosh -d ${DEPLOYMENT_ENV_DIR}/manifests/.deploy.yml deploy
		exit $?
		;;

	(bosh-init)
		(VAULT_ADDR= REDACT=y cmd_build manifest.yml) || exit 3
		(            REDACT=  cmd_build .deploy.yml)  || exit 4
		[[ -n $DEBUG_LEAVE_THE_CREDS_THERE ]] || \
			trap "rm -f ${DEPLOYMENT_ENV_DIR}/manifests/.deploy.yml" QUIT TERM INT EXIT

		if [[ ! -f "${DEPLOYMENT_ENV_DIR}/manifests/.deploy-state.json" ]]; then
			echo "No existing genesis-created bosh-init statefile detected. Please help genesis find it."
			read -e -p "Path to existing bosh-init statefile (leave blank for new deployments): " statefile
			while [[ -n "${statefile}" && ! -f "${statefile}" ]]; do
				echo "Invalid path."
				read -e -p "Path to existing bosh-init statefile (leave blank for new deployments): " statefile
			done
			if [[ -n "${statefile}" ]]; then
				mv "${statefile}" ${DEPLOYMENT_ENV_DIR}/manifests/.deploy-state.json
			fi
		fi

		bosh-init deploy ${DEPLOYMENT_ENV_DIR}/manifests/.deploy.yml
		exit $?
		;;
	esac
}

cmd_embed() {
	echo "Embedding genesis script into repository"
	setup

	mkdir -p ${DEPLOYMENT_ROOT}/bin
	cp ${BASH_SOURCE[0]} ${DEPLOYMENT_ROOT}/bin/genesis

	${DEPLOYMENT_ROOT}/bin/genesis version
}

ci_environment_type() {
  local site=${1:?ci_environment_type() - no site given}
  local env=${2:?ci_environment_type() - no environment given}

  local alpha=$(spruce json ${DEPLOYMENT_ROOT}/.ci.yml | jq -r ".alpha")
  if [[ "${site}/${env}" == $alpha ]]; then
    echo "alpha"
    return
  fi

  local beta=$(spruce json ${DEPLOYMENT_ROOT}/.ci.yml | jq -r ".sites[\"${site}\"].beta")
  if [[ "${env}" == $beta ]]; then
    echo "beta"
    return
  fi

  # otherwise, is it automatically updatable?
  local auto=$(spruce json ${DEPLOYMENT_ROOT}/.ci.yml | jq -r ".sites[\"${site}\"].auto[\"${env}\"] // \"\"")
  if [[ -n ${auto} ]]; then
    echo "gamma"
  else
    echo "omega"
  fi
}

ci_alpha_environment() {
	spruce json ${DEPLOYMENT_ROOT}/.ci.yml | jq -r ".alpha"
}

ci_beta_environment_for() {
  local site=${1:?ci_beta_environment_for() - no site given}
  local env=$(spruce json ${DEPLOYMENT_ROOT}/.ci.yml | jq -r ".sites[\"${site}\"].beta // \"\"")
  if [[ -n ${env} ]]; then
    echo "${site}/${env}"
  fi
}

ci_gamma_environments_for() {
  local site=${1:?ci_gamma_environments_for() - no site given}
  local beta=$(ci_beta_environment_for ${site})
  local alpha=$(ci_alpha_environment)
  for env in $(all_environments_for $site); do
    if [[ "${site}/${env}" == "${beta}" || "${site}/${env}" == "${alpha}" ]] ; then continue ; fi
    local auto=$(spruce json ${DEPLOYMENT_ROOT}/.ci.yml | jq -r ".sites[\"${site}\"].auto[\"${env}\"] // \"\"")
    if [[ -n ${auto} ]]; then
      echo ${site}/${env}
    fi
  done
}

ci_name() {
  tr / - <<<"$1"
}

ci_check_configuration() {
	setup
	local rc=0

	mkdir -p ${DEPLOYMENT_ROOT}/ci
	if [[ ! -f ${DEPLOYMENT_ROOT}/ci/boshes.yml ]]; then
		cat >${DEPLOYMENT_ROOT}/ci/boshes.yml <<EOF
---
auth: (( param "Please define your BOSH directors in ci/boshes.yml (and remove this line)" ))

# BOSH directors are specified by \`url: username / password\`
# (just like in ~/.bosh_config's auth section), i.e.:
#
#auth:
#  https://ip.ad.dr.ess:25555:
#    username: admin
#    password: (( vault "this/should/probably/be/in/vault" ))
#
EOF
	fi
	if [[ ! -f ${DEPLOYMENT_ROOT}/ci/settings.yml ]]; then
		cat >${DEPLOYMENT_ROOT}/ci/settings.yml <<EOF
--- {}
# This is where you will configure your Genesis CI deployment pipeline
# (everything goes under 'meta')
#
#meta:
#  # This is the name of your pipeline
#  name: Pipeline Name
#
#  # A map of name:value environment variables
#  # that will be made available to the script
#  env: {}
#
#  github:
#    owner: github-user
#    repo:  repository-name
#
#    private_key: |
#      ssh-private-key
#      (PEM-encoded)
#
#    # Optional branch to track for changes.
#    # (defaults to "master")
#    #branch: master
#
#  slack:
#    webhook: https://slack/web/hook/url
#    channel: '#name' # or '@user'
#
#    # Optional name/icon to use for posting the notification.
#    #username: runwaybot
#    #icon: http://ip.ad.dr.ess/of/icon.gif
#
EOF
	fi

	local alpha=""
	ensure_ci_configuration
	for site in $(all_sites); do
		local beta=""
		local numenvs=0
		for env in $(all_environments_for ${site}); do
			local type="$(ci_environment_type ${site} ${env})"
			case ${type} in
			(alpha)
				if [[ -n "${alpha}" ]]; then
					echo >&2 "Multiple alpha environments detected: ${alpha} and ${site}/${env}"
					rc=1
				fi
				alpha="${site}/${env}"
				;;

			(beta)
				if [[ -n "${beta}" ]]; then
					echo >&2 "Multiple beta environments detected for ${site}: ${beta} and ${site}/${env}."
					rc=1
				fi
				beta="${site}/${env}"
				;;
			(*)
				numenvs=$(( numenvs + 1 ))
				;;
			esac
		done

		if [[ -z "${beta}" && $numenvs -gt 0 ]]; then
			echo >&2 "No beta environment found for ${site}."
			rc=1
		fi
	done

	if [[ -z "${alpha}" ]]; then
		echo >&2 "No alpha environment found."
		rc=1
	fi

	if [[ $rc -ne 0 ]]; then
		echo >&2 "Configuration issues with CI found.  Please address the above."
		exit 1
	fi
}

ci_update() {
	# emulate:
	#   echo "some: change" | spruce merge -i ${DEPLOYMENT_ROOT}/.ci.yml

	ensure_ci_configuration

	need_a_workdir
	cat > ${WORKDIR}/update.yml
	ensure_yaml_file ${WORKDIR}/update.yml

	if spruce merge "$@" ${DEPLOYMENT_ROOT}/.ci.yml ${WORKDIR}/update.yml > ${WORKDIR}/.ci.yml; then
		mv ${WORKDIR}/.ci.yml ${DEPLOYMENT_ROOT}/.ci.yml
	fi
}

need_ci_git_access() {
	[ -z ${GIT_USERNAME} ] && GIT_USERNAME="Concourse Bot"
	[ -z ${GIT_EMAIL}    ] && GIT_EMAIL="concourse@$(hostname -f)"
	if [[ -z $(git config --global user.email) ]]; then
		git config --global user.email ${GIT_EMAIL}
	fi
	if [[ -z $(git config --global user.name) ]]; then
		git config --global user.name ${GIT_USERNAME}
	fi

	if [[ ! -f ~/.ssh/key && -n ${CI_PRIVATE_KEY} ]]; then
		mkdir -p ~/.ssh
		cat > ~/.ssh/key <<EOF
${CI_PRIVATE_KEY}
EOF
		chmod 0400 ~/.ssh/key
		eval $(ssh-agent) >/dev/null 2>&1
		trap "kill $SSH_AGENT_PID" 0

		cat >~/.ssh/askpass <<EOF
#!/bin/sh
echo "Looks like there is something wrong with your SSH private key (for accessing the repository)" >&2
exit 1
EOF
		chmod 0755 ~/.ssh/askpass
		SSH_ASKPASS=~/.ssh/askpass DISPLAY= ssh-add ~/.ssh/key >/dev/null
	fi

	if [[ ! -f ~/.ssh/config ]]; then
		mkdir -p ~/.ssh
		cat > ~/.ssh/config <<EOF
StrictHostKeyChecking no
LogLevel quiet
EOF
		chmod 0600 ~/.ssh/config
	fi
}

ci_commit() {
	local msg=${1:?ci_commit() - no commit message given}
	if [[ -n $(git status --porcelain) ]]; then
		need_ci_git_access
		git add -A
		git status
		git --no-pager diff --cached
		git commit -m "${msg}"
	fi
}

cmd_ci_alpha() {
	setup
	local site_env=${1}
	if [[ -z "${site_env}" ]]; then
		must_be_in_an_environment
		site_env="${DEPLOYMENT_SITE}/${DEPLOYMENT_ENVIRONMENT}"
	fi

	check_environment $site_env
	local site=${site_env%%/*}
	local env=${site_env##*/}
	ci_update <<EOF
---
alpha: ${site_env}
sites:
  ${site}:
    auto:
      ${env}: y
EOF
}

cmd_ci_beta() {
	setup
	if [[ $# -eq 0 ]]; then
		must_be_in_an_environment
		set -- "${DEPLOYMENT_SITE}/${DEPLOYMENT_ENVIRONMENT}"
	fi
	for site_env in "$@"; do
		check_environment $site_env
		local site=${site_env%%/*}
		local env=${site_env##*/}
		ci_update <<EOF
---
sites:
  ${site}:
    beta: ${env}
    auto:
      ${env}: y
EOF
	done
}

cmd_ci_auto() {
	setup
	if [[ $# -eq 0 ]]; then
		must_be_in_an_environment
		set -- "${DEPLOYMENT_SITE}/${DEPLOYMENT_ENVIRONMENT}"
	fi
	for site_env in "$@"; do
		check_environment $site_env
		local site=${site_env%%/*}
		local env=${site_env##*/}
		ci_update <<EOF
---
sites:
  ${site}:
    auto:
      ${env}: y
EOF
	done
}

cmd_ci_manual() {
	setup
	if [[ $# -eq 0 ]]; then
		must_be_in_an_environment
		set -- "${DEPLOYMENT_SITE}/${DEPLOYMENT_ENVIRONMENT}"
	fi
	rc=0
	for site_env in "$@"; do
		check_environment $site_env
		local site=${site_env%%/*}
		local env=${site_env##*/}
		case "$(ci_environment_type ${site} ${env})" in
		(alpha)
			cat >&2 <<EOF
${site}/${env} is currently the Alpha CI environment.

Alpha environments are automatically updated in response to changes made to global/,
new BOSH releases, stemcells, etc.

If you want to require manual approval for updates to ${site}/${env},
please first select a different Alpha environment.
EOF
			exit 2
			;;

		(beta)
			cat >&2 <<EOF
${site}/${env} is currently the Beta CI environment for ${site}.

Beta environments are automatically updated in response to changes made to global/,
${site}/site/, new BOSH releases, stemcells, etc.

If you want to require manual approval for updates to ${site}/${env},
please first select a different Beta environment for ${site}.
EOF
			exit 2
			;;
		esac
		ci_update --prune "sites[${site}].auto[${env}]" </dev/null
	done
}

ci_repipe_proto_job() {
  local job_name=${1:?ci_repipe_proto_job() - no job name given}

  cat <<EOF
jobs:
  - name: ${job_name}
    public: true
    serial: true
    plan:
      - aggregate:
          - get: world-changes
            resource: (( param "looks like genesis forgot to override the resource name" ))
          - get: local-changes
            resource: (( param "looks like genesis forgot to override the resource name" ))
      - task: (( param "looks like genesis forgot to override the task name" ))
        config:
          platform: linux
          image_resource:
            type: docker-image
            source:
              repository: starkandwayne/concourse
              tag: latest
          inputs:
            - name: world-changes
            - name: local-changes
          outputs:
            - name: out
          run:
            path: world-changes/bin/genesis
            args: [ci, stage1]
          params:
            .: (( inject meta.env ))

            VAULT_APP_ID:   concourse
            VAULT_USER_ID:  (( concat meta.name "-pipeline" ))

            CI_SITE_ENV:    (( param "looks like genesis forgot to override the CI_SITE_ENV variable" ))
            CI_BRANCH:      (( grab resources.git.source.branch ))
            CI_PRIVATE_KEY: (( grab resources.git.source.private_key ))

            LOCAL_CHANGES:  local-changes
            WORLD_CHANGES:  world-changes
            WORKING_DIR:    out/git

            CI_BOSHES: |
EOF
  need_a_vault
  spruce merge ${DEPLOYMENT_ROOT}/ci/boshes.yml | sed -e 's/^/              /' || exit $?
}

ci_repipe_build_base() {
  need_a_workdir

  cat >${WORKDIR}/pipeline.yml <<EOF
---
meta:
  name: (( param "Please name this deployment pipeline (in ci/settings.yml)" ))
  env: {}

  github:
    uri:          (( concat "git@github.com:" meta.github.owner "/" meta.github.repo ))
    owner:        (( param "Please specify the name of the user / organization that owns the Github repository (in ci/settings.yml)" ))
    repo:         (( param "Please specify the name of the Github repository (in ci/settings.yml)" ))
    branch:       master
    private_key:  (( param "Please generate an SSH Deployment Key for this repo and specify it in ci/settings.yml" ))

  slack:
    webhook:  (( param "Please provide a Slack Integration WebHook (in ci/settings.yml)" ))
    channel:  (( param "Please specify the channel (#name) or user (@user) to send messages to (in ci/settings.yml)" ))
    username: runwaybot
    icon:     http://cl.ly/image/3e1h0H3H2s0P/concourse-logo.png

resources:
  - name: git
    type: git
    source:
      uri:         (( grab meta.github.uri ))
      branch:      (( grab meta.github.branch ))
      private_key: (( grab meta.github.private_key ))

  - name: notification
    type: slack-notification
    source:
      url:      (( grab meta.slack.webhook ))



resource_types:
  - name: slack-notification
    type: docker-image
    source:
      repository: cfcommunity/slack-notification-resource

groups:
  - name: '*'
    jobs:
      - stemcells

  - name: upkeep
    jobs:
      - stemcells

jobs:
  - name: stemcells
    public: true
    serial: true
    plan:
      - aggregate:
        - get: git
      - task: update
        config:
          inputs:
            - name: git
          outputs:
            - name: out
          platform: linux
          image_resource:
            type: docker-image
            source:
              repository: starkandwayne/concourse
          run:
            path: git/bin/genesis
            args: [ ci, stemcells ]
          params:
            STEMCELLS: stemcells
            REPO_OUT:  out/git
      - put: git
        params:
          rebase: true
          repository: out/git
EOF
}

ci_repipe_build_environments() {
  local alpha_env=$(ci_alpha_environment)
  local alpha_name=$(ci_name ${alpha_env})
  local alpha_site=${alpha_env%%/*}

  need_a_workdir
  workdir="${WORKDIR}/repipe"
  mkdir -p ${workdir}
  cat <<EOF >${workdir}/09-all.yml
---
groups:
  - name: '*'
    jobs:
      - (( append ))
EOF
  cat <<EOF >${workdir}/08-groups.yml
---
groups:
  - name: '*'
  - name: 
    jobs:
      - $alpha_name

  - name: 
    jobs:
      - $alpha_name
EOF

  local rc=0
  for site in $(all_sites); do
    if [[ ! -f ${DEPLOYMENT_ROOT}/${site}/site/stemcell/name ]]; then
      echo >&2 "Site ${site} has no defined stemcell"
      rc=1
    fi
  done
  if [[ $rc -ne 0 ]]; then
    exit $rc
  fi


  for site in $(all_sites); do
    local site_name=$(ci_name ${site})
    local beta_env=$(ci_beta_environment_for ${site})
    local beta_name=$(ci_name ${beta_env})

    if [[ -n ${beta_name} ]]; then
      echo "      - ${beta_name}" >> ${workdir}/08-groups.yml
    fi

    local stemcell_alias=
    local stemcell_name=$(cat ${DEPLOYMENT_ROOT}/${site}/site/stemcell/name 2>/dev/null)
    case $stemcell_name in
    (*vsphere*) stemcell_alias=vsphere-stemcell ;;
    (*aws*hvm*) stemcell_alias=aws-hvm-stemcell ;;
    (*aws*)     stemcell_alias=aws-stemcell     ;;
    (*warden*)  stemcell_alias=warden-stemcell  ;;
    ("")        stemcell_alias=empty            ;;
    (*)         stemcell_alias=${stemcell_name} ;;
    esac
    cat >${workdir}/77-${stemcell_alias}.yml <<EOF
---
resources:
  - name: ${stemcell_alias}
    type: bosh-io-stemcell
    source: { name: ${stemcell_name} }

jobs:
  - name: stemcells
    plan:
      - (( inline ))
      - aggregate:
        - (( append ))
        - get: ${stemcell_alias}
          trigger: true
          params: { tarball: true }
      - task: update
        config:
          inputs:
            - (( append ))
            - name: ${stemcell_alias}
              path: stemcells/${stemcell_name}
EOF

    if [[ -n ${beta_name} ]]; then
      cat >${workdir}/10-${site}.yml <<EOF
---
groups:
  - name: $site_name
    jobs:
      - $alpha_name # alpha
      - $beta_name  # beta
EOF
    fi

    for env in $(all_environments_for ${site}); do
      local env_type=$(ci_environment_type ${site} ${env})
      local env_name=$(ci_name ${env})
      local site_env=${site}/${env}
      local site_env_name=$(ci_name ${site_env})

      cat >>${workdir}/09-all.yml <<EOF
      - $site_env_name
EOF

      ci_repipe_proto_job ${site_env_name} > ${workdir}/50-${site_env_name}.yml || exit 5
      case ${env_type} in
      (alpha)
        cat >${workdir}/51-${site_env_name}.yml <<EOF
---
resources:
  # changes that trigger the alpha environment

  ##########################################################################
  #
  #   global-changes      Changes made to the global/ definitions,
  #                       (and the alpha environment's site, for continuity)
  #
  - name: global-changes
    .: (( inject resources.git ))
    source:
      paths:
        - bin/genesis
        - global

  ##########################################################################
  #
  #   {env}-changes     Changes that only affect the current environment
  #                     (i.e. property changes, re-IPing, creds, etc.)
  #
  - name: ${alpha_name}-changes
    .: (( inject resources.git ))
    source:
      paths:
        - ${alpha_site}/site
        - ${alpha_env}/*.yml

  ##########################################################################
  #
  #   -changes         Changes that come from previous steps in the
  #                     pipeline, from a successful build in alpha.
  #                     (this will trigger beta builds)
  #
  - name: -changes
    .: (( inject resources.git ))
    source:
      paths:
        - ${alpha_env}/.global

jobs:
  # alpha environment
  - name: ${site_env_name}
    plan:
      - (( inline ))
      - aggregate:
        - (( merge on get ))

        - get: world-changes
          resource: global-changes
          trigger: true

        - get: local-changes
          resource: ${alpha_name}-changes
          trigger: true

      - task: ${site_env_name}
        config:
          params:
            CI_SITE_ENV: ${site_env}
        # PUT to the beta inputs
      - put: -changes
        params: { repository: out/git }
EOF
        ;;

      (beta)
        cat >${workdir}/51-${site_env_name}.yml <<EOF
---
resources:
  # changes that trigger the beta environment

  ##########################################################################
  #
  #   {site}-changes    Changes that only affect the current environment
  #                     (i.e. property changes, re-IPing, creds, etc.)
  #
  - name: ${site}-changes
    .: (( inject resources.git ))
    source:
      paths:
        - ${site}/site
        - ${beta_env}/*.yml

  ##########################################################################
  #
  #   {site}--changes  Changes that come from previous steps in the
  #                     pipeline, from a successful build in alpha.
  #
  - name: ${site}--changes
    .: (( inject resources.git ))
    source:
      paths:
        - ${beta_env}/.site
        - ${beta_env}/.global

jobs:
  # beta environment
  - name: ${site_env_name}
    plan:
      - (( inline ))
      - aggregate:
        - (( merge on get ))

        - get: world-changes
          resource: -changes
          trigger: true
          passed: [${alpha_name}]

        - get: local-changes
          resource: ${site}-changes
          trigger: true

      - task: ${site_env_name}
        config:
          params:
            CI_SITE_ENV: ${site_env}
        # PUT to the gamma inputs
      - put: ${site}--changes
        params: { repository: out/git }
EOF
        ;;

      (gamma)
        cat >>${workdir}/10-${site}.yml <<EOF
      - $site_env_name # gamma
EOF
        cat >${workdir}/51-${site_env_name}.yml <<EOF
---
resources:
  # changes that trigger the gamma environment

  ##########################################################################
  #
  #   {env}-changes     Changes that only affect the current environment
  #                     (i.e. property changes, re-IPing, creds, etc.)
  #
  - name: ${site_env_name}-changes
    .: (( inject resources.git ))
    source:
      paths:
        - ${site_env}/*.yml

jobs:
  # gamma environment
  - name: ${site_env_name}
    plan:
      - (( inline ))
      - aggregate:
        - (( merge on get ))

        - get: world-changes
          resource: ${site}--changes
          trigger: true
          passed: [${beta_name}]

        - get: local-changes
          resource: ${site_env_name}-changes
          trigger: true

      - task: ${site_env_name}
        config:
          params:
            CI_SITE_ENV: ${site_env}
        # PUT to git
      - put: git
        params: { repository: out/git }
EOF
        ;;

      (omega)
        cat >>${workdir}/09-all.yml <<EOF
      - ${site_env_name}-notif
EOF
        cat >>${workdir}/10-${site}.yml <<EOF
      - $site_env_name # omega
      - ${site_env_name}-notif
EOF
        cat >${workdir}/51-${site_env_name}.yml <<EOF
---
resources:
  # changes that trigger the omega environment

  ##########################################################################
  #
  #   {env}-changes     Changes that only affect the current environment
  #                     (i.e. property changes, re-IPing, creds, etc.)
  #
  - name: ${site_env_name}-changes
    .: (( inject resources.git ))
    source:
      paths:
        - ${site_env}/*.yml

jobs:
  # omega environment
  - name: ${site_env_name}-notif
    plan:
      - aggregate:
        - get: world-changes
          resource: ${site}--changes
          passed: [${beta_name}]
          trigger: true

        - get: local-changes
          resource: ${site_env_name}-changes
          trigger: true

      - task: draft-message
        config:
          platform: linux
          image_resource:
            type: docker-image
            source:
              repository: starkandwayne/concourse
              tag: latest
          inputs:
            - name: world-changes
            - name: local-changes
          outputs:
            - name: out
          run:
            path: world-changes/bin/genesis
            args: [ci, draft-message]
          params:
            LOCAL_CHANGES:  local-changes
            WORLD_CHANGES:  world-changes
            CI_SITE_ENV:    ${site_env}
            DRAFT_FILE:     out/notif
      - put: notification
        params:
          text_file: out/notif
          username: (( grab meta.slack.username ))
          channel:  (( grab meta.slack.channel ))
          icon_url: (( grab meta.slack.icon ))

  - name: ${site_env_name}
    plan:
      - (( inline ))
      - aggregate:
        - (( merge on get ))

        - get: world-changes
          resource: ${site}--changes
          passed: [${site_env_name}-notif]
          trigger: false

        - get: local-changes
          resource: ${site_env_name}-changes
          passed: [${site_env_name}-notif]
          trigger: false

      - task: ${site_env_name}
        config:
          params:
            CI_SITE_ENV: ${site_env}
        # PUT to git
      - put: git
        params: { repository: out/git }
EOF
        ;;
      esac
    done
  done
}

ci_repipe_merge() {
	target=${1:-pipeline.yml}
	mkdir -p ${DEPLOYMENT_ROOT}/ci

	need_command spruce
	spruce $SPRUCE_OPTS merge --prune meta \
	    ${WORKDIR}/pipeline.yml \
	    ${WORKDIR}/repipe/*.yml \
	    $(actual_yaml_files ${DEPLOYMENT_ROOT}/ci/settings.yml) > ${DEPLOYMENT_ROOT}/ci/${target}
}

cmd_ci_repipe() {
	setup
	ci_check_configuration
	need_a_workdir
	need_a_vault

	ci_repipe_build_base
	ci_repipe_build_environments || exit 2
	VAULT_ADDR= REDACT=y ci_repipe_merge pipeline.yml || exit 3
	            REDACT=  ci_repipe_merge .deploy.yml  || exit 4
	[[ -n $DEBUG_LEAVE_THE_CREDS_THERE ]] || \
		trap "rm -f ${DEPLOYMENT_ROOT}/ci/.deploy.yml" QUIT TERM INT EXIT

	CI_TARGET_NAME=$(spruce json ${DEPLOYMENT_ROOT}/ci/settings.yml | jq -r '.meta.target // ""')
	CI_PIPELINE=$(   spruce json ${DEPLOYMENT_ROOT}/ci/settings.yml | jq -r '.meta.name // ""')

	echo
	echo "Configuring pipeline at ${CI_TARGET_NAME} (${CI_TARGET_URL})"
	fly -t ${CI_TARGET_NAME:-concourse} set-pipeline -p ${CI_PIPELINE:-pipeline} -c ${DEPLOYMENT_ROOT}/ci/.deploy.yml
	exit $?
}


cmd_ci_flow() {
	setup
	# FIXME: ascii diagram!
	cat ${DEPLOYMENT_ROOT}/.ci.yml
}

cmd_ci_stemcells() {
	if [[ -z ${STEMCELLS} ]]; then
		echo >&2 "!! ERROR: Your Concourse Pipeline seems to be MISCONFIGURED !!"
		echo >&2
		echo >&2 "The \$STEMCELLS environment variable was not set."
		echo >&2
		echo >&2 "This environment variable tells genesis where to find the"
		echo >&2 "downloaded stemcells, for checksumming and version querying."
		exit 2
	fi
	if [[ ! -d ${STEMCELLS} ]]; then
		echo >&2 "!! ERROR: Your Concourse Pipeline seems to be MISCONFIGURED !!"
		echo >&2
		echo >&2 "The \$STEMCELLS environment variable seems to be incorrect."
		echo >&2
		echo >&2 "Failed to find stemcell path '${STEMCELLS}',"
		echo >&2 "starting from '$(pwd)'..."
		exit 2
	fi

	REPO_IN=$(cd $(dirname $BASH_SOURCE[0])/..; pwd)
	for dir in ${STEMCELLS}/*; do
		local name=${dir##*/}
		local vers=$(cat ${dir}/version)
		local sha1=$(cat ${dir}/stemcell.tgz | sha1sum | awk '{print $1}')

		pushd ${REPO_IN} >/dev/null
			for site in */site; do
				if [[ $(cat ${site}/stemcell/name 2>/dev/null) == ${name} ]]; then
					echo ${vers} > ${site}/stemcell/version
					echo ${sha1} > ${site}/stemcell/sha1
				fi
			done
		popd >/dev/null
	done

	pushd ${REPO_IN} >/dev/null
		ci_commit "upgrade stemcells via pipeline"
	popd >/dev/null
	[ -n ${REPO_OUT} ] && cp -a ${REPO_IN} ${REPO_OUT}/
	exit 0
}

cmd_ci_stage1() {
	if [[ -z ${WORKING_DIR} ]]; then
		echo >&2 "!! ERROR: Your Concourse Pipeline seems to be MISCONFIGURED !!"
		echo >&2
		echo >&2 "The \$WORKING_DIR environment variable was not set."
		echo >&2
		echo >&2 "This environment variable tells genesis where to find the"
		echo >&2 "committed changes to this deployment manifest, so that Concourse"
		echo >&2 "can push the updatees back to origin properly."
		exit 2
	fi

	cp -a ${LOCAL_CHANGES} ${WORKING_DIR}
	if [[ ! -d ${WORKING_DIR} ]]; then
		echo >&2 "Failed to copy the git working copy from"
		echo >&2 "${LOCAL_CHANGES}"
		echo >&2 "to"
		echo >&2 "${WORKING_DIR}"
		echo >&2
		exit 2
	fi

	line
	echo "Pulling in latest copy of ${CI_BRANCH}"
	echo "(this avoids spurious git conflicts later)"
	echo
	pushd ${WORKING_DIR}/${CI_SITE_ENV} >/dev/null
		need_ci_git_access
		git pull origin ${CI_BRANCH} # in case we want to test...
	popd

	line
	echo "Invoking stage2 of the Genesis CI pipeline"
	echo
	exec ${WORKING_DIR}/bin/genesis ci stage2
}

cmd_ci_stage2() {
	line
	echo "Setting up .bosh_config with values from ci/boshes.yml"
	echo
	cat >~/.bosh_config<<EOF
${CI_BOSHES}
EOF
	ls -l ~/.bosh_config
	echo

	line
	echo "Probing environment for information..."
	# figure out our environment type
	pushd ${WORKING_DIR}/${CI_SITE_ENV} >/dev/null
		CI_SITE=$(setup; must_be_in_an_environment; echo $DEPLOYMENT_SITE)
		CI_ENV=$( setup; must_be_in_an_environment; echo $DEPLOYMENT_ENVIRONMENT)

		local env_type=$(setup; must_be_in_an_environment;
			ci_environment_type ${DEPLOYMENT_SITE} ${DEPLOYMENT_ENVIRONMENT})

		local alpha_env=$(setup; must_be_in_an_environment;
			ci_alpha_environment)

		local beta_env=$(setup; must_be_in_an_environment;
			ci_beta_environment_for ${CI_SITE})
	popd
	echo "        CI_SITE_ENV: ${CI_SITE_ENV}"
	echo "            CI_SITE: ${CI_SITE}"
	echo "             CI_ENV: ${CI_ENV}"
	echo "   Environment Type: ${env_type}"
	echo "  Alpha Environment: ${alpha_env}"
	echo "   Beta Environment: ${beta_env}"
	echo

	line
	echo "Updating .site and .global copies from known good values"

	rm -rf ${WORKING_DIR}/${CI_SITE_ENV}/.global
	rm -rf ${WORKING_DIR}/${CI_SITE_ENV}/.site
	case ${env_type} in
	(alpha)
		echo "... in ALPHA environment"
		echo
		echo "copy world/global -> ${CI_SITE_ENV}/.global"
		echo "copy local/${CI_SITE}/site -> ${CI_SITE_ENV}/.site"
		echo
		cp -a ${WORLD_CHANGES}/global                ${WORKING_DIR}/${CI_SITE_ENV}/.global
		cp -a ${LOCAL_CHANGES}/${CI_SITE}/site       ${WORKING_DIR}/${CI_SITE_ENV}/.site
		;;
	(beta)
		echo "... in BETA environment"
		echo
		echo "copy world/${alpha_env}/.global -> ${CI_SITE_ENV}/.global"
		echo "copy world/${CI_SITE}/site -> ${CI_SITE_ENV}/.site"
		echo
		cp -a ${WORLD_CHANGES}/${alpha_env}/.global  ${WORKING_DIR}/${CI_SITE_ENV}/.global
		cp -a ${WORLD_CHANGES}/${CI_SITE}/site       ${WORKING_DIR}/${CI_SITE_ENV}/.site
		;;
	(*)
		echo
		echo "copy world/${beta_env}/.global -> ${CI_SITE_ENV}/.global"
		echo "copy world/${beta_env}/.site -> ${CI_SITE_ENV}/.site"
		cp -a ${WORLD_CHANGES}/${beta_env}/.global   ${WORKING_DIR}/${CI_SITE_ENV}/.global
		cp -a ${WORLD_CHANGES}/${beta_env}/.site     ${WORKING_DIR}/${CI_SITE_ENV}/.site
		;;
	esac

	pushd ${WORKING_DIR}/${CI_SITE_ENV} >/dev/null
		setup
		must_be_in_an_environment

		line
		echo "Generating manifest (live.yml)..."
		echo
		set -e
		need_a_vault
		(VAULT_ADDR= REDACT=y cmd_build live.yml)    || exit 3
		(            REDACT=  cmd_build .deploy.yml) || exit 4

		local target=$(spruce json ${DEPLOYMENT_ENV_DIR}/manifests/live.yml | jq -r '.director_uuid')
		line
		echo "Deploying to BOSH director ${target}"
		echo
		bosh target ${target}
		bosh deployment ${DEPLOYMENT_ENV_DIR}/manifests/.deploy.yml
		bosh -n deploy

		line
		echo "Committing changes to git repository..."
		echo
		if [[ -z ${GIT_MESSAGE} ]]; then
			GIT_MESSAGE="[${CI_SITE_ENV}] deployed via pipeline"
		fi
		ci_commit "${GIT_MESSAGE}"
		set +e
	popd >/dev/null

	line
	echo "COMPLETE"

	exit 0
}

cmd_ci_draft_message() {
	(
		echo "[${CI_SITE_ENV}] Deployment changes are ready to go!"
		echo
		echo "World:"
		echo "\`\`\`"
		(cd $WORLD_CHANGES && git log -n1)
		echo "\`\`\`"
		echo
		echo "Local:"
		echo "\`\`\`"
		(cd $LOCAL_CHANGES && git log -n1)
		echo "\`\`\`"
	)>${DRAFT_FILE}
}

cmd_ci_check() {
	ci_check_configuration
}

bad_ci() {
	local cmd=${1}
	cat >&2 <<EOF
USAGE:  genesis ci alpha [site/env]
        genesis ci beta [site/env [site/env ...]]
        genesis ci auto [site/env [site/env ...]]
        genesis ci manual [site/env [site/env ...]]
        genesis ci repipe [target-concourse]
        genesis ci flow
EOF
	exit 1
}

cmd_bosh() {
	must_be_in_an_environment

	case ${DEPLOYMENT_TYPE} in
	(normal)
		(REDACT= cmd_build .deploy.yml) || exit 3
		[[ -n $DEBUG_LEAVE_THE_CREDS_THERE ]] || \
			trap "rm -f ${DEPLOYMENT_ENV_DIR}/manifests/.deploy.yml" QUIT TERM INT EXIT

		bosh -d ${DEPLOYMENT_ENV_DIR}/manifests/.deploy.yml $@
		exit $?
		;;

	(bosh-init)
		echo >&2 "BOSH-init deployments do not currently support the \`bosh' command"
		exit 1
		;;
	esac
}

cmd_dump() {
	setup
	printf "name: %s\n" ${DEPLOYMENT_NAME}
	printf "type: %s\n" ${DEPLOYMENT_TYPE}
	printf "root: %s\n" ${DEPLOYMENT_ROOT}
	printf "site: %s\n" ${DEPLOYMENT_SITE}
	printf "env:  %s\n" ${DEPLOYMENT_ENVIRONMENT}
	exit 0
}

bad_command() {
	local cmd=${1}
	cat >&2 <<EOF
Unrecognized sub-command: '$cmd'

Try one of these:

   genesis help
   genesis new (deployment|site|environment)
   genesis build
   genesis refresh (global|site|all|makefile|readme)
   genesis bosh ...

EOF
	exit 1
}

checksum() {
  if [[ -z $(command -v sha1sum) ]]; then
    shasum "$@"
  else
    sha1sum "$@"
  fi
}

####################################################
# multi-call interface

main() {
	local cmd=${1:-help} ; shift

	case ${cmd} in
	(ping)
		exit 0
		;;
	(version|-v|--version)
		s=$(cat ${BASH_SOURCE[0]} | checksum)
		echo "genesis ${VERSION} (${s:0:12})"
		exit 0
		;;
	(help|-h|--help|-?)
		cmd_help $*
		;;
	(new)
		local arg=${1:-} ; shift
		case ${arg} in
		(deployment)
			cmd_new_deployment $*
			;;
		(site)
			cmd_new_site $*
			;;
		(env|environment)
			cmd_new_environment $*
			;;
		(*)
			bad_new ${arg}
			;;
		esac
		;;
	(add)
		local arg=${1:-} ; shift
		case ${arg} in
		(release)
			cmd_add_release $*
			;;
		(*)
			bad_add ${arg}
			;;
		esac
		;;
	(set)
		local arg=${1:-} ; shift
		case ${arg} in
		(release)
			cmd_set_release $*
			;;
		(*)
			bad_set ${arg}
			;;
		esac
		;;
	(use)
		local arg=${1:-} ; shift
		case ${arg} in
		(release)
			cmd_use_release $*
			;;
		(stemcell)
			cmd_use_stemcell $*
			;;
		(*)
			bad_use ${arg}
			;;
		esac
		;;
	(stemcell|stemcells)
		cmd_stemcells $*
		;;
	(release|releases)
		cmd_releases $*
		;;
	(build)
		cmd_build $*
		;;
	(diff)
		cmd_diff $*
		;;
	(refresh)
		local arg=${1:-all} ; shift
		case ${arg} in
		(global)
			cmd_refresh_global $*
			;;
		(site)
			cmd_refresh_site $*
			;;
		(all)
			cmd_refresh_all $*
			;;
		(makefile|makefiles)
			cmd_refresh_makefile $*
			;;
		(readme|readmes)
			cmd_refresh_readmes $*
			;;
		(*)
			bad_refresh ${arg}
			;;
		esac
		;;
	(deploy)
		cmd_deploy
		;;
	(embed)
		cmd_embed
		;;
	(ci)
		TERM=dumb
		local arg=${1:-} ; shift
		case ${arg} in
		(alpha)
			cmd_ci_alpha $*
			;;
		(beta)
			cmd_ci_beta $*
			;;
		(auto)
			cmd_ci_auto $*
			;;
		(manual)
			cmd_ci_manual $*
			;;
		(repipe)
			cmd_ci_repipe $*
			;;
		(flow)
			cmd_ci_flow $*
			;;
		(stemcells)
			cmd_ci_stemcells $*
			;;
		(stage1)
			cmd_ci_stage1 $*
			;;
		(stage2)
			cmd_ci_stage2 $*
			;;
		(draft-message)
			cmd_ci_draft_message $*
			;;
		(check)
			cmd_ci_check
			;;
		(*)
			bad_ci ${arg}
			;;
		esac
		;;
	(dump)
		cmd_dump
		;;
	(bosh)
		cmd_bosh $*
		;;
	(*)
		bad_command ${cmd}
		;;
	esac
}

[ -n "${CI_DEBUG}" ] && set -x
# look for some help flags
declare -a argv
while (( $# != 0 )); do
	case ${1} in
	(-h|-\?|--help) argv=( help ${argv[@]}        ) ;;
	(*)             argv=(      ${argv[@]} "${1}" ) ;;
	esac
	shift
done
set -- ${argv[@]}
main $@

# fin
