#!/usr/bin/env perl
# vim:ft=perl:noet:ts=2:sts=2:sw=2:fdm=marker:fdl=0
use strict;
use warnings;
no warnings 'utf8';
use utf8;

BEGIN {
	delete($ENV{GENESIS_LIB}) if $ENV{GENESIS_LIB} && $ENV{GENESIS_LIB} =~ '\.geese'; # Upgrade protection
}

# Ensure code exits and cleans up workdirs
$SIG{ __DIE__ } = sub {require Carp; $Carp::Verbose=1;  Carp::confess(@_) }
	if ($ENV{GENESIS_DEV_MODE});
$SIG{INT} = $SIG{TERM} = sub {print STDERR "\e[?25h\n";bail("Genesis halted due to user interrupt (Ctrl-C)")};

# core modules

use Encode;
use FindBin;
use lib $ENV{GENESIS_LIB}  ||  $FindBin::Bin.'/lib';
$ENV{GENESIS_LIB}          ||= $FindBin::Bin.'/lib';
$ENV{GENESIS_CALLBACK_BIN} ||= $FindBin::Bin.'/'.$FindBin::Script;

use Genesis;
use Genesis::State;
use Genesis::Config;
use Genesis::Term;
use Genesis::Commands;
use Genesis::Log;

$Genesis::APP = 'genesis';
$Genesis::VERSION = "(development)";
$Genesis::BUILD = "";
Genesis::Init();


### Genesis Core commands {{{
# genesis help - get the basic help page for Genesis {{{
define_command('help', {
		summary => "Displays Genesis help on general usage and specific topics",
		usage => "help [<options...>]",
		function_group => Genesis::Commands::GENESIS,
		options => [
			'all|A' => 'Show all commands, not just the common categories',
		],
		skip_check_prereqs => 1,
		no_vault => 1
}, sub { command_help(); });

# }}}
# genesis version - Print the version of Genesis. {{{
define_command("version", {
		summary => "Print the version of Genesis",
		description =>
			"With no arguments, will print out a human-readable line specifying the ".
			"version, commit hash and build code.  Alternatively, you can ask for ".
			"one or more version components as arguments (listed below), printed ".
			"either on separate lines, or in a json block with the #y{--json} option.",

		function_group => Genesis::Commands::GENESIS,
		skip_check_prereqs => 1,
		arguments => [
			'semver' =>
				"Provide the version in semantic format (dev versions are 0.0.0-rc.0)",

			'is_dev' =>
				"Outputs true if the genesis executable is a dev version, false otherwise",

			'major' =>
				'Provide the major version value (first semantic value)',

			'minor' =>
				"Provide the minor version value (second sematic value)",

			'patch' =>
				"Provide the patch value (third semantic value)",

			'rc' =>
				"Provide the release candidate value, or null if not applicable",

			'is_rc' =>
				"Outputs true if version is a release candidate, false otherwise",

			'build_epoch' =>
				"Build time expressed in epoch (seconds since midnight, Jan 1, 1970 UTC)",

			'build_code' =>
				"Build identifier code",

			'build_date' =>
				"Local time and date of the build for this version of Genesis",

			'commit' =>
				"Provide the git commit hash the verison was based on",

			'is_dirty' =>
				"Outputs true if version was built with uncommitted changes, false otherwise",
		],
		option_group => Genesis::Commands::BLANK_OPTIONS,
		options => [
			'json|j' =>
				"Produce the version components in json format"
		]
		# TODO: add json|j option to get out json info
});

# }}}
# genesis ping - see if the genesis binary is a real thing. {{{
define_command("ping", {
	summary => "Check if genesis binary is present and all dependencies are met",
	function_group => Genesis::Commands::GENESIS,
	no_vault => 1
});
# }}}
# genesis update - update the current version of Genesis {{{
define_command("update", {
	summary => "Downloads a newer version of Genesis or checks if one is available.",
	usage => "update [-c|--check] [-p|--pre] [-v|--version VERSION] [-d|--details] [-f|--force]",
	alias => 'upgrade',
	description => "Updates the current version of genesis",
	function_group => Genesis::Commands::GENESIS,
	skip_check_prereqs => 1,
	no_vault => 1,
	options => [
		"check|c" =>
			"Check if a newer version (or the specified version) is available.",

		"pre|p" =>
			"Include prereleases when searching for available updates.",

		"version|v=s" => { argument => '<semver>', description =>
			"Install the specified version instead of the latest"
		},

		"details|d" =>
			"Print the release notes of the versions between the current version ".
			"and the latest (or the release notes of the specified version)",

		"force|f" =>
			"Replace the current genesis executable.  Otherwise, confirmation will ".
			"be requested."
		],
});


# }}}
# }}}

### Environment Management commands {{{
# genesis create - create a new Genesis deployment environment (YAML file) {{{
define_command("create", {
	summary => "Create a new Genesis deployment environment.",
	usage => "create #M{<env>} [<options...>]",
	alias => 'new',
	description =>
		"Creates a new environment in the current (or specified) deployment ".
		"repository, filled with your answers to questions the kit prompts for, ".
		"and then generates the required secret credentials and certificates.\n".
		"\n".
		"Note: if secrets already exist for an environment under the secrets path ".
		"(see below), you will be prompted to purge them prior to creating the ".
		"new environment.  If you want to keep them, use safe to move them to ".
		"another path, create the new environment, then move back the secrets you ".
		"need to keep.",
	function_group => Genesis::Commands::ENVIRONMENT,
	scope => [qw/repo env/],
	option_group => Genesis::Commands::ENV_OPTIONS,
	arguments => [
		"env" =>
			"The name of the environment, optionally with the .yml suffix"
	],
	options => [
		"create-env!" =>
			"For kits that allow but not require deployment using create-env, this ".
			"will create the environment as indicated.  It will result in an error ".
			"if it conflicts with the deployment methods the kit does support, or ".
			"if the kit is not compatible with v2.8.0 (ie earlier kits) It does not ".
			"have to be specified if the kit only supports one deployment method.",

		"kit|k=s" =>
			"Name (and optionally, version) of the Genesis Kit to use for this ".
			"environment (eg: shield/6.3.0). Defaults to latest.  This kit must be ".
			"locally present (see 'genesis list-kits').  To use the dev kit, ".
			"specify 'dev/latest'",

		"credhub-env=s" =>
			"The name of the credhub deployment (for kits that use credhub).  By ".
			"default, it will use the bosh env as the source of the credhub exodus ".
			"data, which in turn defaults to the deployment environment's name.  If ".
			"the deployment that contains the credhub's exodus data is not a bosh ".
			"deployment, you must also specify the deployment type ".
			"(eg: some-other-env/bucc)",

		"secrets-path|prefix|P=s" =>
			"By default, the secrets path is secret/<env-name>/<kit> where <env-name> ".
			"has had any - converted to / and <kit> is the kit name.  Use this option ".
			"to change the part after 'secret/'",

		"secrets-mount=s" =>
			"If you need secrets stored in another location other than 'secret/', ".
			"you can specify it with this option.  You can specify '/' if your ".
			"secrets provider allows access to the root level, and you can specify a ".
			"deeper subdirectory if you only have access to such a branch.",

		"exodus-mount=s" =>
			"Similar to --secrets-mount, you can specify a different base path for ".
			"the exodus data.  It is highly recommended you do not specify '/' for ".
			"this, nor is it required that it be under the secrets mount location.  ".
			"By default, it will use '<secrets-mount>/exodus/'",

		"ci-mount=s" =>
			"For kits that provide secrets to concourse, this allows to specify an ".
			"alternative location for the base secrets to be put.  By default, it ".
			"is set to the same as secrets mount.",

		"root-ca-path=s" =>
			"Specify a vault path to a root CA certificate that will be used to sign ".
			"all generated certs that don't specify a signatory CA certificate.",

		"vault=s" =>
			"The name of a `safe' target (a Vault) to store newly generated ".
			"credentials in.  Overrides the vault specified in the deployment ".
			"repository for the environment.",

		"force|-f" =>
			"Create a new environment file even if it already exists."
	],
	deprecated_options => [
		"^prefix=s" =>
			"Old name of --secrets-path option.",

		"secrets!" =>
			"Do not generate secrets in the Vault.  You will have to manually run ".
			"`genesis secrets` yourself.  This option is accepted but no longer has ".
			"any effect."
	]
});

# }}}
# genesis edit - edit the environment with the kit manual pages on the side {{{
define_command("edit", {
	summary => "Edit a Genesis deployment environment file, with manual in a side window",
	usage => "<env> edit",
	alias => 'e',
	description =>
		"Open the environment file in your default editor.  If your editor is vim ".
		"or emacs, it will also include the kit's manual pages open in a split window.",
	function_group => Genesis::Commands::ENVIRONMENT,
	scope => ['env'],
	option_group => Genesis::Commands::REPO_OPTIONS,
	options => [
		'editor|e=s' =>
			"Specify the editor to use (defaults to EDITOR env var)\n".
			"Note that only vim and emacs will split screen with the kit manual",

		'kit|k=s' =>
			"Specify the kit/version for displaying the manual.  Used when the ".
			"environment is intending to use a new version, or to override the ".
			"kit specified in the environment file.",

		'manual!' =>
			"Display the kit manual in a split window.  This is the default, but ".
			"can be turned off with this option.".
			"\n".
			"[[Note: >>this option is only valid if the editor is vi-based (vim, ".
			"mvim, etc), emacs, or VSCode (code).",

		'ancestors!' =>
			"If specified, all possible hierarchial files will be opened in the ".
			"split window, even if they don't exist.  If --no-ancestors is specified, ".
			"only the environment file will be opened.  By default, existing ancestor ".
			"files will be opened underneith the environment file in the split window.".
			"\n".
			"[[Note: >>this option is only valid if the editor is vi-based (vim, ".
			"mvim, etc) or VSCode (code)",
	]
});

# }}}
# genesis check - generate the manifest and run the check hook {{{
define_command("check", {
	summary => "Check a deployment manifest for errors, without deploying it.",
	usage => "<env> check [<options...>]",
	description =>
		"Runs checks against the cloud config, environment files and vault secrets ".
		"to determine if a manifest can be successfully built.  Partial checks can ".
		"also be performed as per the options below.  Run with the -q|--quiet flag ".
		"will result in no output except exit-code 0 on success, 1 otherwise.",
	function_group => Genesis::Commands::ENVIRONMENT,
	scope => 'env',
	option_group => Genesis::Commands::ENV_OPTIONS,
	options => [
		'no-config' =>
			"Do not run cloud config tests.",

		'secrets!' =>
			"Determines if the secrets checks are run.\n".
			"Runs by default.",

		'manifest!' =>
			"Determines if the secrets checks are run.\n".
			"Runs by default.",

		'stemcells!' =>
			"Determines if the secrets checks are run.\n".
			"DOES NOT run by default.",
	],
});

# }}}
# genesis manifest - Compile a deployment manifest. {{{
define_command("manifest", {
	summary => "Generate a BOSH deployment manifest for an environment to STDOUT.",
	usage => "<env> manifest [<options...>]",
	alias => 'm',
	description =>
		"Generate the manifest based on the given environment file, or list the ".
		"valid manifest types and subsets for the environment.\n".
		"\n".
		"[[#yi{Note:} >>For those upgrading from Genesis 2.x, the --no-redact option ".
		"has been replaced with the #Y{--type unredacted} option.  However, ".
		"unredacted manifest may not be what you want, as there are two other types ".
		"that don't get redacted, but also don't show all the secrets: entombed ".
		"and vaultified-entombed.  See the --type option for more information. ".
		"You will most likely want to use the default behaviour, which is to ".
		"display the manifest that will be sent to the BOSH director (with the ".
		"extra build metadata still remaining -- see below).\n".
		"\n".
		"[[      >>Likewise, the #Y{--no-prune} option is now the default behaviour; ".
		"if you want to see the pruned manifest, you will need to specify the ".
		"#Y{--subset pruned} option.",
	function_group => Genesis::Commands::ENVIRONMENT,
	scope => 'env',
	option_group => Genesis::Commands::ENV_OPTIONS,
	options => [
		'list|l' =>
			"List the valid manifest types and subsets for the environment (different ".
			"environments and their kits may have different valid types and subsets)".
			" -- all other options are ignored if this is specified.",

		'type|t=s' =>
			"Will generate a manifest of the given type.  If no type given, it will ".
			"produce the default deployment manifest.",

		'subset|s=s' =>
			"Will deterimine what subset of manifest content is returned.  By default ".
			"the full manifest will be returned.",
	]
});

# }}}
# genesis deploy - Pull in Cloud Config, Generate a manifest, deploy {{{
define_command("deploy", {
	summary => "Generate the manifest for the environment and deploy it to the BOSH director.",
	usage => '<env> deploy [<options...>]',
	alias => 'd',
	description =>
		"Deploy the environment to BOSH director or via create-env command.\n".
		"\n".
		"Note: Unless specified, the following options don't apply when deploying ".
		"a create-env environment.",
	function_group => Genesis::Commands::ENVIRONMENT,
	scope => 'env',
	option_group => Genesis::Commands::ENV_OPTIONS,
	options => [
		'dry-run|n' =>
			"Build the manifest and validate it against the current state of the ".
			"BOSH director for this deployment, but doesn't change anything.",

		'yes|y' =>
			"Do not ask any questions, assume 'y' for any that would normally be ".
			"asked.  Allows automation to deploy without requiring human ".
			"intervention or expect-style scripting.  (Also valid for create-env ".
			"environments)",

		'reactions!' =>
			"Determines if reactions specified in the environment file will be ".
			"processed if present (default: yes)",

		'redact!' =>
			"Determines if values are shown on the diff output.  By default, the ".
			"manifest will be redacted unless being output to the live console.",

		'fix' =>
			"Recreate unresponsive VMs instead of raising an error.  (Precludes ".
			"--recreate and --dry-run)",

		'fix-releases' =>
			"Reupload releases in manifest and replace corrupt or missing ".
			"jobs/packages.",

		'recreate' =>
			"Recreate all VMs instead of just applying changes to them. This ".
			"requires the VMs to be responsive; use --fix if they are not.\n".
			"Can be used with a create-env environment.",

		'recreate-persistent-disks|rpd' =>
			"Recreates all persistant disks, even if the deployment is a no-op ".
			"(Shortform: #y{--rpd})",

		'skip-drain=s@' =>
			"Skip running drain scripts for specific instance group.  Can be ".
			"specified multiple times. No instance group needs to be specified for ".
			"create-env environments.",

		'canaries=i' =>
			"Override the default number of canary VMs per instance group.",

		'max-in-flight=i' =>
			"Override the default number of maximum VMs in flight per instance group.",
	]
});
# }}}
# genesis bosh - run a bosh command against the BOSH director for the specified environment {{{
define_command("bosh", {
	summary => "Run a BOSH cli command for the specific environment.",
	usage => "<env> bosh [<options>] <bosh command> [<bosh options and args...>]",
	alias => 'b',
	description =>
		"Runs the specified bosh command and options, without the need to specify ".
		"the director or deployment name.  The options below must come BEFORE any ".
		"bosh command and options, or they will be passed through to the bosh cli.".
		"\n\n".
		"[[Note: >>When targeting a bosh director deployment that was deployed by ".
		"another bosh director, you should specify either --self or --parent, as ".
		"the target is ambiguous.  If you don't specify either, it will prompt you ".
		"to choose one if in a controlling terminal, or fail if not.",
	function_group => Genesis::Commands::ENVIRONMENT,
	scope => 'env',
	option_group => Genesis::Commands::REPO_OPTIONS,
	option_passthrough => 1,
	option_require_order => 1,
	options => [
		"self|A|?as-director" =>
			"Run the bosh command against this deployment as a bosh director.  This ".
			"is only applicable if the environment is a bosh deployment that doesn't ".
			"use create-env.  This is the only valid behaviour for bosh director ".
			"deployments that use create-env, so this option is unnecessary.",
		"parent" =>
			"Target the BOSH director used to deploy this environment, with the ".
			"environment being the associated deployment.  This is only applicable ".
			"if the environment is a bosh deployment that doesn't use create-env.  ".
			"This is the only valid behaviour for non-bosh director deployments, so".
			"this option is unnecessary.",
		"connect" =>
			"Intended to run inside an #C{eval \"\$(...)\"} wrapper, this command ".
			"will set the environment variables required to connect via the bosh ".
			"cli, targeting the desired deployment and associated BOSH director."
	]
});
# }}}
# genesis delete - delete the environment from the BOSH director {{{
# TODO: Create this command
# }}}
# genesis credhub - run a credhub command on the Credhub server for the specified environment {{{
define_command("credhub", {
	summary => "Run a Credhub cli command for the specific environment.",
	usage => "<env> credhub [<options>] <credhub command> [<credhub options and args...>]",
	description =>
		"Runs the specified credhub command and options against the CredHub server ".
		"associated with the specified environment.  The options below must come ".
		"BEFORE any credhub command and options, or they will be passed through to ".
		"the credhub cli.\n".
		"\n".
		"[[Note: >>Like the bosh command, if specifying a non-bosh director ".
		"deployment, it will select the CredHub server used to deploy the ".
		"environment.  If the environment is a bosh deployment that was deployed by ".
		"create-env, it will select the CredHub server on that BOSH director VM.\n".
		"\n".
		"[[      >>If the environment is a bosh deployment that was deployed by ".
		"another bosh director, you should specify either --self or --parent, as ".
		"the target is ambiguous.  If you don't specify either, it will prompt you ".
		"to choose one if in a controlling terminal, or fail if not.  Alternatively, ".
		"you can set the `default_bosh_target` in the user config to specify the ".
		"default target.",
	function_group => Genesis::Commands::ENVIRONMENT,
	scope => 'env',
	option_group => Genesis::Commands::REPO_OPTIONS,
	option_passthrough => 1,
	option_require_order => 1,
	options => [
		"raw" =>
			"Process the command exactly as given, without any additional processing. ".
			"Without this option, the command will provide augmentation to the path ".
			"based on the environment",
		"self" =>
			"Run the credhub command against this deployment as a credhub server.  This ".
			"is only applicable if the environment is a bosh deployment that doesn't ".
			"use create-env.  This is the only valid behaviour for bosh director ".
			"deployments that use create-env, so this option is unnecessary.",
		"parent" =>
			"Target the Credhub server used to deploy this environment, with the ".
			"environment being the associated deployment.  This is only applicable ".
			"if the environment is a bosh deployment that doesn't use create-env.  ".
			"This is the only valid behaviour for non-bosh director deployments, so ".
			"this option is unnecessary."
	]
});
# }}}
# genesis logs - fetch logs from the BOSH director for the specified environment {{{
define_command("logs", {
	summary => "Fetch logs from the BOSH director for the specified environment.",
	usage => "<env> logs [<options...>]",
	description =>
		"Fetches logs from the BOSH director for the specified environment.  This ".
		"will only work for environments that are bosh deployments (i.e.: will ".
		"work on create-env deployments, as they don't have a CredHub server ".
		"associated with them).",
	function_group => Genesis::Commands::ENVIRONMENT,
	scope => 'env',
	option_group => Genesis::Commands::REPO_OPTIONS,
	option_passthrough => 1,
	option_require_order => 1,
	options => []
});
# }}}
# genesis do - run a kit addon {{{
define_command("do", {
	summary => "Run an addon script provided by the environment's kit.",
	usage => "<env> do [<options...>] action [<addon options and args...>]",
	aliases => ['apply','run','addon'],
	description =>
		"Run an addon from the kit against your environment.  Except for rare ".
		"circumstances, this requires the environment to already be deployed.  ".
		"A list of addons available and any options they support can be found by ".
		'running the `#g{$BIN} #M{<env>} #G{$CALLED} #c{list}` addon.',
	function_group => Genesis::Commands::ENVIRONMENT,
	scope => 'env',
	option_group => Genesis::Commands::ENV_OPTIONS,
	option_passthrough => 1,
	option_require_order => 1,
});
# }}}
# }}}

### Informative commands {{{
# genesis info - get deployment environment information from  a kit{{{
define_command("info", {
	summary => "Prints out kit-specific information for a given environment.",
	usage => "<env> info [<options...>]",
	alias => 'i',
	description =>
		"Get details for the current deployment of the given environment.",
	function_group => Genesis::Commands::INFO,
	scope => 'env',
	option_group => Genesis::Commands::ENV_OPTIONS,
}, "Genesis::Commands::Info::information"); # info method already taken, so can't use default

# }}}
# genesis lookup - Find a key set in environment manifests. {{{
define_command("lookup", {
	summary => "Look up values from an environment's file, manifest, deployment, exodus or env state.",
	usage => "<env> lookup [--merged|--deployed|--env|--exodus|] key [default-value|--defined] [--entomb]\n".
					 "lookup --exodus-for <env/type> key [default-value|--defined]",
	alias => 'get',
	description =>
		"Looks up data from the environment file (or alterative source: see ".
		"options below) If the key is empty string, it will return all data from ".
		"the source.",
	function_group => Genesis::Commands::INFO,
	scope => [['exodus-for' => 'repo'], 'env'],
	option_group => Genesis::Commands::ENV_OPTIONS,
	options => [
		"merged" =>
			"Lookup data from a fully merged manifest for the environment.",
		"partial" =>
			"Lookup data from a partially merged manifest for the environment.",
		"deployed" =>
			"Lookup data from the manifest of the last deployment.",
		"exodus" =>
			"Lookup data from the genesis exodus data for the last deployment.",
		"exodus-for=s" =>
			"Lookup data from the genesis exodus data for a different enviroment.  ".
			"Takes an argument of the form 'env-name/deployment-type'",
		"env" =>
			"Lookup environment variables used by Genesis for the given environment.",
		"entomb" =>
			"Entomb the vault secrets in the BOSH director's credhub before ".
			"rendering the manifest, so that if looking up a secret, return the ".
			"reference to credhub instead.  Not applicable to exodus or deployed ".
			"manifests",
		"defined" =>
			"Exit with 0 if key defined in specified source, 9 otherwise.  No output ".
			"is produced, making it useful in 'if lookup ... ; then'"
	]
});

# }}}
# genesis yamls - Print a list of the YAML files used for a single environment. {{{
define_command("yamls", {
	summary => "Print the sequence of YAML files used for a single environment.",
	usage => '<env> yamls [-k|--include-kit]',
	alias => 'yml',
	description =>
		"List the manifest fragments that will be merged, in order, to build the ".
		"deployment manifest.  This includes any hierarchial files that share the ".
		"sub-names of the kit (ie #M{c.yml} and #M{c-region.yml} if environment ".
		"is named #M{c-region-env.yml}), as well as any ops files, or specified ".
		"by 'genesis.inherits' array in the environment file.\n".
		"\n".
		"If the #y{-k|--include-kit} option is specified, it will also include ".
		"the fragments the kit supplies, depending on the features requested.",
	function_group => Genesis::Commands::INFO,
	scope => 'env',
	option_group => Genesis::Commands::ENV_OPTIONS,
	options => [
		'include-kit|k' =>
			"This also includes the files that will be merges from the kit."
	]
});

# }}}
# genesis vault-paths - Print the list of vault paths used by the environment. {{{
define_command("vault-paths", {
	summary => "Print the list of vault paths used by the environment, and optionally what references each one.",
	usage => '<env> yamls [-r|--references]',
	alias => 'vp',
	description =>
		"List the vault paths used by the environment, including those in the kit, ".
		"the environment file, and any used by included ops files.\n".
		"\n".
		"If the #y{-r|--references} option is specified, it will also include ".
		"the YAML path of all references to those vault paths.",
	function_group => Genesis::Commands::INFO,
	scope => 'env',
	option_group => Genesis::Commands::ENV_OPTIONS,
	options => [
		'references|r' =>
			"Include all YAML references to the given vault paths as a list under ".
			"each path."
	]
});

# }}}
# genesis kit-manual - peruse the kit manual pages {{{
define_command("kit-manual", {
	summary => "Show the manual for kit by name/version or in use by the given environment",
	usage => "kit-manual <kit-name>|<kit-version>|<kit-name/version>\n".
					 "<env> kit-manual",
	alias => 'man',
	description =>
		"Produces the manual for the kit specified.  If an environment is ".
		"specified, it will be for the version of the kit used by that environment. ".
		"Otherwise, it will be for the name and/or version of the kit specified.  ".
		"If no name is specified, it will be for the de-facto kit for this repo, ".
		"or error if there isn't one.  If no version is specified, it will be for ".
		"the latest version found locally.",
	function_group => Genesis::Commands::INFO,
	scope => ['repo','env'],
	option_group => Genesis::Commands::REPO_OPTIONS,
	options => [
		'raw' =>
			"Print the raw manual instead of rendering it in markdown.",
		'pager|P' =>
			"Use a pager to display the manual."
	],
	no_vault => 1
});

# }}}
# genesis environments - list the environments in the known deployment repositories {{{
define_command("environments", {
	summary => "List the environments in the known deployment repositories.",
	usage => "environments",
	alias => 'envs',
	description =>
		"List the environments in the known deployment repositories, along with ".
		"the path to the environment file, the kit used, and the last deployment ".
		"status.",
	function_group => Genesis::Commands::INFO,
	scope => 'all',
	option_group => Genesis::Commands::REPO_OPTIONS,
	options => [
		'group_by_env|G' =>
			"Group the environments by the environment name, rather than by the ".
			"kit repository."
	],
	no_vault => 0
});

# }}}
# }}}

### Secrets Management commands {{{
# genesis check-secrets - Check required credentials for an environment. {{{
define_command("check-secrets", {
	summary => "Check for missing certificates and credentials needed by the environment.",
	usage => '<env> check-secrets [<options...>] [<path1> <...pathN>]',
	alias => 'cs',
	description =>
		"Checks that all required secrets are present.  Returns a exit code of 1 ".
		"if any are missing, and lists them, otherwise states all secrets are ".
		"present and exits with 0.  A list of secret paths can be specified, ".
		"otherwise all secrets specified by the kit will be checked.",
	function_group => Genesis::Commands::ENVIRONMENT,
	scope => 'env',
	option_group => Genesis::Commands::ENV_OPTIONS,
	options => [
		'verbose|v' =>
			"List each item, not just failures and warnings.",

		'exists' =>
			"Instead of validating the structure of each secret, just check that ".
			"secret and its required keys exist",
	],
	deprecated_options => [
		'vault' =>
			"The name of a `safe' target (a Vault) to check for the generated ".
			"credentials.  Only accepted if the deployment repository does not have ".
			"a vault specified."
	]
});

# }}}
# genesis add-secrets - Generate missing credentials for an environment. {{{
define_command("add-secrets", {
	summary => "Generate missing certificates and credentials for the environment.",
	usage => '<env> add-secrets [<options...>] [<path1> <...pathN>]',
	alias => 'as',
	description =>
		"Generates any missing secrets required by the deployment.  Useful to ".
		"generate credentials after upgrading kits.   A list of secret paths can ".
		"be specified, or it applies to all secrets if no path is specified.",
	function_group => Genesis::Commands::ENVIRONMENT,
	scope => 'env',
	option_group => Genesis::Commands::ENV_OPTIONS,
	options => [
		"verbose|v" =>
			"List each item as it is processed.",
		"~import|import-from-credhub" =>
			"Attempt to import the secret value from credhub if the secret ".
			"definition originates from the manifest and the value exists in ".
			"credhub.  (credhub-oriented kits such as cf and cf-app-autoscaler)"
	],
	deprecated_options => [
		"vault=s" =>
			"The name of a 'safe' target (a Vault) to store newly generated ".
			"credentials in.  This option is only accepted if the deployment ".
			"repository does not have a secrets-provider set - see ".
			"'#g{$ENV{GENESIS_CALL_BIN}} #G{secrets-provider}'."
	]
});

# }}}
# genesis rotate-secrets - Rotate required credentials for an environment. {{{
define_command("rotate-secrets", {
	summary => "Regenerate secrets for the environment.",
	usage => '<env> rotate-secrets [<options...>] [<path1> <...pathN>]',
	aliases => ['rot','rs','regen'],
	function_group => Genesis::Commands::ENVIRONMENT,
	scope => 'env',
	description =>
		"Regenerate secrets for your deployment. If any secrets are marked by the ".
		"kit as 'fixed', they are not updated.  A list of secret paths can be ".
		"specified, or it applies to all secrets if no path is specified.\n",
	option_group => Genesis::Commands::ENV_OPTIONS,
	options => [
		'verbose|v' =>
			"List each item as it is processed, not just failures and warnings.",

		'regen-x509-keys' =>
			"Normally, when x509 certificates are renewed, Genesis retains the ".
			"existing keys.  This is done to ensure compatibility with the previous ".
			"certificates (and any certificates signed by that certificate) while ".
			"updating the validity period.\n".
			"\n".
			"With this option specified, keys will be regenerated along with the ".
			"certificate, meaning all certificates it signed will also have to be ".
			"regenerated, and any deployments on certificate modulo pairing will ".
			"need a three-step deployment.",

		'update-subjects' =>
			"When rotating X.509 certificates, normally the current subject is ".
			"retained because changing it will break signing chains for any ".
			"certificate it signed.  However, it may be necessary to update the ".
			"subject of a leaf certificate, or even a CA, if the definition has ".
			"changed, so this option is provided.\n\n".
			"[[Note: >>If --regen-x509-keys option is used, it will recreate the ".
			"certificate completely, including any changes in the subject.",

		'invalid|I' =>
			"Rotate secrets that are invalid (expired, missing, or don't match the ".
			"kit specification)",

		'problematic|problem|P' =>
			"Rotate secrets that are either invalid, or valid for deployment, but ".
			"are not in compliance with the kit specification or may soon expire.",

		'no-prompt|y' =>
			"Don't prompt for confirmation",

		'interactive|i' =>
			"Ask before rotating each secret.",
	],
	deprecated_options => [
		'vault=s' =>
			"The name of a `safe' target (a Vault) that is storing the target ".
			"credentials.  This option is only accepted if the deployment ".
			"repository does not have a secrets-provider set - see ".
			"'#g{$ENV{GENESIS_CALL_BIN}} #G{secrets-provider}'.",

		'force|force-rotate-all|f' =>
			"Used to rotate #R{ALL} secrets, including any credentials that the kit ".
			"defined as `fixed'. This was very dangerous.  Instead, use ".
			"'#G{remove-secrets}' to remove specific secrets and the ".
			"'#G{add-secrets}' to add them back."
	]
});

# }}}
# genesis remove-secrets - Remove credentials from an environment. {{{
define_command("remove-secrets", {
	summary => "Remove certificates and credentials from the environment",
	usage => "<env> remove-secrets [<options...>] [<path1> <...pathN>]",
	aliases => ['rms','ds'],
	description =>
		"Removes the generated secrets for the specified environment. If the --all ".
		"option is specified, it will remove all screts under the environment's ".
		"secrets base path, including any manually put there (such as by the ".
		"'#g{genesis} #G{create}' command).  Otherwise, secrets can be specified ".
		"on the command line to further limit the scope of what will be removed ".
		"(all generated secrets if no path is specified).",
	function_group => Genesis::Commands::ENVIRONMENT,
	scope => 'env',
	option_group => Genesis::Commands::ENV_OPTIONS,
	options => [
		'verbose|v' =>
			"List each item as it is processed, not just failures and warnings.",

		'all|A' =>
			"Remove all secrets under this deployments secrets base path in vault.",  # FIXME: what about credhub?

		'invalid|I' =>
			"Remove any secrets that are invalid",

		'problematic|problem|P' =>
			"Remove any secrets that are invalid or problematic.",

		'unused|U' =>
			"Remove any secrets that the kit does not know about, or are in credhub ".
			"from a pre-vaultified deployment, or are outdated entombed secrets.",

		'no-prompt|y' =>
			"Don't prompt for confirmation",

		'interactive|i' =>
			"Ask for confirmation on each secret path removal.",
	], # FIXME Do we need a --force to remove fixed and x509 keys/serial?
	deprecated_options => [
		'vault=s' =>
			"The name of a `safe' target (a Vault) that is storing the target ".
			"credentials.  This option is only accepted if the deployment ".
			"repository does not have a secrets-provider set - see ".
			"'#g{$ENV{GENESIS_CALL_BIN}} #G{secrets-provider}'.",
	]
});

# }}}
# }}}

### Repository Management commands {{{
# genesis init - initialize a new Genesis repository {{{
define_command("init", {
		summary => "Initialize a new Genesis deployment repository.",
		usage => "init [-k KIT/VERSION|-l path/to/local/kit] [-d directory] [--vault target] [name]",
		description =>
			"Create a new Genesis deployment repository, specific to the given kit type.",
		function_group => Genesis::Commands::REPOSITORY,
		scope => 'empty',
		option_group => Genesis::Commands::REPO_OPTIONS,
		options => [
			"kit|k=s" =>
				"Name (and optionally, version) of the Genesis Kit to base these ".
				"deployments on.  I.e.: shield/6.3.0.  If you do not specify a kit, a ".
				"dev directory will be created for you to develop a local kit into.\n".
				"\n".
				"You can also specify a path to a compiled kit to use that explicit ".
				"kit, which will be copied into the .genesis/kits/ directory",

			"link-dev-kit|l=s" =>
				"Instead of using a kit or initializing an empty dev directory, this ".
				"will link the specified directory to the dev directory.",

			"vault=s" =>
				"Name of a 'safe' target (a Vault) to store newly generated ".
				"credentials in. If not specified, it will be interactively prompted for.",

			"directory|d=s" =>
				"By default, the directory in which the Genesis deployment will be ".
				"created in will be named ./<name>-deployments.  Use this option to ".
				"change it to something else.".
				"\n".
				"Note: As of Genesis 3.0.0, the default directory name no longer has ".
				"the '-deployments' suffix, but the option is still available for ".
				"backward compatibility by setting the #Y{legacy_repo_suffix} option in ".
				"the Genesis configuration file \$HOME/.genesis/config.yml to true.",
		],
		option_passthrough => 1,
		arguments => [
			"name?" =>
				"If the name argument is not specified, it will default to the same ".
				"name as the kit.  You must specify either name or kit."
		],
		extended_usage => sub {
			require Genesis::Kit::Provider;
			Genesis::Kit::Provider->opts_help();
		}
});

# }}}
# genesis secrets-provider - set, clear or get the secret provider information {{{
define_command("secrets-provider", {
	summary => "Check or set the secrets provider for the Genesis deployment repo.",
	usage => "secrets-provider [-i|--interactive|-c|--clear] [target]",
	alias => 'sp',
	description =>
		"Set, clear or view the secrets provider information",
	function_group => Genesis::Commands::REPOSITORY,
	scope => 'repo',
	option_group => Genesis::Commands::REPO_OPTIONS,
	options => [
		"interactive|i" =>
			"Set the provider interactively from a list of known secrets providers.",

		"clear|c" =>
			"Remove existing provider -- this will restore legacy behaviour of ".
			"using the system-targeted vault.",
	],
	arguments => [
		"target?" =>
			"Set the secrets provider to the specified target, which can either be ".
			"a full url including protocol, or an alias.  This target must be known ".
			"to the local system.  If this is omitted, the current secrets provider ".
			"information is displayed.",
		]
});


# }}}
# genesis kit-provider - set, clear or get the kit provider information {{{

define_command("kit-provider", {
	summary => "Check or set the kit provider for the Genesis deployment repo.",
	usage => "kit-provider [-d|--default] [<provider-options>]",
	alias => 'kp',
	description =>
		"Without any options, will display the current kit provider information, ".
		"its status and its kits (version counts are included with the --verbose ".
		"option)\n".
		"\n".
		"With --kit-provider-* options, will set the kit provider to a new ".
		"provider specified by those options.  See Kit Provider options below for ".
		"more details.",
	function_group => Genesis::Commands::REPOSITORY,
	scope => 'repo',
	option_group => Genesis::Commands::REPO_OPTIONS,
	options => [
		"default|d" =>
			"Use default genesis-community provider",
		"verbose|v" =>
			"Show details of the kits the current kit provider supports.",
		"export-config" =>
			"Export the current kit provider information."
	],
	extended_usage => sub {
			require Genesis::Kit::Provider;
			Genesis::Kit::Provider->opts_help();
	}
});

# }}}
# }}}

### Kit Management command {{{
# genesis create-kit - Create the structure for a new kit {{{
define_command("create-kit", {
	summary => "Create a new kit with default scaffolding.",
	usage => " create-kit [-C path] [-d|--dev] -n NAME [FEATURE ...]",
	alias => "mk",
	function_group => Genesis::Commands::KIT,
	scope => [['dev' => 'repo'], 'empty'],
	option_group => Genesis::Commands::REPO_OPTIONS,
	options => [
		'name|n=s' =>
			"Name of the kit archive. The suffix -genesis-kit will be appended to ".
			"your <name> parameter.",

		'dev|d' =>
			"create kit in development repo 'dev' directory instead of ".
			"<name>-genesis-kit"
	],
	no_vault => 1,
});

# }}}
# genesis compile-kit - Create a distributable kit archive from dev/. {{{

define_command("compile-kit", {
	summary => "Create a distributable kit archive from the kit repo or dev dir",
	usage => "compile-kit [<options...>]",
	alias => 'ck',
	description =>
		"Compile the kit in the current directy (if in a kit dir) or in ./dev (if ".
		"in a deployment repo dir), automatically creating the next appropriate ".
		"version (see options for version specification if desired)",
	function_group => Genesis::Commands::KIT,
	scope => [
		[['processed','dev'] => 'repo'],
		[['processed','name'] => 'kit'],
		['processed' => 'kit_or_dev'],
		'undef'
	],
	option_group => Genesis::Commands::REPO_OPTIONS,
	options => [
		'version|v=s' => { argument => ' <semver>', description =>
			"Specify the explicit version you want created.  If this version already ".
			"exists locally or remotely, you must also specify --force to recreate it."
		},

		'major|M' =>
			"If not specifying an explicit version, bump the current latest ".
			"version's major value instead of the patch value.",

		'minor|m' =>
			"If not specifying an explicit version, bump the current latest ".
			"version's minor value instead of the patch value.",

		'final|F' =>
			"If not specifying an explicit version, an rc based on the next ".
			"version will be created.  If a non-rc version is desired, use this ".
			"--final option.",

		'name|n=s' =>
			"Name of the kit archive.  If not provided, will take the name of the ".
			"current (or specified with -C) directory before the suffix of ".
			"'-genesis-kit' (standalone mode) or '-deployments' (dev mode).",

		'target|t=s' =>
			"Directory to place kit once compiled.  Defaults to current directory.  ".
			"If the target has a .genesis directory under it, it will be placed in ".
			"'.genesis/kits' directory.\n".
			"\n".
			"If using relative bumping, it will consider the existing kits in the ".
			"target directory to determine latest version.",

		'dev|d' =>
			"Compile based off of a dev-kit (./dev). If not specified, genesis will ".
			"compile based off of ./<name>-genesis-kit.  Automatically set if run ".
			"from inside a genesis deployments directory.",

		'force|f' =>
			"Proceed with compilation even if there are unstaged or uncommitted ".
			"changes in the working directory, or if the validation of the contents ".
			"fails.  Normally, Genesis will refuse to continue when this happens.",
	],
	no_vault => 1,
	skip_check_prereqs => 1,
});

# }}}
# genesis decompile-kit - Unpack a kit archive to dev/. {{{
define_command("decompile-kit", {
	summary => "Unpack a kit archive to dev.",
	usage => "decompile-kit [<options...>] <kit-name>|<kit-version>|<kit-name/version>|<path/to/kit.tar.gz>\n".
	         "<env> decompile-kit [<options...>]",
	alias => 'dk',
	description =>
		"Decompile the specified kit (by name/version, path, or in use by the ".
		"given environment file) into a local 'dev' directory.  This can be used ".
		"to alter the kit from published version (ie for bug fixes or feature ".
		"augmentation) by specifying the kit.name key in your environment file.",
	function_group => Genesis::Commands::KIT,
	scope => ['env','repo'],

	option_group => Genesis::Commands::REPO_OPTIONS,
	options => [
		'directory|d=s' =>
			"Path to decompile kit into (defaults to dev)",

		'force|f' =>
			"Overwrite dev/, if it exists."
	],
	no_vault => 1,
});

# }}}
# genesis list-kits - list kit versions available locally or remotely {{{
define_command("list-kits", {
	summary => "List available local or remote Genesis kits.",
	alias => 'lk',
	usage => 'list-kits [-r|--remote|--updates|-u] [<options>] [--filter <regex>|<name>]',
	description =>
		"Lists the kits available locally or remotely.  If filter is specified, ".
		"use it as a regular expression to filter the kits returned.",
	function_group => Genesis::Commands::KIT,
	scope => [['remote' => 'any'], 'repo'],
	option_group => Genesis::Commands::REPO_OPTIONS,
	arguments => [
		'name?' =>
			"name of the kit to list versions (cannnot be used with #y{--filter})",
	],
	options => [
		'updates|u' =>
			"List remote updates newer than the latest local",

		'remote|r' =>
			"List the remote kits available from the Genesis Community Github ".
			"organization",

		'all|a' =>
			"List all the remote kits and versions, not just the kit(s) in the ".
			"current deployment repository.  Must be used with #y{--remote}",

		'latest|l:i' =>
			"List only the latest (N) versions -- N defaults to 1",

		'filter=s' => {argument => ' <regex>', description =>
			"Filter kits to the given regular expression pattern"
		},

		'-section-break-' =>
			"Remote and update options supports further options:",

		'prereleases' =>
			"Include pre-release versions of kits",

		'drafts' =>
			"Include draft versions of the kits",

		'details!' =>
			"Determines if release date and details are shown.  Defaults to show ".
			"for #y{--updated}, not show for others",
	],
	skip_check_prereqs => 1,
	no_vault => 1,
});


# }}}
# genesis fetch-kit - Download a Genesis Kit from the Internet. {{{
define_command("fetch-kit", {
	summary => "Download one or more Genesis kits from a Genesis kit provider.",
	usage => "fetch-kit [<kit-name>|<kit-name/version>|<kit-version> ...]",
	# TODO:  add <env> fetch-kit support to fetch kit used by env
	alias => 'fk',
	description =>
		"Fetch the specified kit version for this deployent.  With no arguments, ".
		"it will update all local kits.  If you have a single local kit, you can ".
		"specify a list of versions of that kit to be fetched.",
	function_group => Genesis::Commands::KIT,
	scope => 'repo',
	option_group => Genesis::Commands::REPO_OPTIONS,
	options => [
		'force|f' =>
			"Force refetching the specified kit, or overwriting the ./dev directory, ".
			"even if it already exists.",

		'to=s' => {argument => ' <path>', description =>
			"Normally, the kit is downloaded into the .genesis/kits in your repo ".
			"directory.  Use this option to download it to any specified directory.\n",
		},
		'as-dev|d' =>
			"After downloading the specified kit, decompile it to the dev director\n".
			"\n".
			"Note: if using this option, you must specify a single version of the ".
			"kit to download",

	],
	no_vault => 1,
});

define_command("download", {
	deprecated => 'fetch-kit',
	summary => "Download a kit - use #g{fetch-kit} instead",
	usage => "download [<kit-name>|<kit-name/version>|<kit-version> ...]",
	description => "Download Genesis kit",
	function_group => Genesis::Commands::DEPRECATED,
	scope => 'repo',
	option_group => Genesis::Commands::BASE_OPTIONS,
	option_passthrough => 1,
	no_vault => 1,
}, "Genesis::Commands::Deprecated::redirect");

# }}}
# }}}

### Pipeline Management commands {{{
# genesis embed - embed Genesis in the repository {{{
define_command("embed", {
	summary => "Embed this version of Genesis into the current Genesis deployment repository.",
	description =>
		"Embed current version of genesis in the repo to allow pipelines to run ".
		"genesis commands",
	function_group => Genesis::Commands::PIPELINE,
	scope => 'repo',
	option_group => Genesis::Commands::REPO_OPTIONS,
	no_vault => 1,
	no_use_embedded_genesis => 1,
});

# }}}
# genesis repipe - Deploy a Concourse CI/CD deployment pipeline. {{{
define_command("repipe", {
	summary => "Configure a Concourse pipeline for automating deployments.",
	usage => 'repipe [<pipeline-layout>]',
	alias => "push",
	function_group => Genesis::Commands::PIPELINE,
	scope => 'repo',
	arguments => [
		'pipeline-layout?' =>
			"The name of the layout to push to Concourse.\n".
			"Defaults to single layout present in config file, or 'default' if there ".
			"are multiple layouts present.  You must specify this argument if you ".
			"have multiple layouts without one of them being named 'default'"
	],
	option_group => Genesis::Commands::REPO_OPTIONS,
	options => [
		'yes|y' =>
			"Do not ask any questions, assume 'y' for any that would normally be ".
			"asked.  Allows automation to repipe without requiring human ".
			"intervention or expect-style scripting.",

		'dry-run|n' =>
			"Generate the Concourse Pipeline configuration, but refrain from ".
			"actually deploying it to Concourse.  Instead, just print the YAML.",

		'target|t=s' =>
			"The name of your Concourse target (per `fly targets'), if it differs ".
			"from the pipeline layout name.",

		'config|c=s' =>
			"Path to the pipeline configuration file, which specifies Git ".
			"parameters, notification settings, pipeline layouts, etc.\n".
			"Defaults to 'ci.yml'",

		'paused|P' =>
			"Keep the pipeline paused after repiping.",
	],
	deprecated_options => [
		'vault=s' =>
			"The name of a `safe' target (a Vault) where the secret credentials ".
			"are stored.  Only accepted if the deployment repository does not ".
			"have a vault specified.",
	]
});
# }}}
# genesis graph - Draw a Concourse CI/CD deployment pipeline. {{{
define_command("graph", {
	summary => "Draw a Concourse pipeline.",
	usage => "graph [<pipeline-layout>] | #g{dot} #y{-Tpng} > pipe.png",
	description =>
		"Generate a directed, acyclic graph (a DAG) for the specified layout in ".
		"the Graphviz language (http://www.graphviz.org/).\n".
		"\n".
		"If you want a picture of the pipeline, you will need to pipe the output ".
		"through one of the many Graphviz formatters, like `dot -Tpng > out.png`",
	function_group => Genesis::Commands::PIPELINE,
	scope => 'repo',
	arguments => [
		'pipeline-layout?' =>
			"The name of the layout to push to Concourse.\n".
			"Defaults to single layout present in config file, or 'default' if there ".
			"are multiple layouts present.  You must specify this argument if you ".
			"have multiple layouts without one of them being named 'default'"
	],
	option_group => Genesis::Commands::REPO_OPTIONS,
	options => [
		'config|c=s' =>
			"Path to the pipeline configuration file, which specifies Git ".
			"parameters, notification settings, pipeline layouts, etc.\n".
			"Defaults to 'ci.yml'",
	]
});
# }}}
# genesis describe - Describe a Concourse CI/CD deployment pipeline. {{{
define_command("describe", {
	summary => "Describe a Concourse pipeline, in words.",
	usage => "describe [<pipeline-layout>]",
	description =>
		"Describe the genesis deployment repo pipeline for the given layout in ".
		"human terms",
	function_group => Genesis::Commands::PIPELINE,
	scope => 'repo',
	arguments => [
		'pipeline-layout?' =>
			"The name of the layout to push to Concourse.\n".
			"Defaults to single layout present in config file, or 'default' if there ".
			"are multiple layouts present.  You must specify this argument if you ".
			"have multiple layouts without one of them being named 'default'"
	],
	option_group => Genesis::Commands::REPO_OPTIONS,
	options => [
		'config|c=s' =>
			"Path to the pipeline configuration file, which specifies Git ".
			"parameters, notification settings, pipeline layouts, etc.\n".
			"Defaults to 'ci.yml'",
	]
});
# }}}
# genesis ci-pipeline-deploy - Deploy via the CI/CD Pipeline {{{
define_command("ci-pipeline-deploy", {
	summary => "Deploy an environment.",
	usage => "ci-pipeline-deploy [<options...>]",
	description =>
		"This Genesis command is used by the Genesis pipeline to deploy an ".
		"environment, correctly propagating changes through the pipeline process ".
		"so that changes that weren't tested in an upstream environment don't ".
		"get deployed to a later (and most likely more sensitive) environment.\n".
		"\n".
		"Rather than use options, it relies on environment variables to convey ".
		"information about the action being requested (base options still apply)",
	function_group => Genesis::Commands::PIPELINE,
	scope => 'pipeline',
	variables => [
		CURRENT_ENV =>
			"Name of the current environment",

		PREVIOUS_ENV =>
			"Name of previous environment (if applicable, for finding cached changes ".
			"to propagate)",

		"-section-break-" => '',

		VAULT_ROLE_ID =>
			"Vault RoleID to authenticate to Vault with",

		VAULT_SECRET_ID =>
			"Vault SecretID to authenticate to Vault with",

		VAULT_ADDR =>
			"URL of the Vault to use for credentials retrieval",

		VAULT_SKIP_VERIFY =>
			"Whether or not to enforce SSL/TLS validation",

		VAULT_NAMESPACE =>
			"Set for enterprise vaults that require namespaces",

		VAULT_NO_STRONGBOX =>
			"Set true for non Genesis vault deployments",

		VAULT_SECRETS_MOUNT =>
			"Set if vault secrets are not found under /secret",

		"-section-break-" => '',

		GIT_BRANCH =>
			"Name of the git branch to push commits to. post-deploy",

		GIT_PRIVATE_KEY =>
			"Private Key to use for pushing commits, post-deploy, ssh",

		GIT_USERNAME =>
			"Username to use for pushing commits, post-deploy, https",

		GIT_PASSWORD =>
			"Password to use for pushing commits, post-deploy, https",

		"-section-break-" => '',

		WORKING_DIR =>
			"Path to the directory to deploy/work from",

		OUT_DIR =>
			"Path to the directory to output to",

		CACHE_DIR =>
			"Path to the directory our cache is in (required if PREVIOUS_ENV is present)",

		GIT_GENESIS_ROOT =>
			"Path under *_DIR where the genesis deployment actually is (defaults to .)",
	],
	option_group => Genesis::Commands::REPO_OPTIONS,
});

# }}}
# genesis ci-show-changes - Show what changes would be deployed based on changes and upstream cache via the CI/CD Pipeline {{{
define_command("ci-show-changes", {
	summary => "Show what changes would be deployed based on changes and upstream cache via the CI/CD Pipeline",
	usage => "ci-show-changes [<options...>]",
	description => "",
	function_group => Genesis::Commands::PIPELINE,
	scope => 'pipeline',
	variables => command_properties('ci-pipeline-deploy')->{variables}, # Same variables as ci-pipeline-deploy
	option_group => Genesis::Commands::REPO_OPTIONS,
});

# }}}
# genesis ci-generate-cache - Generate cache for an environment via the CI/CD Pipeline {{{
define_command("ci-generate-cache", {
	summary => "Generate cache for an environment via the CI/CD Pipeline",
	usage => "ci-generate-cache [<options...>]",
	description => "",
	function_group => Genesis::Commands::PIPELINE,
	scope => 'pipeline',
	variables => [
		CURRENT_ENV =>
			"Name of the current environment",

		PREVIOUS_ENV =>
			"Name of previous environment (if applicable, for finding cached changes ".
			"to propagate)",

		"-section-break-" => '',

		GIT_BRANCH =>
			"Name of the git branch to push commits to. post-deploy",

		GIT_PRIVATE_KEY =>
			"Private Key to use for pushing commits, post-deploy, ssh",

		GIT_USERNAME =>
			"Username to use for pushing commits, post-deploy, https",

		GIT_PASSWORD =>
			"Password to use for pushing commits, post-deploy, https",

		"-section-break-" => '',

		WORKING_DIR =>
			"Path to the directory to deploy/work from",

		OUT_DIR =>
			"Path to the directory to output to",

		CACHE_DIR =>
			"Path to the directory our cache is in (required if PREVIOUS_ENV is present)",

	],
	option_group => Genesis::Commands::REPO_OPTIONS,
});
# }}}
# genesis ci-pipeline-run-errand - Run arbitrary errands via the CI/CD Pipeline {{{

define_command("ci-pipeline-run-errand", {
	summary => "Run arbitrary errands via the CI/CD Pipeline",
	usage => "ci-pipeline-run-errand [<options...>]",
	function_group => Genesis::Commands::PIPELINE,
	scope => 'pipeline',
	option_group => Genesis::Commands::REPO_OPTIONS
});

# }}}
# }}}

### Genesis Utility commands {{{
# genesis ui-semver - Provides semver in support of hook scripts {{{
define_command("ui-semver", {
	summary => "Tests if a semantic version meets or exceeds the specified version.",
	usage => "ui-semver <version> ge <minimum>",
	description =>
		"Returns an exit code of 0 if the given version meets or exceeds the ".
		"minimum version specified.\n".
		"\n".
		"Please note that non-semantic versions (i.e. \"latest\", confusingly ".
		"enough) are never valid for either side of a version assertion.",
	function_group => Genesis::Commands::UTILITY,
	scope => 'any',
	option_group => Genesis::Commands::BLANK_OPTIONS,
}, sub {
	command_usage(1) if @_ != 3 || $_[1] ne 'ge';
	my ($have, undef, $min) = @_;
	exit(new_enough($have, $min) ? 0 : 1);
});
# }}}
# genesis ui-describe - Provides colored explanatory test {{{

define_command("ui-describe", {
		summary => "Easy formatted colorize text.",
		usage => "ui-describe [<options...>] <string> [<...stringN>]",
		alias => "print",
		description =>
			"Prints each string, separated by a new line.  Supports color blocks by ".
			"the wrapping of a block of text with #B{#<f>[<b>ui]{block}}, where <f> ".
			"and <b> specify the foreground and background color, using one of:\n".
			"  b - #b{blue}               B - #B{light blue}\n".
			"  c - #c{dark cyan}          C - #C{cyan}\n".
			"  g - #g{green}              G - #G{light green}\n".
			"  k - #k{black}              K - #K{dark grey}\n".
			"  m - #m{purple}             M - #M{magenta}\n".
			"  r - #r{red}                R - #R{light red}\n".
			"  w - #w{light grey}         W - #W{white}\n".
			"  y - #y{amber}              Y - #Y{yellow}\n".
			"  * - #*{rainbow}\n".
			"\n".
			"The u and i represent #u{underline} and #i{italic} respectively.\n\n".
			"[[Note: >>this is available via the #g{describe} bash function in the ".
			"helper scripts.",
		function_group => Genesis::Commands::UTILITY,
		scope => 'any',
		option_group => Genesis::Commands::BLANK_OPTIONS,
		no_vault => 1,
		skip_check_prereqs => 1,
		no_use_embedded_genesis => 1
}, sub {
	# TODO: Support wrap at terminal width option
	print csprintf("%s\n", $_) for (@_);
});
# }}}
# genesis ui-prompt-for - Provides prompts in support of hooks/new script {{{
define_command("ui-prompt-for", {
	summary => "provides various interactive prompts for scripts",
	usage => "ui-prompt-for <type> <path> [options...] [<prompt>]",
	description =>
		"Provide prompts for getting information from the user.  Types of prompts ".
		"supported are:\n".
		"[[  line:          >>prompt for a single line of text\n".
		"[[  boolean:       >>prompt for a boolean value, returns 'true'/'false'\n".
		"[[  block:         >>prompt for a multi-line block of text\n".
		"[[  select:        >>prompt the user to select one of a list of choices\n".
		"[[  multi-line     >>prompt for zero or more lines of text\n".
		"[[  multi-block:   >>prompt for zero or more blocks of text\n".
		"[[  multi-select:  >>provide the user with a list of choices to select ".
		                     "zero or more of them\n".
		"[[  secret-line:   >>prompt for a single line of test, stores it in vault\n".
		"[[  secret-block:  >>prompt for a block of text, stores it in vault\n".
		"\n".
		"#B{<path>} is either a file path, or a relative or absolute vault path ".
		"(for secret-* types)\n".
		"\n".
		"[[Note: >>With multi-* types, the first entry in the file is blank, to ".
		           "indicate that there is at least one entry -- an empty list ".
		           "will not contain any fields.  This is to distinguish between ".
		           "a single empty string and no entries at all.\n".
		"\n".
		"[[      >>For vault paths, relative paths don't start with a / and are ".
		          "relative to the environment's secrets base path ".
		          "(secrets_mount+secrets_path).  Absolute vault paths start with ".
		          "a '/'  This changed in v2.7.0; prior to this version, all ".
		          "paths were relative to '/secret/' and the new behaviour is ".
		          "only available for kits that specify a genesis version min of ".
		          "2.7.0-rc4",
	function_group => Genesis::Commands::UTILITY,
	scope => 'any',
	option_group => Genesis::Commands::BLANK_OPTIONS,
	options => [
		'inline|i' =>
			"Place the cursor immediately after the prompt instead of on the next ".
			"line.  This is highly recommended for boolean prompts",

		'label|l=s' =>
			"prompt string immediately in front of cursor (default: '> ')",

		'default=s' =>
			"for line/boolean/select: default value if user leaves prompt empty.",

		'validation|V=s' =>
			"for line/multi-line: validation type, one of:\n".
			"[[ #\@{*} >>comma-separated list of strings: [a,b,c]\n".
			"[[ #\@{*} >>negative comma-separated list:   ![a,b,c]\n".
			"[[ #\@{*} >>regular expression literal: /^(this|that)\$/i\n".
			"[[ #\@{*} >>negative regular expression: !/[^a-zA-Z0-9]/\n".
			"[[ #\@{*} >>range expression: min-max\n".
			"[[ #\@{*} >>'url' - must be a valid url\n".
			"[[ #\@{*} >>'port' - must be a valid port number\n".
			"[[ #\@{*} >>'vault_path' - given vault path must exist\n".
			"[[ #\@{*} >>'vault_path_and_key - given vault path:key must exist'\n",

		'msg=s' =>
			"specify the message to print on validation failure, default is ".
			"specific to the validation type used.",

		'min|minimum|m=i' =>
			"for multi-*: minimum items to enter - default: none",

		'max|maximum|M=i' =>
			"for multi-*: maximum items to enter - default: unlimited",

		'option|o=s@' =>
			"options to chose from (can be specified multiple times) either specify ".
			"a string that is used for both the value and the label, or in the form ".
			"of \"[value]label\"",

		'invert' =>
			"#R{(boolean only)} invert the answer (true becomes 0, false 1)",

		'echo' =>
			"#R{(secret-line only)} echo what the user types to the screen"
	]
});

# }}}
# genesis env-shell - provide a shell with the environment variables for the genesis environment {{{
define_command("env-shell", {
	summary => "Provide a shell with the environment variables and helper scripts for the genesis environment",
	usage => "<env> env-shell [<options...>]",
	alias => 'sh',
	function_group => Genesis::Commands::ENVIRONMENT,
	scope => 'env',
	option_group => Genesis::Commands::ENV_OPTIONS,
	options => [
		'shell|s=s' =>
			"Use the provided shell (default: /bin/bash)",

		'no-bosh' =>
			"Don't connect to bosh",

		'no-vault' =>
			"Don't connect to vault",

		'hook|H=s' =>
			"Pretend to be the specified hook for generating script environment",
	],
});

# }}}
# genesis hack - run a method with arguments inside the genesis environment {{{
#
define_command("hack", {
	summary => "Run a method with arguments inside the Genesis environment",
	usage => "hack <module> <method> [<arg> ...]",
	description =>
		'This is a special command that is not intended to be used by end users, '.
		'but rather by developers of Genesis itself.  It allows for running a '.
		'method with arguments inside the Genesis environment, which is useful for '.
		"testing and development. \n".
		"\n".
		'For example, to run the `Genesis::Env->search_for_env_file` method with '.
		"the arguments 'dev' and 'default', you would run: \n".
		" #g{genesis} #G{hack} Genesis::Env search_for_env_file dev default\n".
		"\n".
		'Note that $env and $top are special arguments that are replaced with the '.
		"current environment and top-level directory objects, respectively.",
	function_group => Genesis::Commands::DEV,
	scope => ['env','repo','any'],
	option_group => Genesis::Commands::ENV_OPTIONS,
});
# }}}
# }}}

###########################################################################
sub main {

	if (in_callback) {
		debug "#G{genesis} callback (using vault #C{'$ENV{GENESIS_TARGET_VAULT}'})...";
	} else {
		debug "#G{genesis} starting up...";
		$ENV{GENESIS_CALLER_DIR} = Cwd::getcwd();
	}

	my ($cmd, @args);
	my $no_warn = 1;
	my $path = '';
	$ENV{GENESIS_PREFIX_TYPE}="none";

	if ($_[0] =~ /^@/) {
		# @-notation for specifying environment
		my $pattern = shift;
		my ($env_pattern,$type_pattern) = $pattern =~ /^@([^:]*)(?::(.*))?$/;
		bail(
			'Invalid file search specifies - expecting @<env-match>[:deployment-match] or @:<deployment-match>/'
		) unless $type_pattern || $env_pattern;
		$ENV{GENESIS_PREFIX_TYPE} = "search";
		$ENV{GENESIS_PREFIX_SEARCH} = $pattern;
		if ($env_pattern) {
			require Genesis::Env;
			($ENV{GENESIS_DEPLOYMENT_ROOT}, $path) = Genesis::Env->search_for_env_file($env_pattern, $type_pattern);
		} elsif ($type_pattern) {
			require Genesis::Top;
			($ENV{GENESIS_DEPLOYMENT_ROOT},$path) = Genesis::Top->search_for_repo_path($type_pattern);
		} else {
			bail(
				'Invalid file search specifies - expecting @[<deployment-match>/]<env-match> or @<deployment-match>/'
			);
		}
	}
	while (@_ > 0) {
		my $arg = shift @_;

		if ($ENV{LANG}) {
			eval {$arg = decode($ENV{LANG},$arg)};
			if ($@ && $no_warn) {
				warning(
					"Environment variable \$LANG contains invalid value.  Some output ".
					"may be garbled as a result"
				);
				$no_warn = 0;
			}
		}

		if ($cmd || $arg =~ m/^-+/) {
			if ($arg eq '-C') {
				bail(
					"Cannot specify -C after environment name when using prefix style calls\n"
				) if ($ENV{GENESIS_PREFIX_TYPE} =~ /file$/ );
				$path = shift @_;
				$ENV{GENESIS_PREFIX_TYPE} = "option_c"
			} else {
				push @args, $arg;
			}
		} elsif ($arg =~ /^@/) {
			bail(
				"Must use @-notation before the Genesis subcommand."
			);
		} else {
			if (has_command($arg) || $arg eq 'help') {
				# argument matches a command (or alias) -- assume its a command
				$cmd = $arg;
			} else {
				if ($arg =~ /\.yml/ || -f $arg.'.yml' || equivalent_commands($_[0],'create')) {
					bail(
						"Cannot specify both -C and explicit file before the Genesis subcommand"
					) if ($ENV{GENESIS_PREFIX_TYPE} eq 'option_c');
					bail(
						"Cannot specify multiple explicit file before the Genesis subcommand"
					) if ($ENV{GENESIS_PREFIX_TYPE} =~ /file/);

					if ($arg =~ /\.yml/) { # explicit file
						bail(
							"Explicit environment file specified, but does not exist."
						) unless -f $arg || $_[0] eq 'new';
						$ENV{GENESIS_PREFIX_TYPE} = 'explicit_file';
						$path = $arg;
					} elsif (-f $arg.".yml" || equivalent_commands($_[0],'create')) {
						$ENV{GENESIS_PREFIX_TYPE} = 'file';
						$path = $arg.".yml";
					} else {
						command_help("Unrecognized command, path or file '$arg'",2);
					}
				} else {
					command_help("Unrecognized command, path or file '$arg'",2);
				}
			}
		}
	}

	# Default commands based on arguments alone
	unless ($cmd) {
		if (@args and scalar(@args) == 1 && $args[0] =~ m/^(-v|--version)$/) {
			$cmd = 'version';
			@args = ();
		} elsif (grep {/^(-h|--help)$/} @args) {
			$cmd = 'help',
			@args = (grep {$_ !~ /^(-h|--help)$/} @args);
		} else {
			command_help('No known command specified',2)
		}
	}

	if ($cmd) {
		unshift(@args, "-C", $path) if $path;
		trace("running command '$cmd'");
		trace("arguments are [".join(', ', @args)."]");
		if (has_command $cmd) {
			prepare_command $cmd, @args;
			set_top_path;
			check_embedded_genesis;
			command_usage(0) if get_options->{help};
			build_command_environment;
			check_prereqs unless command_properties->{skip_check_prereqs};
			run_command;
		} else {
			command_help('Unknown command: #G{$cmd}',2)
		}
		exit 0;
	}
}

END {
	my $rc = $?;
	require Service::Vault::Local;
	Service::Vault::Local->shutdown_all();
	my $level = envset('QUIET') ? 'ERROR' : 'INFO';
	logger->configure_log(
		level => $level,
		style => $ENV{GENESIS_LOG_STYLE} // $Genesis::RC->get('output_style','plain'),
	) unless logger->is_logging($level);
	trace("Genesis process $$ exited with an exit code of $rc") unless in_callback;
	$? = $rc; # Have to set the exit code again before leaving...
}

main(@ARGV);
# vim: fdm=marker:foldlevel=1:noet
