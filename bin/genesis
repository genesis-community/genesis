#!/usr/bin/env perl
# vim:ft=perl:noet:ts=4:sts=4:sw=4
use strict;
use warnings;

# non-core modules
use JSON::PP qw/decode_json encode_json/;
use HTTP::Tiny;
# NOTE: if you add more non-core modules,
# be sure to update ./pack!

use Getopt::Long qw/GetOptionsFromArray :config no_ignore_case/;
use File::Temp qw/tempdir tempfile/;
use File::Basename qw/dirname basename/;
use POSIX qw/strftime/;
use FindBin;
use Socket qw/inet_ntoa/;
use Cwd qw/getcwd abs_path/;
use lib "$FindBin::Bin/../lib";

our $VERSION = "(development)";
our $GITHUB_URL = "https://github.com/starkandwayne/genesis";
our $USER_AGENT_STRING = "genesis/$VERSION";

sub DumpJSON {
	my ($file, $data) = @_;
	open my $fh, ">", $file or die "Unable to write to $file: $!\n";
	print $fh encode_json($data);
	close $fh;
}

sub LoadFile {
	my ($file) = @_;
	decode_json(qx(spruce json $file));
}

sub Load {
	my ($yaml) = @_;

	my $tmp = workdir();
	open my $fh, "|-", "spruce json >$tmp/yaml.json"
		or die "Failed to execute `spruce json': $!\n";
	print $fh $yaml;
	close $fh;

	return LoadFile("$tmp/yaml.json")
}

my $END_HOOKS = [];
sub at_exit {
	my ($fn) = @_;
	push @$END_HOOKS, $fn;
}

END {
	$_->($?) for @$END_HOOKS;
}

sub envset {
	my ($var) = @_;
	return (defined $ENV{$var} and $ENV{$var} =~ m/^(1|y|yes|true)$/i);
}

sub envdefault {
	my ($var, $default) = @_;
	return defined $ENV{$var} ? $ENV{$var} : $default;
}

sub valid_envs {
	my (%envs, $json);
	foreach (glob "*.yml") {
		eval {$json = decode_json(qx{spruce json "$_" 2>/dev/null});};
		next if $@;
		next unless $json && $json->{params} && $json->{params}{env};
		(my $label= $_) =~ s/\.yml$//;
		$envs{$label} = {
			file  => $_,
			env   => $json->{params}{env},
			vault => $json->{params}{vault} || join('/',(split('-', $json->{params}{env}))),
			bosh  => $json->{params}{bosh}  || $json->{params}{env}
		}
	}
	return %envs;
}

sub ago {
	my ($ts) = @_;
	my $ago = time - $ts;
	if ($ago >  90 * 86400) { return sprintf("%i months ago", $ago / 30 / 86400); }
	if ($ago >= 21 * 86400) { return sprintf("%i weeks ago", $ago / 7  / 86400); }
	if ($ago >= 2  * 86400) { return sprintf("%i days ago", $ago / 86400); }
	if ($ago >= 90 * 60)    { return sprintf("%i hours ago", $ago / 3600); }
	if ($ago >  60)         { return sprintf("%i minutes ago", $ago / 60); }
	return "just now";
}

sub colorize {
	my ($c, $msg) = @_;
	return $msg if envset('NOCOLOR');
	$c = substr $c, 1, 1;
	my %color = (
		'k'		=> "\e[30m",     #black
		'K'		=> "\e[1;30m",   #black (BOLD)
		'r'		=> "\e[31m",     #red
		'R'		=> "\e[1;31m",   #red (BOLD)
		'g'		=> "\e[32m",     #green
		'G'		=> "\e[1;32m",   #green (BOLD)
		'y'		=> "\e[33m",     #yellow
		'Y'		=> "\e[1;33m",   #yellow (BOLD)
		'b'		=> "\e[34m",     #blue
		'B'		=> "\e[1;34m",   #blue (BOLD)
		'm'		=> "\e[35m",     #magenta
		'M'		=> "\e[1;35m",   #magenta (BOLD)
		'p'		=> "\e[35m",     #purple (alias for magenta)
		'P'		=> "\e[1;35m",   #purple (BOLD)
		'c'		=> "\e[36m",     #cyan
		'C'		=> "\e[1;36m",   #cyan (BOLD)
		'w'		=> "\e[37m",     #white
		'W'		=> "\e[1;37m",   #white (BOLD)
	);

	if ($c eq "*") {
		my @rainbow = ('R','G','Y','B','M','C');
		my $i = 0;
		my $msgc = "";
		foreach my $char (split //, $msg) {
			$msgc = $msgc . "$color{$rainbow[$i%6]}$char";
			if ($char =~ m/\S/) {
				$i++;
			}
		}
		return "$msgc\e[0m";
	} else {
		return "$color{$c}$msg\e[0m";
	}
}

sub csprintf {
	my ($fmt, @args) = @_;
	return '' unless $fmt;
	my $s = sprintf($fmt, @args);
	$s =~ s/(#[KRGYBMPCW*]\{)(.*?)(\})/colorize($1, $2)/egi;
	return $s;
}
sub explain(@) {
	return if envset "QUIET";
	my $colorize = $ENV{NOCOLOR};
	$ENV{NOCOLOR} = "true" if (! -t STDOUT);
	print csprintf(@_);
	$ENV{NOCOLOR} = $colorize;
	print "\n";
}

sub debug(@) {
	return unless envset "DEBUG";
	print STDERR "DEBUG> ";
	my $colorize = $ENV{NOCOLOR};
	$ENV{NOCOLOR} = "true" if (! -t STDERR);
	print STDERR csprintf(@_);
	$ENV{NOCOLOR} = $colorize;
	print STDERR "\n";
}

sub trace(@) {
	return unless envset "TRACE";
	print STDERR "TRACE> ";
	print STDERR csprintf(@_);
	print STDERR "\n";
}

sub error {
	my @err = @_;
	unshift @err, "%s" if $#err == 0;
	print STDERR csprintf(@err) . "\n";
}

sub online {
	return !envset('OFFLINE');
}

sub execute {
	my ($prog) = @_;
	debug "executing `#C{$prog} 2>&1`";
	my $out = qx($prog 2>&1);
	my $rc = $?;

	if ($rc != 0) {
		debug "command exited #R{%d}.", $rc >> 8;
		debug "--------------------------------";
		debug $out;
		debug "--------------------------------";
		return 0;
	}
	return 1;
}

sub system_execute {
	my ($prog) = @_;
	debug "executing `#C{$prog}`";
	my $out = system "$prog";
	my $rc = $?;

	if ($rc != 0) {
		debug "command exited #R{%d}.", $rc >> 8;
		return 0;
	}
	return 1;
}

sub mkfile_or_fail {
	my ($f, $c) = @_;
	debug "creating file $f";
	eval {
		open my $fh, ">", $f;
		print $fh $c;
		close $fh;
	} or die "Error creating file $f: $!\n";
}

# mkdir_or_fail $dir;
sub mkdir_or_fail {
	my ($dir) = @_;
	return if -d $dir;
	debug "creating directory $dir/";
	system("mkdir", "-p", "$dir/") == 0 or die "Unable to create directory $dir/: $!\n";
}
# chdir_or_fail $dir;
sub chdir_or_fail {
	my ($dir) = @_;
	debug "changing current working directory to $dir/";
	chdir $dir or die "Unable to change directory to $dir/: $!\n";
}

# symlink_or_fail $source $dest;
sub symlink_or_fail {
	my ($source, $dest) = @_;
	-d $source or die "$source does not exist!\n";
	-e $dest and die abs_path($dest)." already exists!";
	symlink($source, $dest) or die "Unable to link $source to $dest: $!\n";
}

our @DIRSTACK;
sub pushd {
	my ($dir) = @_;
	push @DIRSTACK, Cwd::cwd;
	chdir_or_fail($dir);
}
sub popd {
	@DIRSTACK or die "popd called when we don't have anything on the directory stack; please file a bug\n";
	chdir_or_fail(pop @DIRSTACK);
}

# copy_or_fail $from, $to;
sub copy_or_fail {
	my ($from, $to) = @_;
	-f $from or die "$from: $!\n";
	open my $in,  "<", $from or die "Unable to open $from for reading: $!\n";
	open my $out, ">", $to   or die "Unable to open $to for writing: $!\n";
	print $out $_ while (<$in>);
	close $in;
	close $out;
}
# chmod_or_fail 0755, $path; <-- don't quote the mode. make it an octal number.
sub chmod_or_fail {
	my ($mode, $path) = @_;
	-e $path or die "$path: $!\n";
	chmod $mode, $path;
}

# check we're in a Genesis v2 directory
sub in_repo_dir {
	return  -d ".genesis" && -e ".genesis/config";
}

# workdir;
my $WORKDIR;
sub workdir {
	if (!defined $WORKDIR) {
		$WORKDIR = tempdir(CLEANUP => 1);
	}
	return $WORKDIR;
}
# put_file $path, $contents;
sub put_file {
	my ($path, $contents, $mode) = @_;
	debug "populating $path file";
	open my $fh, ">", $path
		or die "Unable to open $path for writing: $!\n";
	chmod_or_fail $mode, $path if defined $mode;
	print $fh $contents || "";
	close $fh;
}

# get_file $path
sub get_file {
	my ($file) = @_;
	open my $fh, "<", $file
		or die "failed to open '$file' for reading: $!\n";
	my $contents = do { local $/; <$fh> };
	close $fh;
	return $contents;
}

sub yaml_bool {
	my ($bool, $default) = @_;
	return ($default || 0) unless defined($bool);
	return $bool;
}

sub validate_subkits {
	my ($kit, $version, $meta, @subkits) = @_;
	for my $sk (@subkits) {
		die "You specified a subkit without a name\n" unless $sk;
		my $path = kit_file($kit, $version, "subkits/$sk", 0);
		my ($k, $v) = ($kit, $version);
		$k ||= "dev";
		$v = "latest" unless defined $v;
		die "No subkit '$sk' found in kit $k/$v.\n"
			unless -d $path;
	}

	my %requested_subkits = map { $_ => 1 } @subkits;
	for my $sk (@{$meta->{subkits}}) {
		if ($sk->{choices}) {
			my $matches = 0;
			my $min_matches = 1;
			my @choices;
			for my $choice (@{$sk->{choices}}) {
				push @choices, $choice->{subkit} if defined $choice && defined $choice->{subkit};
				if (! defined $choice->{subkit}){
					$min_matches = 0;
				} elsif ($requested_subkits{$choice->{subkit}}) {
					$matches++;
				}
			}
			my $choices = join(", ", map { "'$_'" } @choices);
			if ($matches > 1) {
				die "You selected too many subkits for your $sk->{type}. Should be only one of $choices\n";
			}
			if ($matches < $min_matches) {
				die "You must select a subkit to provide your $sk->{type}. Should be one of $choices\n";
			}
		}
	}
}

sub run_subkit_hook {
	my ($kit, $version, @subkits) = @_;
	my $hook_dir = kit_file($kit, $version, "hooks", 0); # grab subkit hook + any helpers
	my $hook = "$hook_dir/subkit";
	return @subkits unless -f $hook;


	$kit ||= "dev";
	$version = "latest" unless defined $version;
	chmod(0755,$hook) unless -e $hook;

	my $cmd = "$hook " . join(" ", map { "'$_'" } @subkits);
	my $out = qx($cmd);
	die "Error running subkit hook for $kit/$version. Contact your kit author for a bugfix.\n"
		if $? >> 8;

	@subkits = map { $_ =~ s/^\s+|\s+$//g; $_ } split /\n/, $out, -1;
	pop @subkits if @subkits && $subkits[-1] eq "";
	return @subkits;
}

sub run_param_hook {
	my ($kit, $version, $env_name, $vault_prefix, $params, @subkits) = @_;
	my $hook_dir = kit_file($kit, $version, "hooks", 0); # grab params hook + any helpers
	my $hook = "$hook_dir/params";
	return $params unless -f $hook;


	$kit ||= "dev";
	$version = "latest" unless defined $version;
	chmod(0755,$hook) unless -e $hook;

	my $dir = workdir;
	DumpJSON "$dir/in", $params;
	my $cmd = "$hook $dir/in $dir/out " . join(" ", map { "'$_'" } @subkits);
	$ENV{GENESIS_ENVIRONMENT_NAME} = $env_name;
	$ENV{GENESIS_VAULT_PREFIX} = $vault_prefix;
	system($cmd);
	die "\nNew environment creation cancelled.\n"
		if $? >> 8 eq 130;
	die "Error running params hook for $kit/$version. Contact your kit author for a bugfix.\n"
		if $? >> 8;

	# FIXME: get a better error message when json fails to load
	open my $fh, "<", "$dir/out";
	my @json = <$fh>;
	close $fh;
	return decode_json(join("\n",@json));
}

sub new_environment {
	my ($meta, $kit, $version, $env, $vault_prefix, $params, @subkits) = @_;

	$kit     = "dev"    unless defined $kit;
	$version = "latest" unless defined $version;

	my $file = "$env.yml";
	open my $fh, ">", $file or die "Couldn't write to $file: $!";
	print $fh <<EOF;
---
kit:
  name:    $kit
  version: $version
EOF
	if (! @subkits) {
		print $fh "  subkits: []\n";
	} else {
		print $fh "  subkits:\n";
		for my $subkit (@subkits) {
			print $fh <<EOF;
  - $subkit
EOF
		}
	}
	print $fh <<EOF;

params:
  env:   $env
  vault: $vault_prefix
EOF
	if (defined($ENV{GENESIS_BOSH_ENVIRONMENT})) {
		print $fh <<EOF;
  bosh:  $ENV{GENESIS_BOSH_ENVIRONMENT}
EOF
	} elsif (defined($ENV{BOSH_ENVIRONMENT})) {
		print $fh <<EOF;
  bosh:  $ENV{BOSH_ENVIRONMENT}
EOF
	}

	for my $param (@$params) {
		print $fh "\n";
		my $indent = "  # ";
		if (defined $param->{comment}) {
			for my $line (split /\n/, $param->{comment}) {
				print $fh "${indent}$line\n";
			}
		}
		if (defined $param->{example}) {
			print $fh "${indent}(e.g. $param->{example})\n";
		}

		$indent = $param->{default} ? "  #" : "  ";

		for my $val (@{$param->{values}}) {
			my $k = (keys(%$val))[0];
			# if the value is a spruce operator, we know it's a string, and don't need fancy encoding of the value
			# this helps us not run into issues resolving the operator
			my $v = $val->{$k};
			if (defined $v && ! ref($v) && $v =~ m/^\(\(.*\)\)$/) {
				print $fh "${indent}$k: $v\n";
				next;
			}
			my $tmpdir = workdir;
			open my $tmpfile, ">", "$tmpdir/value_formatting";
			print $tmpfile encode_json($val);
			close $tmpfile;
			open my $spruce, "-|", "spruce merge $tmpdir/value_formatting";

			for my $line (<$spruce>) {
				chomp $line;
				next unless $line;
				next if $line eq "---";
				print $fh "${indent}$line\n";
			}
			close $spruce;
			die "Unable to convert JSON to spruce-compatible YAML. This is a bug\n"
				if $? >> 8;
		}
	}
	close $fh;
}

sub kit_yaml_files_in {
	my ($env, $dir, @subkits) = @_;
	$env =~ s/\.ya?ml$//;

	my @files = glob "$dir/base/*.yml";
	push @files, map { glob "$dir/subkits/$_/*.yml" } @subkits;
	return @files;
}

sub kit_yaml_files {
	my ($env) = @_;
	my @files;

	my $kit     = get_key($env, 'kit.name');
	my $version = get_key($env, 'kit.version');
	my @subkits = @{get_key($env, 'kit.subkits', [])};
	my $meta = read_kit_metadata($kit, $version);
	validate_subkits($kit, $version, $meta, @subkits);

	if ($kit && $version && $kit ne 'dev') {
		my $dir = workdir();
		qx(tar -xz -C $dir --strip-components 1 -f .genesis/kits/$kit-$version.tar.gz);
		$? == 0 or die;
		return kit_yaml_files_in($env, $dir, @subkits);
	}

	if (-d "dev") {
		return kit_yaml_files_in($env, "dev", @subkits);
	}

	die "No kit/version detected in $env.\n";
}

# takes a list of tokens, in order, and generates
# all strictly ordered combinations of them.
#
# for example:
#  [us, east, 1] -> [[us]
#                    [us-east]
#                    [us-east-1]]
#
sub expand_tokens {
	my @tokens = @_;

	my @l;
	my @pre;

	for (@tokens) {
		push @pre, $_;
		push @l, join '-', @pre;
	}

	return @l;
}

# return a list of the hyphen-separated tokens
# that form a common prefix to both arguments.
#
# for example:
#   us-east-1-preprod-a
#   us-east-1-sandbox-a
#   ->    (us, east, 1)
#
sub common_base {
	my ($a, $b) = @_;
	my @a = split /-/, $a;
	my @b = split /-/, $b;
	my @c = (); # common

	while (@a and @b) {
		$a = shift @a;
		$b = shift @b;
		last unless $a eq $b;
		push @c, $a;
	}
	return @c;
}

# return a list of the hyphen-separated tokens
# that form a unique suffix for the second argument.
#
# for example:
#   us-east-1-preprod-a
#   us-east-1-sandbox-a
#   ->     us-east-1, (sandbox, a)
sub unique_suffix {
	my ($a, $b) = @_;
	my @a = split /-/, $a;
	my @b = split /-/, $b;
	my @pre;

	while (@a and @b) {
		last if $a[0] ne $b[0];
		$a = shift @a;
		$b = shift @b;
		push @pre, $a;
	}
	return join('-', @pre), @b;
}

sub mergeable_yaml_files {
	my ($file) = @_;
	$file =~ s/\.yml$//;
	my @parts = split /-/, $file;

	my @ll;
	if ($ENV{PREVIOUS_ENV}) {
		for (expand_tokens(common_base($file, $ENV{PREVIOUS_ENV}))) {
			my $here = ".genesis/cached/$ENV{PREVIOUS_ENV}/$_.yml";
			push @ll, $here if -f $here;
		}
		my ($pre, @unique) = unique_suffix($ENV{PREVIOUS_ENV}, $file);
		$pre = "$pre-" unless $pre eq "";
		for (map { "$pre$_" } expand_tokens(@unique)) {
			my $here = "$_.yml";
			push @ll, $here if -f $here;
		}

	} else {
		while (@parts) {
			my $here = join('-', @parts) . ".yml";
			push @ll, $here if -f $here;
			pop @parts;
		}
		@ll = reverse @ll;
	}
	return @ll;
}

sub standalone_environment_yaml_files {
	my @envs = @_;
	grep { has_own_key($_, "params.env") } @envs;
}

sub has_key {
	my ($file, $key) = @_;
	for (mergeable_yaml_files $file) {
		chomp(my $out = qx(spruce json $_ | jq -r '.$key'));
		return 1 if $? == 0 and $out ne "null";
	}
	return 0;
}

sub has_own_key {
	my ($file, $key) = @_;
	return 0 unless -f $file;
	chomp(my $out = qx(spruce json $file | jq -r '.$key'));
	return 1 if $? == 0 and $out ne "null";
}

sub get_key {
	my ($file, $key, $default) = @_;
	return $default unless has_key($file, $key);

	my $result = Load(spruce_merge({ 'cherry-pick' => $key },
	                               mergeable_yaml_files($file)));
	for (grep {$_ !~ m/^\.?$/} split(/(\.|\[[0-9+]\])/, $key)) {
		if ($_ =~ m/^\[[0-9]+\]$/) {
			return $default unless @{$result}[0];
			$result = @{$result}[0];
		} else {
			return $default unless exists $result->{$_};
			$result = $result->{$_};
		}
	}
	return defined $result ? $result : $default;
}

sub has_subkit {
	my ($file, $subkit) = @_;
	my %subkits = map { $_ => 1 } @{get_key($file, "kit.subkits", [])};
	return $subkits{$subkit};
}

###########################################################################

sub dereference_param {
	my ($env, $key) = @_;
	my $val = get_key($env, $key);
	die "Unable to resolve '$key' for $env. This must be defined in the environment YAML.\n"
		unless defined $val;
	return $val;
}

sub dereference_params {
	my ($cmd, $env) = @_;
	$cmd =~ s/\$\{(.*?)\}/dereference_param($env, $1)/ge;
	return $cmd;
}

sub safe_path_exists {
	system "safe exists $_[0]";
	return ( $? eq 0);
}

sub safe_commands {
	my ($creds, %options) = @_;
	my @cmds;
	my $force_rotate = ($options{scope}||'') eq 'force';
	my $missing_only = ($options{scope}||'') eq 'add';
	for my $path (sort keys %$creds) {
		if (! ref $creds->{$path}) {
			my $cmd = $creds->{$path};
			$cmd = dereference_params($cmd, $options{env});

			if ($cmd =~ m/^(ssh|rsa)\s+(\d+)(\s+fixed)?$/) {
				my $safe = [$1, $2, "secret/$options{prefix}/$path"];
				push @$safe, "--no-clobber", "--quiet" if ($3 && !$force_rotate) || $missing_only;
				push @cmds, $safe;

			} elsif ($cmd =~ m/^dhparams?\s+(\d+)(\s+fixed)?$/) {
				my $safe = ['dhparam', $1, "secret/$options{prefix}/$path"];
				push @$safe, "--no-clobber", "--quiet" if ($2 && !$force_rotate) || $missing_only;
				push @cmds, $safe;

			} else {
				die "unrecognized credential type: `$cmd'\n";
			}
		} elsif ('HASH' eq ref $creds->{$path}) {
			for my $attr (sort keys %{$creds->{$path}}) {
				my $cmd = $creds->{$path}{$attr};
				$cmd = dereference_params($cmd, $options{env});

				if ($cmd =~ m/^random\s+(\d+)(\s+fmt\s+(\S+)(\s+at\s+(\S+))?)?(\s+allowed-chars\s+(\S+))?(\s+fixed)?$/) {
					my ($len, $format, $destination, $valid_chars, $fixed) = ($1, $3, $5, $7, $8);
					my @allowed_chars = ();
					if ($valid_chars) {
						@allowed_chars = ("--policy", $valid_chars);
					}
					my $safe = ['gen', $len, @allowed_chars, "secret/$options{prefix}/$path", $attr];
					push @$safe, "--no-clobber", "--quiet" if ($fixed && !$force_rotate) || $missing_only;
					push @cmds, $safe;
					if ($format) {
						$destination ||= "$attr-$format";
						my $safe = ["fmt", $format , "secret/$options{prefix}/$path", $attr, $destination];
						push @$safe, "--no-clobber", "--quiet" if ($fixed && !$force_rotate) || $missing_only;
						push @cmds, $safe;
					}

				} else {
					die "unrecognized credential type: `$cmd'\n";
				}
			}
		} else {
			die "unrecognized datastructure for $path. Please contact your kit author\n";
		}
	}

	return @cmds;
}

sub cert_commands {
	my ($certs, %options) = @_;
	my @cmds;
	my $force_rotate = ($options{scope}||'') eq 'force';
	my $missing_only = ($options{scope}||'') eq 'add';
	for my $path (sort keys %$certs) {
		my @cmd = (
			"x509",
			"issue",
			"secret/$options{prefix}/$path/ca",
			"--name", "ca.$path",
			"--ca");
		push @cmd, "--no-clobber", "--quiet" if !$force_rotate; # All CA certs are considered kept
		push @cmds, \@cmd;

		for my $cert (sort keys %{$certs->{$path}}) {
			next if $cert eq "ca";
			my $c = $certs->{$path}{$cert};

			die "Required 'names' value missing for cert at $path/$cert.\n" unless $c->{names}[0];
			my $cn = $c->{names}[0];
			$c->{valid_for} ||= "1y";

			my @name_flags = map {( "--name", dereference_params($_, $options{env}) )} @{$c->{names}};
			my @cmd = (
				"x509",
				"issue",
				"secret/$options{prefix}/$path/$cert",
				"--ttl", $c->{valid_for},
				@name_flags,
				"--signed-by", "secret/$options{prefix}/$path/ca");
			push @cmd, "--no-clobber", "--quiet" if $missing_only;
			push @cmds, \@cmd;
		}
	}
	return @cmds;
}

sub check_secret {
	my ($cmd, %options) = @_;
	my (@keys);
	my $type = $cmd->[0];
	my $path = $cmd->[2];
	if ($type eq 'x509') {
		if (grep {$_ eq '--signed-by'} @$cmd) {
			$type = "certificate";
			@keys = qw(certificate combined key);
		} else {
			$type = "CA certificate";
			@keys = qw(certificate combined crl key serial);
		}
	} elsif ($type eq 'rsa') {
		@keys = qw(private public);
	} elsif ($type eq 'ssh') {
		@keys = qw(private public fingerprint);
	} elsif ($type eq 'dhparam') {
		@keys = qw(dhparam-pem);
	} elsif ($type eq 'gen') {
		$type = 'random';
		my $path_offset = $cmd->[1] eq '-l' ? 3 : 2;
		$path_offset += 2 if $cmd->[$path_offset] eq '--policy';
		$path = $cmd->[$path_offset];
		@keys = ($cmd->[$path_offset + 1]);
	} elsif ($type eq 'fmt') {
		$type = 'random/formatted';
		@keys = ($cmd->[4]);
	} else {
		die "Unrecognized credential or certificate command: '".join(" ", @$cmd)."'\n";
	}

	my @missing = ();
	for (@keys) {
		system('safe', 'exists', "$path:$_");
		push @missing, ["[$type]", "$path:$_"] if $?;
	}
	return @missing;
}

###########################################################################

sub validate_repo_name {
	my ($name) = @_;
	return $name =~ m/^[a-z][a-z0-9-]+$/;
}

sub validate_env_name {
	my ($name) = @_;
	return $name =~ m/^[a-z][a-z0-9-]+$/
	    && $name !~ m/--/;
}

###########################################################################

our %ord_suffix = (11 => 'th', 12 => 'th', 13 => 'th', 1 => 'st', 2 => 'nd', 3 => 'rd');
sub ordify {
	return "$_[0]". ($ord_suffix{ $_[0] % 100 } || $ord_suffix{ $_[0] % 10 } || 'th')." ";
}

sub clean_heredoc {
	my $heredoc = join("",map {s/^\s*\|//; $_} split(/^/, shift));
	chomp $heredoc;
	return $heredoc;
}

sub __prompt_for_line {
	my ($prompt,$validation,$err_msg,$default,$allow_blank) = @_;
	$prompt = join(' ', grep {defined($_) && $_ ne ""} ($prompt, '>')) . " ";

	# `validate` is a sub with first argument the test value, and the second
	# being an optional error message
	my $validate;
	if (defined($validation)) {
		if (ref($validation) eq 'CODE') {
			$validate = $validation; # Only used by internal usage of prompts
		} elsif ($validation eq "url") {
			$validate = sub() {
				return "" if (is_valid_uri($_[0]));
				return ($_[1] ? $_[1] :"$_[0] is not a valid URL");
			}
		} elsif ($validation eq "port") {
			$validate = sub() {
				return "" if ( ($_[0] =~ m/^\d+$/) && ($_[0] >= 0 ) && ($_[0] <= 65535) );
				return ($_[1] ? $_[1] :"$_[0] is not a valid port");
			}
		} elsif ($validation =~ m/^(-?\d+(?:.\d+)?)-(-?\d+(?:.\d+)?)$/) {
			my ($__min,$__max) = ($1,$2);
			$validate = sub() {
				return "" if (($_[0] =~ m/^\d+$/) && ($_[0] >= $__min ) && ($_[0] <= $__max));
				return ($_[1] ? $_[1] : "$_[0] expected to be between $__min and $__max");
			}
		} elsif ($validation =~ m/^(!)?\/(.*)\/(i?m?s?)$/) {
			my $__vre;
			my $__negate = ($1 && $1 eq "!");
			# safe because the only thing being eval'ed is the optional i,s, or m
			eval "\$__vre = qr/\$2/$3"
				or die "Error compiling param regex: $!";
			$validate = $__negate ? sub() {
				return ($_[0] !~ $__vre ? "" : ( $_[1] ? $_[1] : "Matches exclusionary pattern"));
			} : sub() {
				return ($_[0] =~ $__vre ? "" : ( $_[1] ? $_[1] : "Does not match required pattern"));
			};
		} elsif ($validation =~ m/^(!)?\[([^,]+(,[^,]+)*)\]$/) {
			my @__vlist = split(",", $2);
			my $__negate = ($1 && $1 eq "!");
			$validate =  sub() {
				my $needle=shift;
				my @matches = grep {$_ eq $needle} @__vlist;
				return $__negate ?
					(scalar(@matches) == 0 ? "" : ($_[1] ? $_[1] : "Cannot be one of ".join(", ",@__vlist))):
					(scalar(@matches) != 0 ? "" : ($_[1] ? $_[1] : "Expecting one of ".join(", ",@__vlist)));
			}
		} elsif ($validation =~ m/^((^|,)[^,]+){2,}$/) { # Deprecated list match 2 or more
			my @__vlist = split(",", $validation);
			$validate = sub() {
				my $needle=shift;
				my @matches = grep {$_ eq $needle} @__vlist;
				return (scalar(@matches) != 0 ? "" : ($_[1] ? $_[1] : "Expecting one of ".join(", ",@__vlist)));
			}
		} elsif ($validation eq "vault_path") {
			$validate = sub() {
				return (safe_path_exists $_[0]) ? "" : ($_[1] ? $_[1] :"$_[0] not found in vault");
			}
		}
	}

	while (1) {
		print csprintf("%s", $prompt);
		chomp (my $in=<STDIN>);
		if ($in eq "" && defined($default)) {
			$in = $default;
			print(csprintf("\033[1A%s#C{%s}\n",$prompt, $in));
		}
		$in =~ s/^\s+|\s+$//g;

		return "" if ($in eq "" && $allow_blank);
		my $err="";
		if ($in eq "") {
			return "" if $allow_blank;
			$err= "#R{No default:} you must specify a non-empty string";
		} else {
			$err = &$validate($in,$err_msg) if defined($validate);
			$err = "#r{Invalid:} $err" if $err;
		}

		no warnings "numeric";
		return (($in eq $in + 0) ? $in + 0 : $in) unless $err;
		use warnings "numeric";
		error($err);
	}
}

sub __prompt_for_block {
	my ($prompt) = @_;
	$prompt = "$prompt (Enter <CTRL-D> to end)";
	(my $line = $prompt) =~ s/./-/g;
	print "\n$prompt\n$line\n";
	my @data = <STDIN>;
	return join("", @data);
}

sub prompt_for_boolean {
	my ($prompt,$default,$invert) = @_;
	my ($t,$f) = (JSON::PP::true,JSON::PP::false);

	my $true_re = qr/^(?:y(?:es)?|t(rue)?)$/i;
	my $false_re =  qr/^(?:no?|f(alse)?)$/i;
	my $val_prompt = "[y|n]";
	if (defined $default) {
		$default = $default ? "y" : "n" if $default =~ m/^[01]$/; # standardize
		$val_prompt = $default =~ $true_re ? "[#g{Y}|n]" : "[y|#g{N}]";
	}
	chomp $prompt;
	if ($prompt =~ /\[y\|n\]/) {
		# Allow a single line boolean prompt
		$prompt =~ s/\[y\|n\]/$val_prompt/;
		$val_prompt = $prompt;
		print "\n";
	} else {
		print "\n$prompt\n";
	}
	while (1) {
		my $answer = __prompt_for_line($val_prompt,undef,undef,$default,'allow_blank');
		return ($invert ? $f : $t) if $answer =~ $true_re;
		return ($invert ? $t : $f) if $answer =~ $false_re;
		error "#r{Invalid response:} you must specify y, yes, true, n, no or false";
	}
}
sub prompt_for_choices {
	my ($prompt, $choices, $min, $max, $labels, $err_msg) = @_;

	my %chosen;
	$labels ||= [];
	my $num_choices = scalar(@{$choices});
	for my $i (0 .. $#$choices) {
		$labels->[$i] ||= $choices->[$i];
		$prompt .= "\n  ".($i+1).") ".$labels->[$i];
	}
	my $line_prompt = "choice";
	$min ||= 0;
	$max ||= $num_choices;
	die "Illegal list maximum count specified. Please contact your kit author for a fix.\n"
		if $max < $min;

	print csprintf($prompt."\n\nMake your selections (leave $line_prompt empty to end):\n");

	my @ll;
	while (1) {
		my $v = __prompt_for_line(
			ordify(scalar(@ll) + 1) . $line_prompt,
			"1-$num_choices",
			$err_msg || "Invalid choice - enter a number between 1 and $max",
			undef,
			'allow_blank'
		);
		if ($chosen{$v}) {
			error "#r{ERROR:} ".$choices->[$v-1]." already selected - choose another value";
			next;
		}
		if ($v eq "") {
			if (scalar(@ll) < $min) {
				error "#r{ERROR:} Insufficient items provided - at least $min required.";
				next;
			}
			last;
		}
		push @ll, $choices->[$v-1];
		$chosen{$v} = 1;
		print(csprintf("\033[1A%s%s > #C{%s}\n",ordify(scalar(@ll)), $line_prompt, $labels->[$v-1]));
		last if scalar(@ll) == $max;
	}
	return \@ll;

}
sub prompt_for_choice {
	my ($prompt, $choices, $default, $labels, $err_msg) = @_;

	my $default_choice;
	my $num_choices = scalar(@{$choices});
	print "\n$prompt";
	for my $i (0 .. $#$choices) {
		my $label = (ref($labels) eq 'ARRAY' &&  $labels->[$i]) ? $labels->[$i] : $choices->[$i];
		print "\n  ".($i+1).") ".$label;
		if ($default && $default eq $choices->[$i]) {
			print csprintf(" #G{(default)}");
			$default_choice = $i+1;
		}
	}
	print "\n\n";
	my $c = __prompt_for_line(
		"Select choice",
		"1-$num_choices",
		$err_msg || "enter a number between 1 and $num_choices",
		$default_choice);

	print(csprintf("\033[1ASelect choice > #C{%s}\n", (ref($labels) eq 'ARRAY' &&  $labels->[$c-1]) ? $labels->[$c-1] : $choices->[$c-1]));
	return $choices->[$c-1];
}

sub prompt_for_line {
	my ($prompt,$label,$default,$validation,$err_msg) = @_;
	print "\n$prompt";
	my $padding = ($prompt =~ /\s$/) ? "" : " ";
	print(csprintf("%s", "${padding}#g{(default: $default)}")) if defined($default);
	print "\n";
	return __prompt_for_line(defined($label) ? $label : "", $validation, $err_msg, $default);
}

sub prompt_for_list {
	my ($type,$prompt,$label,$min,$max,$validation, $err_msg, $end_prompt) = @_;
	$label ||= "value";
	$min ||= 0;
	$end_prompt = "(leave $label empty to end)" unless defined($end_prompt);
	die "Illegal list maximum count specified. Please contact your kit author for a fix.\n"
		if (defined($max) and $max < 1);

	print csprintf("\n%s %s\n", $prompt, $end_prompt);

	my @ll;
	while (1) {
		my $v;
		if ($type eq 'line') {
			$v = __prompt_for_line(ordify(scalar(@ll) + 1) . $label, $validation, $err_msg, undef, 'allow_blank');
		} else {
			$v = __prompt_for_block(ordify(scalar(@ll) + 1) . $label);
		}
		if ($v eq "") {
			if (scalar(@ll) < $min) {
				error "#r{ERROR:} Insufficient items provided - at least $min required.";
				next;
			}
			last;
		}
		push @ll, $v;
		last if (defined($max) && scalar(@ll) == $max);
	}
	return \@ll;
}

sub prompt_for_block {
	printf("\n");
	return __prompt_for_block(@_);
}

sub parse_uri {
	my ($uri) = @_;
	# https://tools.ietf.org/html/rfc3986
    # We use very basic validation
	$uri =~ m/^(?<uri>
		(?<scheme>[a-zA-Z][a-zA-Z0-9+.-]+):\/\/
		(?<authority>
			(?:(?<userinfo>(?<user>[^:@]+)(?::(?<password>[^@]+)))?@)?
			(?<host>[a-zA-Z0-9.\-_~]+)?
			(?::(?<port>\d+))?
		)
		(?<path>\/(?:[a-zA-Z0-9-._~]|[a-f0-9]|[!\$&'()*+,;=:@])+(?:\/(?:[a-zA-Z0-9-._~]|[a-f0-9]|[!\$&'()*+,;=:@])*)*|(?:\/(?:[a-zA-Z0-9-._~]|[a-f0-9]|[!\$&'()*+,;=:@])+)*)?
		(?:\?(?<query>(?:[a-zA-Z0-9-._~]|[a-f0-9]|[!\$&'()*+,;=:@]|%[A-Fa-f0-9]{2})+))?
		(?:\#(?<fragment>(?:[a-zA-Z0-9-._~]|[a-f0-9]|[!\$&'()*+,;=:@])+))?
	)$/gsx;
	return %+;
}

sub is_valid_uri {
	my %components = parse_uri($_[0]);
	return unless ($components{scheme}||"") =~ /^(https?|file)$/;
	return unless $components{authority} || ($components{scheme} eq 'file' && $components{path});
	return $components{uri};
}

my $BOSH; # used for abstracting out the actual name of the installed
          # bosh (v2) cli (could be bosh, bosh2, or boshv2)
sub detect_bosh_version {
	my ($BOSH2_MIN_VERSION) = @_;
	foreach my $boshcmd ("bosh", "bosh2", "boshv2") {
		my $version = qx($boshcmd -v 2>&1 | grep version | head -n1);
		if ($version) {
			chomp($version);
			if ($version =~ s/version (\S+?)-.*/$1/){
				if (!new_enough("bosh2", $version, $BOSH2_MIN_VERSION)) {
					error "BOSH (v2) CLI v${version} is installed, but Genesis requires #R{at least $BOSH2_MIN_VERSION} - upgrade your BOSH CLI, via #B{https://github.com/cloudfoundry/bosh-cli/releases}";
				}
				$BOSH = $boshcmd;
			}
		}
	}
	if (!$BOSH) {
		error "Missing `bosh2' - install the BOSH (v2) CLI from #B{https://github.com/cloudfoundry/bosh-cli/releases}";
	}
}

sub is_create_env {
	my ($env) = @_;
	# convert env to file for env if not already done
	$env = "$env.yml" unless $env =~ /\.yml$/;
	return has_subkit($env, 'bosh-init') || has_subkit($env, 'create-env');
}

sub bosh_deploy {
	my ($target, $deployment, $path_to_manifest, @deploy_opts) = @_;
	my @args = ();
	if ($target eq "create-env") {
		@args = ("create-env", "--state", $deployment);
		push @args, "-n" if $ENV{BOSH_NON_INTERACTIVE};
		push @args, $path_to_manifest;
	} else {
		@args = ("-e", $target, "-d", $deployment);
		push @args, "-n" if $ENV{BOSH_NON_INTERACTIVE};
		push @args, "deploy", @deploy_opts, $path_to_manifest;
	}
	system($BOSH, @args) == 0 or return 1;
	return 0;
}

sub bosh_alias {
	my ($target) = @_;
	system($BOSH, "alias-env", $target) == 0, or exit 1;
}

sub bosh_run_errand {
	my ($target, $deployment, $errand) = @_;
	system($BOSH, "-n", "-e", $target, "-d", $deployment, "run-errand", $errand) == 0 or exit 1;
}

sub bosh_upload_stemcell {
	my ($name, $version, $sha1, $url) = @_;
	system($BOSH, "-n", "upload-stemcell", "--name", $name, "--version", $version, "--sha1", $sha1, $url) == 0 or exit 1;
}

sub bosh_download_cloud_config {
	my ($target, $path_to_cloudconfig) = @_;
	execute("$BOSH -e $target cloud-config > $path_to_cloudconfig") or
		die "Failed to download cloud-config from '$target' BOSH director.\n";
	die "No cloud-config defined on BOSH director '$target'.\n" unless -s $path_to_cloudconfig;
}

# `genesis bosh ...`
sub bosh_exec {
	die "not implemented";
}

sub write_stemcell_data {
	my ($file) = @_;
	my $stemcells = "{}";
	if ($ENV{GENESIS_INDEX} ne "no") {
		$stemcells = `curl -ks $ENV{GENESIS_INDEX}/v1/stemcell/latest | jq '. | map({"key": .name, "value": { "sha1": .sha1, "url": .url}}) | from_entries' -Mc`;
		die "Unable to contact the genesis index to retrieve stemcell data. Cannot continue." unless ($? == 0);
	}
	open my $fh, ">", $file;
	print $fh <<EOF;
---
meta:
  latest_stemcells: $stemcells

EOF
	close $fh;
}

sub spruce_vault_paths {
	my (@files) = @_;
	my $ymls = join(" ", @files);
	my @keys= qx/spruce vaultinfo --go-patch $ymls | spruce json | jq -r '.secrets[].key'/;
	if ($? != 0) {
		die "Failure while running spruce vaultinfo.\n";
	}
	my %paths = map {$_ =~ s/:.*?$//; $_ => 1} @keys;
	return keys %paths;
}

sub spruce_merge {
	my (@files) = @_;
	if (!@files) {
		my (undef, $file, $line) = caller;
		die "BUG DETECTED!  $file:$line called spruce_merge without any arguments.  Please file a bug report at $GITHUB_URL\n";
	}

	# spruce_merge({ prune => ['meta', 'pipeline']}, $file1, $file2)
	# spruce_merge({ prune => 'meta'}, $file1, $file2)
	my $opts = ref($files[0]) eq 'HASH' ? shift @files : {};
	my @flags;
	for my $flag (keys %$opts) {
		for my $value (ref($opts->{$flag}) ? @{ $opts->{$flag} } : ($opts->{$flag})) {
			push @flags, "--$flag", $value;
		}
	}
	push @flags, "--go-patch";

	open my $cmd, "-|", (qw(spruce merge), @flags, @files)
		or die "Failed to execute `spruce merge': $!\n";
	my $out = do { local $/; <$cmd> };
	close $cmd;
	exit ($? >> 8 ) unless $? == 0;
	return $out;
}

# finds the "name" of the deployment type that we are in
# (i.e. redis-deployments/... -> 'redis')
sub deployment_suffix {
	my $config = LoadFile(".genesis/config");
	die "No deployment type defined in .genesis/config." unless $config->{deployment_type};
	return $config->{deployment_type};
}

sub base_yaml_files {
	my ($env) = @_;
	my $type = deployment_suffix;
	my $dir = workdir;
	open my $fh, ">", "$dir/base.yml";
	print $fh <<EOF;
params:
  name: (( concat params.env "-$type" ))
name: (( grab params.name ))
EOF
	close $fh;
	return "$dir/base.yml";
}

sub merge_files {
	my ($env, $options) = @_;
	$env =~ s/(\.yml)?$/.yml/;

	my @files = ();
	push @files, base_yaml_files($env);
	push @files, kit_yaml_files($env);
	push @files, mergeable_yaml_files($env);
	push @files, grep { $_ } $options->{'cloud-config'};
	return \@files;
}

sub merge_manifest {
	my ($file, $options) = @_;
	$file =~ s/(\.yml)?$/.yml/;

	my @prunables = qw/meta pipeline params kit compilation/;
	push @prunables, qw/resource_pools disk_pools
	                    networks vm_types disk_types
	                    azs vm_extensions/
		unless $options->{'create-env'};

	if ($options->{'create-env'}) {
		my $dir = workdir;
		write_stemcell_data("$dir/cloud.yml");
		$options->{'cloud-config'} = "$dir/cloud.yml";
	}

	return spruce_merge({
			prune => [@prunables],
		},
		@{merge_files($file, $options)});
}

sub deploy_manifest {
	my ($env, $options) = @_;
	$ENV{REDACT} = '';
	my $dir = workdir;
	my $target = '';
	my $create_env = is_create_env($env);

	if (!$create_env) {
		$target = bosh_target_for($env);
		bosh_download_cloud_config($target, "$dir/cloud.yml");
		$options->{'cloud-config'} = "$dir/cloud.yml";
	} else {
		$ENV{OFFLINE} = 1; # set offline since there's no director to talk to
	}

	my $merge_opts = {
		'cloud-config' => $options->{'cloud-config'},
		'create-env'   => $create_env,
	};
	mkfile_or_fail("$dir/manifest.yml", merge_manifest($env, $merge_opts));
	my $deployment_prefix = get_key($env, 'params.env');
	$env =~ s/.yml$//;
	$deployment_prefix ||= $env;
	my $deployment = "$deployment_prefix-" . deployment_suffix;

	mkdir_or_fail(".genesis/manifests");

	$ENV{REDACT} = 'true';
	mkfile_or_fail(".genesis/manifests/$env.yml", merge_manifest($env, $merge_opts));

	if ($create_env) {
		$target = "create-env";
		$deployment = ".genesis/manifests/$env-state.yml";
	}
	my @deploy_opts;
	foreach (qw/no-redact fix recreate/) {
		push @deploy_opts, "--$_" if $options->{$_};
	}
	my $rc = bosh_deploy $target, $deployment, "$dir/manifest.yml", @deploy_opts;
	return $rc;
}

sub curl {
	my ($method, $url, $headers, $data, $skip_verify, $creds) = @_;
	my $flags = "-X '$method'";
	for my $header (keys %$headers) {
		$flags .= " -H '$header: $headers->{$header}'";
	}
	if ($data) {
		$flags .= " -d '$data'";
	}
	if ($skip_verify) {
		$flags .= " -k";
	}
	if ($creds) {
		$flags .= " -u '$creds'";
	}
	my $status = "";
	my $status_line = "";
	my @data = qx(curl -isL $url $flags);
	unless (scalar(@data) && $? == 0) {
		system "curl -L $url $flags"; # curl again to get stdout/err into concourse for debugging
		return 599, "Unable to execute curl command", "";
	}
	while (my $line = shift @data) {
		if ($line =~ m/^HTTP\/\d+\.\d+\s+((\d+)(\s+.*)?)$/) {
			$status_line = $1;
			$status = $2;
		}
		# curl -iL will output a second set of headers if following links
		if ($line =~ /^\s+$/ && $status !~ /^3\d\d$/) {
			last;
		}
	}
	return $status, $status_line, join("", @data);
}

###########################################################################

sub vault_auth {
	my %options = @_;
	for (qw/vault skip_verify secret_id role_id/) {
		next if exists $options{$_} and defined $options{$_};
		die "vault_auth() requires the '$_' argument; please file a bug.\n";
	}

	my ($code, $msg, $data) = curl "POST", "$options{vault}/v1/auth/approle/login", {
			'Content-type' => 'application/json',
		},
		encode_json({
			role_id => $options{role_id},
			secret_id  => $options{secret_id},
		}), $options{skip_verify};

	if ($code != 200) {
		die "Failed to authenticate to the Vault at $options{vault} using role ID $options{role_id}:\n".
			"HTTP $msg\n$data\n";
	}
	my $output;
	eval { $output = decode_json($data); 1 }
		or die "Invalid JSON received from the Vault at $options{vault}\n($data)\n";
	exists $output->{auth} and exists $output->{auth}{client_token}
		or die "No Client Token found in response from the Vault at $options{vault}\n($data)\n";

	$ENV{VAULT_TOKEN} = $output->{auth}{client_token};
	$output = qx(vault status 2>&1);
	if ($? != 0) {
		die "Failed to authenticate to the Vault at $options{vault}\n:`vault status` said:\n$output\n";
	}

	$output = qx(vault read secret/handshake 2>&1);
	if ($? != 0) {
		die "Failed to retrieve secret/handshake from the Vault at $options{vault}; assuming token authentication failure.\n";
	}
}

sub commit_changes {
	my ($indir, $outdir, $branch, $key, $message) = @_;

	# the below copying of files into new repos from older repos is all
	# done in the name of avoiding merge conflicts, or weird errors when
	# rebasing, and git discovers that there are no changes after you rebase

	# create an output git repo based off of latest origin/$branch
	system("cp -R $indir $outdir") == 0 or exit 1;
	pushd $outdir;

	# We need this here so we can do a manual pull after the build/deploy, but
	# prior to pushing. Rebasing inside the concourse resource will not work,
	# as we are changing files that are not watched by the resources. This may
	# cause conflicts as older commits try to change more and more things that
	# have already been updated in the .genesis/manifests directory.
	#
	my $tmp = workdir;
	mkdir_or_fail("$tmp/home/.ssh");
	chmod_or_fail(0700, "$tmp/home/.ssh");
	put_file("$tmp/home/.ssh/key", $key, 0600);
      put_file("$tmp/home/.ssh/config", <<EOF);
Host *
  StrictHostKeyChecking no
  UserKnownHostsFile /dev/null
  LogLevel QUIET
  IdentityFile $tmp/home/.ssh/key
EOF

	$ENV{GIT_AUTHOR_NAME}   ||= 'Concourse Bot';
	$ENV{GIT_AUTHOR_EMAIL}  ||= 'concourse@pipeline';
	$ENV{GIT_COMMITTER_NAME}  = $ENV{GIT_AUTHOR_NAME};
	$ENV{GIT_COMMITTER_EMAIL} = $ENV{GIT_AUTHOR_EMAIL};
	$ENV{GIT_ASKPASS}         = "/bin/false";
	$ENV{GIT_SSH_COMMAND}     = "ssh -F $tmp/home/.ssh/config";
	$ENV{HOME}                = "$tmp/home";

	# no need to fetch or pull from origin/$branch, as the git resource in the pipeline should
	# have the latest data from origin, we just need to reset to the newest applicable ref
	system(qq( HOME=$tmp/home \
	             git reset --hard origin/$branch && \
	             git checkout $branch && \
	             git pull origin $branch)) == 0 or exit 1;
	popd;

	# find and copy all potential changes to the outdir
	pushd $indir;
	my @output = qx(git status --porcelain);
	popd;
	my @changes = map { chomp; s/^...//; $_; } @output;
	for my $file (@changes) {
		mkdir_or_fail(dirname("$outdir/$file"));
		system("cp", "-R", "$indir/$file", "$outdir/$file") == 0 or exit 1;
	}

	# check if any changes actually exist in the outdir (potential changes may have alread
	# been tracked after $indir's commit, so they could disappear here), then commit them
	pushd $outdir;
	my $output = qx(git status --porcelain 2>&1);
	if ($output) {
		system(qq( HOME=$tmp/home \
		             git add -A && \
		             git status && \
		             git --no-pager diff --cached && \
		             git commit -m "CI commit: $message" ));
	}
}

sub read_pipeline {
	my ($file) = @_;

	my @errors = ();
	my $p = Load(spruce_merge($file));
	unless (exists $p->{pipeline}) {
		# fatal error
		push @errors, "Missing top-level 'pipeline:' key.";
		return $p, \@errors;
	}

	unless (ref($p->{pipeline}) eq 'HASH') {
		# fatal error
		push @errors, "Top-level 'pipeline:' key must be a map.";
		return $p, \@errors;
	}
	for (keys %{$p->{pipeline}}) {
		push @errors, "Unrecognized `pipeline.$_' key found."
			unless m/^(name|public|tagged|errands|vault|git|slack|hipchat|email|boshes|task|layout|layouts|debug|stemcells|skip_upkeep|locker)$/;
	}
	for (qw(name vault git boshes)) {
		push @errors, "`pipeline.$_' is required."
			unless $p->{pipeline}{$_};
	}

	# validate pipeline.vault.*
	if (ref($p->{pipeline}{vault}) ne 'HASH') {
		push @errors, "`pipeline.vault' must be a map.";
	} else {
		# required subkeys
		for (qw(url)) {
			push @errors, "`pipeline.vault.$_' is required."
				unless $p->{pipeline}{vault}{$_};
		}
		# allowed subkeys
		for (keys %{$p->{pipeline}{vault}}) {
			push @errors, "Unrecognized `pipeline.vault.$_' key found."
				unless m/^(url|role|secret|verify)$/;
		}
	}

	# validate pipeline.git.*
	if (ref($p->{pipeline}{git}) ne 'HASH') {
		push @errors, "`pipeline.git' must be a map.";
	} else {
		# required subkeys
		for (qw(owner repo private_key)) {
			push @errors, "`pipeline.git.$_' is required."
				unless $p->{pipeline}{git}{$_};
		}
		# allowed subkeys
		for (keys %{$p->{pipeline}{git}}) {
			push @errors, "Unrecognized `pipeline.git.$_' key found."
				unless m/^(host|owner|repo|private_key)$/;
		}
	}

	# validate stemcells
	if (! $p->{pipeline}{skip_upkeep}) {
		if (! $p->{pipeline}{stemcells}) {
			push @errors, "Neither `pipeline.skip_upkeep' nor `pipeline.stemcells' were configured. One or the other is required.";
		} elsif (ref($p->{pipeline}{stemcells}) ne 'HASH') {
			push @errors, "`pipeline.stemcells' must be a map.";
		}
	}

	# validate locker
	if ($p->{pipeline}{locker}) {
		if (ref($p->{pipeline}{locker}) ne 'HASH') {
			push @errors, "`pipeline.locker' must be a map.";
		} else {
			for (qw/url username password/) {
				push @errors, "`pipeline.locker.$_' is required."
					unless $p->{pipeline}{locker}{$_};
			}
			for (keys %{$p->{pipeline}{locker}}) {
				push @errors, "Unrecognized `pipeline.locker.$_' key found."
					unless m/^(url|username|password|ca_cert|skip_ssl_validation)/;
			}
		}
	} else {
		$p->{pipeline}{locker}{url} = "";
	}

	# validate notifications
	my $n = 0;
	for (qw(slack hipchat email)) {
		$n++ if exists $p->{pipeline}{$_};
	}
	if ($n == 0) {
		push @errors, "No notification stanzas defined.  Please define `pipeline.slack', 'pipeline.hipchat' or `pipeline.email'.\n";
	} else {
		if ($p->{pipeline}{slack}) {
			# validate pipeline.slack.*
			if (ref($p->{pipeline}{slack}) ne 'HASH') {
				push @errors, "`pipeline.slack' must be a map.";
			} else {
				# required subkeys
				for (qw(webhook channel)) {
					push @errors, "`pipeline.slack.$_' is required."
						unless $p->{pipeline}{slack}{$_};
				}
				# allowed subkeys
				for (keys %{$p->{pipeline}{slack}}) {
					push @errors, "Unrecognized `pipeline.slack.$_' key found."
						unless m/^(webhook|channel|username|icon)$/;
				}
			}
		}
		if ($p->{pipeline}{hipchat}) {
			# validate pipeline.hipchat.*
			if (ref($p->{pipeline}{hipchat}) ne 'HASH') {
				push @errors, "`pipeline.hipchat' must be am ap.";
			} else {
				# required subkeys
				for (qw/room_id token/) {
					push @errors, "`pipeline.hipchat.$_' is required."
						unless $p->{pipeline}{hipchat}{$_};
				}
				# allowed subkeys
				for (keys %{$p->{pipeline}{hipchat}}) {
					push @errors, "Unrecognized `pipeline.hipchat.$_' key found."
						unless m/^(url|token|room_id|notify|username)$/;
				}
			}
		}
		if ($p->{pipeline}{email}) {
			# validate pipeline.email.*
			# FIXME: fully implement and test email notifications
			push @errors, "Email notifications are not fully implemented yet.";
			if (ref($p->{pipeline}{email}) ne 'HASH') {
				push @errors, "`pipeline.email' must be a map.";
			} else {
				# required subkeys
				for (qw(to from smtp)) {
					push @errors, "`pipeline.email.$_' is required."
						unless $p->{pipeline}{email}{$_};
				}
				# to must be a list...
				if (exists $p->{pipeline}{email}{to}) {
					if (ref($p->{pipeline}{email}{to}) ne 'ARRAY') {
						push @errors, "`pipeline.email.to' must be a list of addresses.";
					} else {
						if (@{$p->{pipeline}{email}{to}} == 0) {
							push @errors, "`pipeline.email.to' must contain at least one address.";
						}
					}
				}
				# allowed subkeys
				for (keys %{$p->{pipeline}{email}}) {
					push @errors, "Unrecognized `pipeline.email.$_' key found."
						unless m/^(to|from|smtp)$/;
				}
				if (ref($p->{pipeline}{email}{smtp}) eq 'HASH') {
					# required sub-subkeys
					for (qw(host username password)) {
						push @errors, "`pipeline.email.smtp.$_' is required."
							unless $p->{pipeline}{email}{smtp}{$_};
					}
					# allowed subkeys
					for (keys %{$p->{pipeline}{email}{smtp}}) {
						push @errors, "Unrecognized `pipeline.email.smtp.$_' key found."
							unless m/^(host|port|username|password)$/;
					}
				} else {
				}
			}
		}
	}

	# validate (optional) pipeline.task.*
	if (exists $p->{pipeline}{task}) {
		if (ref($p->{pipeline}{task}) eq 'HASH') {
			# allowed subkeys
			for (keys %{$p->{pipeline}{task}}) {
				push @errors, "Unrecognized `pipeline.task.$_' key found."
					unless m/^(image|version)$/;
			}
		} else {
			push @errors, "`pipeline.task' must be a map.";
		}
	}

	# validate layouts
	my $key = undef; # for better messaging, later
	if (exists $p->{pipeline}{layout} && exists $p->{pipeline}{layouts}) {
		push @errors, "Both `pipeline.layout' and `pipeline.layouts' (plural) specified.  Please pick one or the other.";
	} elsif (exists $p->{pipeline}{layout}) {
		$p->{pipeline}{layouts}{default} = $p->{pipeline}{layout};
		delete $p->{pipeline}{layout};
		$key = 'pipeline.layout'; # we're pretending the user did it correctly.
	}
	if (ref($p->{pipeline}{layouts}) eq 'HASH') {
		for (keys %{$p->{pipeline}{layouts}}) {
			if (ref($p->{pipeline}{layouts}{$_})) {
				my $k = $key || "pipeline.layouts.$_";
				push @errors, "`$k' must be a string.";
			}
		}
	} else {
		push @errors, "`pipeline.layouts' must be a map.";
	}

	# validate BOSH directors
	if (ref($p->{pipeline}{boshes}) eq 'HASH') {
		for my $env (keys %{$p->{pipeline}{boshes}}) {
			# required sub-subkeys
			if (is_create_env($env)) {
				# allowed subkeys for a create-env deploy
				for (keys %{$p->{pipeline}{boshes}{$env}}) {
					push @errors, "Unrecognized `pipeline.boshes[$env].$_' key found."
						unless m/^(alias)$/;
				}
			} else {
				for (qw(url ca_cert username password)) {
					push @errors, "`pipeline.boshes[$env].$_' is required."
						unless $p->{pipeline}{boshes}{$env}{$_};
				}
				# allowed subkeys
				for (keys %{$p->{pipeline}{boshes}{$env}}) {
					push @errors, "Unrecognized `pipeline.boshes[$env].$_' key found."
						unless m/^(stemcells|url|ca_cert|username|password|alias)$/;
				}
			}

			if (! $p->{pipeline}{skip_upkeep}) {
				unless (is_create_env($env)) {
					if (! $p->{pipeline}{boshes}{$env}{stemcells}) {
						push @errors, "No stemcells specified for `pipeline.boshes[$env]' and `pipeline.skip_upkeep' not enabled.";
					} elsif (ref($p->{pipeline}{boshes}{$env}{stemcells}) ne 'ARRAY') {
						push @errors, "`pipeline.boshes[$env].stemcells' is not an array";
					} else {
						for (@{$p->{pipeline}{boshes}{$env}{stemcells}}) {
							push @errors, "`pipeline.boshes[$env].stemcells.$env' is not a stemcell alias listed in `pipeline.stemcells'"
								unless $p->{pipeline}{stemcells}{$_};
						}
					}
				}
			}
		}
	}

	return $p, @errors;
}

sub parse_pipeline {
	my ($file, $layout) = @_;
	my ($pipeline, @errors) = read_pipeline($file);
	if (@errors) {
		error "#R{ERRORS encountered} in pipeline definition in #Y{$file}:";
		error "  - #R{$_}" for @errors;
		exit 1;
	}

	my $src = $pipeline->{pipeline}{layouts}{$layout}
		or die "No such layout `${layout}'\n";

	# our internal representation
	my $P = $pipeline;
	$P->{file} = $file;  # the path to the original pipeline file,
	                     # which we need to merge in with the guts.yml
	                     # definition to get the final configuration.

	$P->{auto} = [];     # list of patterns that match environments
	                     # we want concourse to trigger automatically.

	$P->{envs} = [];     # list of all environment names seen in the
	                     # configuration, to be used for validation.

	$P->{will_trigger} = {}; # map of (A -> [B, C, D]) triggers, where A triggers
	                         # a deploy (or notification) of B, C, and D.  Note that
	                         # the values are lists, because one environment
	                         # can trigger multiple other environments.
	$P->{triggers} = {};     # map of B -> A where B was a deploy triggered
	                         # by a successful deploy of A. Only one environment
	                         # can have triggered each given environment

	# handle yes/no/y/n/true/false/1/0 in our source YAML.
	$P->{pipeline}{tagged} = yaml_bool($P->{pipeline}{tagged}, 0);
	$P->{pipeline}{public} = yaml_bool($P->{pipeline}{public}, 0);

	# some default values, if the user didn't supply any
	$P->{pipeline}{vault}{role}   ||= "";
	$P->{pipeline}{vault}{secret} ||= "";
	$P->{pipeline}{vault}{verify} = yaml_bool($P->{pipeline}{vault}{verify}, 1);

	$P->{pipeline}{task}{image}   ||= 'starkandwayne/concourse';
	$P->{pipeline}{task}{version} ||= 'latest';

	# NOTE that source-level mucking about via regexen obliterates
	# all of the line and column information we would expect from
	# a more traditional parser.  If it becomes important to report
	# syntax / semantic errors with line information, this whole
	# parser has to be gutted and re-written.

	$src =~ s/\s*#.*$//gm;   # remove comments (without strings, this is fine)
	$src =~ s/[\r\n]+/ ; /g; # collapse newlines into ';' terminators
	$src =~ s/(^\s+|\s+$)//; # strip leading and trailing whitespace

	# condense the raw stream of tokens into a list or rules,
	# where each rule is itself a list of the significant tokens
	# between two terminators (or begining of file and a terminator)
	#
	# i.e.
	#   [['auto', 'sandbox*'],
	#    ['auto', 'preprod*'],
	#    ['tagged'],
	#    ['sandbox-a', '->', 'sandbox-b']]
	#
	# this structure is designed to be easier to interpret individual
	# rules from, since we can assert against arity and randomly access
	# tokens (i.e. a trigger rule must have '->' at $rule[1]).
	#
	my @rules = ();
	my $rule = [];
	for my $tok (split /\s+/, "$src ;") {
		$tok or die "'$tok' was empty in [$src]!\n";
		if ($tok eq ';') {
			if (@$rule) {
				push @rules, $rule;
				$rule = [];
			}
			next;
		}
		push @$rule, $tok;
	}

	my @auto; # patterns; we'll expand them once we have all the
	          # environments, and then populate $P->{auto};
	my %envs; # de-duplicating map; keys will become $P->{envs}
	for $rule (@rules) {
		if (@$rule >= 3 && $rule->[1] eq '->') {
			my $orig = join ' ', @$rule;
			while (@$rule >= 3 && $rule->[1] eq '->') {
				my ($a, $b) = ($rule->[0], $rule->[2]);
				$envs{$a} = $envs{$b} = 1;
				$P->{will_trigger}{$a} ||= [];
				push @{$P->{will_trigger}{$a}}, $b;
				shift @$rule;
				shift @$rule;
			}
			die "Invalid pipeline definition '$orig'.\n"
				unless @$rule == 1;
			next;
		}

		my ($cmd, @args) = @$rule;
		if ($cmd eq 'auto') {
			die "The 'auto' directive requires at least one argument.\n"
				unless @args;
			push @auto, @args;
			next;
		}

		die "Unrecognized configuration directive '$cmd'.\n";
	}
	$P->{envs} = [keys %envs];
	$P->{aliases} = { map { $_ => ($P->{pipeline}{boshes}{$_}{alias} || $_) } keys %envs};

	%envs = (); # we'll reuse envs for auto environment de-duplication
	for my $pattern (@auto) {
		my $regex = $pattern;
		$regex =~ s/\*/.*/g;
		$regex = qr/^$regex$/;

		my $n = 0;
		for my $env (@{$P->{envs}}) {
			if ($env =~ $regex) {
				$envs{$env} = 1;
				$n++;
			}
		}
		if ($n == 0) {
			error "#Y{warning}: rule `auto $pattern' did not match any environments...\n";
		}
	}
	$P->{auto} = [keys %envs];

	# make sure we have a BOSH director for each seen environment.
	# (thanks to read_pipeline, we know any extant BOSH director configs are good)
	for my $env (@{$P->{envs}}) {
		die "No BOSH director configuration found for $env (at `pipeline.boshes[$env]').\n"
			unless $P->{pipeline}{boshes}{$env};
	}

	# figure out who triggers each environment.
	# this is an inversion of the directed acyclic graph that we
	# are storing in {triggers}.
	#
	# this means that it is illegal for a given environment to be
	# triggererd by more than one other environment.  this decision
	# was made to simplify implementation, and was deemed to not
	# impose overly much on desired pipeline structure.
	my $triggers = {};
	for my $a (keys %{$P->{will_trigger}}) {
		for my $b (@{$P->{will_trigger}{$a}}) {
			# $a triggers $b, that is $b won't deploy unti we
			# see a successful deploy (+test) of the $a environment
			die "Environment '$b' is already being triggered by environment '$triggers->{$b}'.\nIt is illegal to trigger an environment more than once.\n"
				if $triggers->{$b} and $triggers->{$b} ne $a;
			$triggers->{$b} = $a;
		}
	}
	$P->{triggers} = $triggers;

	return $P;
}

# FYI: we use quasi-JSON here, so we don't need to care about our indent level when consuming
#      the notification definitions
sub gen_notifications {
	my ($pipeline, $message, $alias) = @_;
	$alias = "" unless defined $alias;
	my $notification = "aggregate: [\n";
	if ($pipeline->{pipeline}{slack}) {
		$notification .= <<EOF;
{
  put: "slack",
  params: {
    channel: "(( grab pipeline.slack.channel ))",
    username: "(( grab pipeline.slack.username ))",
    icon_url: "(( grab pipeline.slack.icon ))",
    text: '(( concat pipeline.name ": $message" ))'
  }
},
EOF
	}
	if ($pipeline->{pipeline}{hipchat}) {
		$notification .= <<EOF;
{
  put: "hipchat",
  params: {
    from: "(( grab pipeline.hipchat.username ))",
    color: "gray",
    message: '(( concat pipeline.name ": $message" ))',
    notify: "(( grab pipeline.hipchat.notify ))"
  }
},
EOF
	}
	if ($pipeline->{pipeline}{email}) {
		$notification .= <<EOF;
{
  do: [
  { get: build-email-$alias },
  { task: write-email-body,
    config: {
      platform: linux,
      image_resource: {
        type: docker-image,
        source: {
          repository: ubuntu,
        },
      },

      inputs: [
        { name: build-email-$alias },
        { name: out },
      ],
      outputs: [
        { name: email },
      ],

      run: {
        path: build-email-$alias/run,
        args: [],
      },
    },
  },

  { put: email,
    params: {
      body:    email/body,
      headers: email/header,
      subject: email/subject,
    },
  }]
}
EOF
	}
	$notification .= "]";
	return $notification;
}

sub generate_pipeline_concourse_yaml {
	my ($pipeline) = @_;
	my $dir = workdir;
	open my $OUT, ">", "$dir/guts.yml"
		or die "Failed to generate Concourse Pipeline YAML configuration: $!\n";

	# Figure out what environments auto-trigger, and what don't
	my %auto = map { $_ => 1 } @{$pipeline->{auto}};

	# Determine what stemcells are being tracked
	my @stemcells = ();
	unless ($pipeline->{pipeline}{skip_upkeep}) {
		@stemcells = map { { name => $pipeline->{pipeline}{stemcells}{$_}, alias => $_ } } keys %{$pipeline->{pipeline}{stemcells}}
	}

	# CONCOURSE: pipeline (+params) {{{
	print $OUT <<'EOF';
---
pipeline:
  git:
    user:        git
    host:        github.com
    uri:         (( concat pipeline.git.user "@" pipeline.git.host ":" pipeline.git.owner "/" pipeline.git.repo ))
    owner:       (( param "Please specify the name of the user / organization that owns the Git repository" ))
    repo:        (( param "Please specify the name of the Git repository" ))
    branch:      master
    private_key: (( param "Please generate an SSH Deployment Key and install it into Github (with write privileges)" ))

EOF

	if ($pipeline->{pipeline}{slack}) {
		print $OUT <<'EOF';
  slack:
    webhook:  (( param "Please provide a Slack Integration WebHook." ))
    channel:  (( param "Please specify the channel (#name) or user (@user) to send messages to." ))
    username: runwaybot
    icon:     http://cl.ly/image/3e1h0H3H2s0P/concourse-logo.png
EOF
	}
	if ($pipeline->{pipeline}{hipchat}) {
		print $OUT <<'EOF';
  hipchat:
    url:      http://api.hipchat.com
    room_id:  (( param "Please specify the room ID that Concourse should send HipChat notifications to" ))
    token:    (( param "Please specify the HipChat authentication token" ))
    notify:   false
    username: runwaybot
EOF
	}
	if ($pipeline->{pipeline}{email}) {
		print $OUT <<'EOF';
  email:
    to:   (( param "Please provide a list of email addresses to send 'Pending Deployment' notifications to." ))
    from: (( param "Please specify a 'From:' account (an email address).  Email will be sent from this address." ))
    smtp:
      username: (( param "Please provide a username to authenticate against your Mail Server (SMTP) host." ))
      password: (( param "Please provide a password to authenticate against your Mail Server (SMTP) host." ))
      host:     (( param "Please specify the FQDN or IP address of your Mail Server (SMTP) host." ))
      port:     587
EOF
	}
	if ($pipeline->{pipeline}{locker}{url}) {
		print $OUT <<'EOF';
  locker:
    url:                 (( param "Please provide the URI to the locker API" ))
    username:            (( param "Please provide the locker API username" ))
    password:            (( param "Please provide the locker API password" ))
    # FIXME until we have service discovery (bosh dns) to reliably know the
    #       locker hostname, and have a ca_cert generated in the concourse kit,
    #       we need to turn on skip_ssl_validation, and nullify the ca_cert by default
    ca_cert:             ~
    skip_ssl_validation: true

EOF
	}
	# }}}
	# CONCOURSE: groups, and resource configuration {{{
	print $OUT <<EOF;
groups:
  - name: $pipeline->{pipeline}{name}
    jobs:
EOF
	print $OUT "    - $_\n" for sort map { "$pipeline->{aliases}{$_}-" . deployment_suffix } @{$pipeline->{envs}};
	print $OUT "    - notify-$_-changes\n" for sort map { "$pipeline->{aliases}{$_}-" . deployment_suffix }
		grep { ! $auto{$_} } @{$pipeline->{envs}};

	print $OUT <<EOF;

resources:
  - name: git
    type: git
    source:
      branch:      (( grab pipeline.git.branch ))
      private_key: (( grab pipeline.git.private_key ))
      uri:         (( grab pipeline.git.uri ))
EOF
	for (@stemcells) {
		print $OUT <<EOF;
  - name: $_->{alias}-stemcell
    type: bosh-io-stemcell
    source: { name: $_->{name} }
EOF
	}
   # }}}
	# CONCOURSE: env-specific resource configuration {{{
	for my $env (sort @{$pipeline->{envs}}) {
		my $alias = $pipeline->{aliases}{$env};
		print $OUT <<EOF;
  - name: ${alias}-changes
    type: git
    source:
      .: (( inject resources.git.source ))
      paths:
EOF
		# watch the common files in our predecessor cache - for example,
		# if us-west-1-sandbox-a triggers us-west-1-preprod-a, then
		# preprod-a would watch the cache of sandbox-a for:
		#
		#    us.yml
		#    us-west.yml
		#    us-west-1.yml
		#
		# and it would only check the top-level root for it's own files:
		#
		#    us-west-1-preprod.yml
		#    us-west-1-preprod-a.yml
		#
		if ($pipeline->{triggers}{$env}) {
			my $trigger = $pipeline->{triggers}{$env};
			my ($pre, @unique) = unique_suffix($trigger, $env);
			$pre = "$pre-" unless $pre eq "";
			for (map { "$pre$_" } expand_tokens(@unique)) {
				print $OUT <<EOF;
        - ${_}.yml
EOF
			}
			print $OUT <<EOF;

  - name: ${alias}-cache
    type: git
    source:
      .: (( inject resources.git.source ))
      paths:
        - .genesis/bin/genesis
        - .genesis/kits
        - .genesis/config
EOF
			print $OUT "# $trigger -> $env\n";
			for (expand_tokens(common_base($env, $trigger))) {
				print $OUT <<EOF;
        - .genesis/cached/${trigger}/${_}.yml
EOF
			}
		} else {
			print $OUT <<EOF;
        - .genesis/bin/genesis
        - .genesis/kits
        - .genesis/config
EOF
			for (expand_tokens(split /-/, $env)) {
				print $OUT <<EOF;
        - ${_}.yml
EOF
			}
		}
		unless (is_create_env($env)) {
			print $OUT <<EOF;

  - name: ${alias}-cloud-config
    type: bosh-config
    source:
      target: $pipeline->{pipeline}{boshes}{$env}{url}
      client: $pipeline->{pipeline}{boshes}{$env}{username}
      client_secret: $pipeline->{pipeline}{boshes}{$env}{password}
      ca_cert: |
EOF
			for (split /\n/, $pipeline->{pipeline}{boshes}{$env}{ca_cert}) {
				print $OUT <<EOF;
         $_
EOF
			}
			print $OUT <<EOF;
      config: cloud

  - name: ${alias}-runtime-config
    type: bosh-config
    source:
      target: $pipeline->{pipeline}{boshes}{$env}{url}
      client: $pipeline->{pipeline}{boshes}{$env}{username}
      client_secret: $pipeline->{pipeline}{boshes}{$env}{password}
      ca_cert: |
EOF
			for (split /\n/, $pipeline->{pipeline}{boshes}{$env}{ca_cert}) {
				print $OUT <<EOF;
        $_
EOF
			}
			print $OUT <<EOF;
      config: runtime

EOF
		}
		if ($pipeline->{pipeline}{locker}{url}) {
			my $deployment_suffix = deployment_suffix;
			unless (is_create_env($env)) {
				my $bosh_lock = $env;
				if ($pipeline->{pipeline}{boshes}{$env}{url} && $pipeline->{pipeline}{boshes}{$env}{url} =~ m|https?://(.*)?:(.*)|) {
					my $addr = gethostbyname($1);
					$bosh_lock = inet_ntoa($addr) . ":" . $2;
				}

				# <alias>-stemcell-lock is used to not upload the same stemcell to the same bosh multiple
				# times - not necessary for create-env
				# <alias>-bosh-lock is used to prevent the parent bosh from upgrading while we deploy
				# - not necessary for create-env
				print $OUT <<EOF;
  - name: ${alias}-stemcell-lock
    type: locker
    source:
      locker_uri: (( grab pipeline.locker.url ))
      username: (( grab pipeline.locker.username ))
      password: (( grab pipeline.locker.password ))
      skip_ssl_validation: (( grab pipeline.locker.skip_ssl_validation ))
      ca_cert: (( grab pipeline.locker.ca_cert ))
      lock_name: ${bosh_lock}-stemcell-lock

  - name: ${alias}-bosh-lock
    type: locker
    source:
      locker_uri: (( grab pipeline.locker.url ))
      username: (( grab pipeline.locker.username ))
      password: (( grab pipeline.locker.password ))
      skip_ssl_validation: (( grab pipeline.locker.skip_ssl_validation ))
      ca_cert: (( grab pipeline.locker.ca_cert ))
      bosh_lock: $pipeline->{pipeline}{boshes}{$env}{url}
EOF
			}
			print $OUT <<EOF;
  - name: ${alias}-deployment-lock
    type: locker
    source:
      locker_uri: (( grab pipeline.locker.url ))
      username: (( grab pipeline.locker.username ))
      password: (( grab pipeline.locker.password ))
      skip_ssl_validation: (( grab pipeline.locker.skip_ssl_validation ))
      ca_cert: (( grab pipeline.locker.ca_cert ))
      lock_name:  ${env}-${deployment_suffix}

EOF
		}
	}
	# }}}
	# CONCOURSE: notification resource configuration {{{
	if ($pipeline->{pipeline}{slack}) {
		print $OUT <<'EOF';
  - name: slack
    type: slack-notification
    source:
      url: (( grab pipeline.slack.webhook ))

EOF
	}
	if ($pipeline->{pipeline}{hipchat}) {
		print $OUT <<'EOF';
  - name: hipchat
    type: hipchat-notification
    source:
      hipchat_server_url: (( grab pipeline.hipchat.url ))
      room_id:  (( grab pipeline.hipchat.room_id ))
      token:    (( grab pipeline.hipchat.token ))
EOF
	}
	if ($pipeline->{pipeline}{email}) {
		print $OUT <<'EOF';
  - name: build-email-changes-staged
    type: script
    source:
      filename: run
      body: |
        #!/bin/bash
        mkdir -p email
        rm -rf email/*
        echo "X-Concourse-Site-Env: ${CI_SITE_ENV}" >>email/header
        head -n1 out/notif > email/subject
        sed -e 's/\`\`\`//' out/notif > email/body
  - name: build-email-success
    .: (( inject resources.build-email-changes-staged ))
  - name: build-email-failure
    .: (( inject resources.build-email-changes-staged ))

  - name: email
    type: email
    source:
      to:   (( grab pipeline.email.to ))
      from: (( grab pipeline.email.from ))
      smtp:
        host:     (( grab pipeline.email.smtp.host ))
        port:     (( grab pipeline.email.smtp.port ))
        username: (( grab pipeline.email.smtp.username ))
        password: (( grab pipeline.email.smtp.password ))
EOF
	}
	# }}}
	# CONCOURSE: resource types {{{
	print $OUT <<'EOF';
resource_types:
  - name: script
    type: docker-image
    source:
      repository: cfcommunity/script-resource

  - name: email
    type: docker-image
    source:
      repository: pcfseceng/email-resource

  - name: slack-notification
    type: docker-image
    source:
      repository: cfcommunity/slack-notification-resource

  - name: hipchat-notification
    type: docker-image
    source:
      repository: cfcommunity/hipchat-notification-resource

  - name: bosh-config
    type: docker-image
    source:
      repository: cfcommunity/bosh-config-resource

  - name: locker
    type: docker-image
    source:
      repository: cfcommunity/locker-resource

EOF
	# }}}
	print $OUT <<EOF;
jobs:
EOF
	for my $env (sort @{$pipeline->{envs}}) {
		# CONCOURSE: env-specific job configuration {{{

		# YAML snippets, to make the print's less obnoxious {{{
		#
		# 1) do we tag the jobs so that they are constrained to a
		#   specific subset of concourse workers? ('tagged' directive)
		my $tag_yaml = $pipeline->{pipeline}{tagged} ? "tags: [$env]" : "";

		# 2) Are we auto-triggering this environment?
		my $trigger = $auto{$env} ? "true" : "false";

		# 3) what is our deployment suffix?
		my $deployment_suffix = deployment_suffix;

		# 4) what previous (triggering) job/env do we need to wait
		#    on for our cached configuration changes
		my $passed =$pipeline->{triggers}{$env} ? $pipeline->{triggers}{$env} : "";
		my $passed_alias = $passed ? "$pipeline->{aliases}{$passed}-$deployment_suffix" : "";

		# 5) Alias of environment for concourse readabilitys
		my $alias = $pipeline->{aliases}{$env};

		# 6) If we have a previous environment, generate input definition
		#    too look at our cache
		my $cache_yaml = "";
		if ($pipeline->{triggers}{$env}) {
			if ($trigger eq "true") {
				$cache_yaml = "- { get: $alias-cache, passed: [$passed_alias], trigger: true }";
			} else {
				$cache_yaml = "- { get: $alias-cache, passed: [notify-$alias-$deployment_suffix-changes], trigger: false }";
			}
		}
		my $notify_cache = $pipeline->{triggers}{$env} ?
			"- { get: $alias-cache, passed: [$passed_alias], trigger: true }" : "";

		# 7) If we don't auto-trigger, we should use passed as our notify resource
		#    otherwise, use the live value
        my $changes_yaml = $trigger eq "true" ?
			"- { get: $alias-changes, trigger: true }" :
			"- { get: $alias-changes, trigger: false, passed: [notify-$alias-$deployment_suffix-changes]}";

		# 8) Build notifications for non-automatic deployments that sense changes
		my $changes_staged_notification = gen_notifications($pipeline,
			"Changes are staged to be deployed to $env-$deployment_suffix, " .
			"please schedule + run a deploy via Concourse", "changes-staged");

		# 9) Build notifications for failed deployments
		my $deployment_failure_notification = gen_notifications($pipeline,
			"Concourse deployment to $env-$deployment_suffix failed", "failure");

		# 10) Build notifications for successful deployments
		my $deployment_success_notification = gen_notifications($pipeline,
			"Concourse successfully deployed $env-$deployment_suffix", "success");

		# 11) notifications for stemcell upload success
		my $stemcell_success_notification = gen_notifications($pipeline,
			"New stemcells have been uploaded to the $env BOSH", "success");
		# 12) notifications for stemcell upload failure
		my $stemcell_failure_notification = gen_notifications($pipeline,
			"Failed uploading new stemcells to the $env BOSH", "failure");

		# 13) directory to find the genesis binary in (use previous env cache if present, else local-changes
		my $genesis_bindir = $passed ? "$alias-cache" : "$alias-changes";

		# }}}

		if ($trigger eq "false" ) {
			# notify job for non-automatic deploys {{{
			print $OUT <<EOF;
  - name: notify-$alias-$deployment_suffix-changes
    public: true
    serial: true
    plan:
    - aggregate:
      - { get: $alias-changes, trigger: true }
EOF
			unless (is_create_env($env)) {
				print $OUT <<EOF;
      - { get: $alias-cloud-config, trigger: true }
      - { get: $alias-runtime-config, trigger: true }
EOF
			}
			print $OUT <<EOF;
      $notify_cache
EOF
			unless ($pipeline->{pipeline}{skip_upkeep}) {
				for (@{$pipeline->{pipeline}{boshes}{$env}{stemcells}}) {
					print $OUT <<EOF;
      - get: $_-stemcell
        trigger: true
        params: { tarball: true }
EOF
				}
			}
			print $OUT <<EOF;
    - $changes_staged_notification
EOF
		}
		# }}}
		print $OUT <<EOF;
  - name: $alias-$deployment_suffix
    public: true
    serial: true
    plan:
    - on_failure:
        $deployment_failure_notification
      on_success:
        $deployment_success_notification
EOF
		if ($pipeline->{pipeline}{locker}{url}) {
			print $OUT <<EOF;
      ensure:
        do:
EOF
			unless (is_create_env($env)) {
				# <alias>-bosh-lock is used to prevent the parent bosh from upgrading while we deploy
				# - not necessary for create-env
				print $OUT <<EOF;
        - put: ${alias}-bosh-lock
          params:
            lock_op: unlock
            key: dont-upgrade-bosh-on-me
            locked_by: ${alias}-${deployment_suffix}
EOF
			}
			print $OUT <<EOF;
        - put: ${alias}-deployment-lock
          params:
            lock_op: unlock
            key: i-need-to-deploy-myself
            locked_by: ${alias}-${deployment_suffix}
EOF
		}
		print $OUT <<EOF;
      do:
EOF
		if ($pipeline->{pipeline}{locker}{url}) {
			unless (is_create_env($env)) {
				# <alias>-bosh-lock is used to prevent the parent bosh from upgrading while we deploy
				# - not necessary for create-env
				print $OUT <<EOF;
      - put: ${alias}-bosh-lock
        params:
          lock_op: lock
          key: dont-upgrade-bosh-on-me
          locked_by: ${alias}-${deployment_suffix}
EOF
			}
			print $OUT <<EOF;
      - put: ${alias}-deployment-lock
        params:
          lock_op: lock
          key: i-need-to-deploy-myself
          locked_by: ${alias}-${deployment_suffix}
EOF
		}
		print $OUT <<EOF;
      - aggregate:
EOF
		# only add cloud/runtime config on true-triggers, otherwise it goes in notifications
		# also make sure that we are not deploying with create-env (no cloud/runtime config for that scenario)
		if (! is_create_env($env) && $trigger eq "true") {
			print $OUT <<EOF;
        - { get: $alias-cloud-config, trigger: true }
        - { get: $alias-runtime-config, trigger: true }
EOF
		}
		unless ($pipeline->{pipeline}{skip_upkeep}) {
			for (@{$pipeline->{pipeline}{boshes}{$env}{stemcells}}) {
				print $OUT <<EOF;
        - get: $_-stemcell
          trigger: $trigger
          params: { tarball: true }
EOF
			}
		}
		print $OUT <<EOF;
        # genesis itself handles the propagation of files from successful environment
        # to the next. anything triggering env-changes should be considered to have passed
        # the previous environment, if in cached, and if not, should be triggered
        $changes_yaml
        $cache_yaml
EOF
		# Update stemcells unless we are create-env based or skip_upkeep requested {{{
		unless (is_create_env($env) || $pipeline->{pipeline}{skip_upkeep}) {
			if ($pipeline->{pipeline}{locker}{url}) {
				print $OUT <<EOF;
      - put: ${alias}-stemcell-lock
        params:
          lock_op: lock
          key: ${alias}-${deployment_suffix}
EOF
			}
			print $OUT <<EOF;
      - task: upload-stemcells
EOF
			if ($pipeline->{pipeline}{locker}{url}) {
				print $OUT <<EOF;
        ensure:
          put: ${alias}-stemcell-lock
          params:
            lock_op: unlock
            key: ${alias}-${deployment_suffix}
EOF
			}
			print $OUT <<EOF;
        config:
          inputs:
            - name: $genesis_bindir
EOF
			for (@{$pipeline->{pipeline}{boshes}{$env}{stemcells}}) {
				print $OUT <<EOF;
            - name: $_-stemcell
              path: stemcells/$pipeline->{pipeline}{stemcells}{$_}
EOF
			}
			print $OUT <<EOF;
          outputs:
            - name: out
          platform: linux
          image_resource:
            type: docker-image
            source:
              repository: starkandwayne/concourse
          run:
            path: .genesis/bin/genesis
            args: [ ci-stemcells ]
            dir: $genesis_bindir
          params:
            STEMCELLS:            ../stemcells
            BOSH_ENVIRONMENT:     $pipeline->{pipeline}{boshes}{$env}{url}
            BOSH_NON_INTERACTIVE: true
            BOSH_CA_CERT: |
EOF
			for (split /\n/, $pipeline->{pipeline}{boshes}{$env}{ca_cert}) {
				print $OUT <<EOF;
              $_
EOF
			}
			print $OUT <<EOF;
            BOSH_CLIENT:        $pipeline->{pipeline}{boshes}{$env}{username}
            BOSH_CLIENT_SECRET: $pipeline->{pipeline}{boshes}{$env}{password}

EOF
			print $OUT <<EOF if $pipeline->{pipeline}{debug};
            DEBUG:              $pipeline->{pipeline}{debug}
EOF
		}
		#   }}}
		print $OUT <<EOF;
      - task: bosh-deploy
        $tag_yaml
        config:
          platform: linux
          image_resource:
            type: docker-image
            source:
              repository: $pipeline->{pipeline}{task}{image}
              tag:        $pipeline->{pipeline}{task}{version}
          params:
            CURRENT_ENV:          $env
            PREVIOUS_ENV:         $passed
            CACHE_DIR:            $alias-cache
            GIT_BRANCH:           (( grab pipeline.git.branch ))
            GIT_PRIVATE_KEY:      (( grab pipeline.git.private_key ))
            VAULT_ROLE_ID:        $pipeline->{pipeline}{vault}{role}
            VAULT_SECRET_ID:      $pipeline->{pipeline}{vault}{secret}
            VAULT_ADDR:           $pipeline->{pipeline}{vault}{url}
            VAULT_SKIP_VERIFY:    ${\(!$pipeline->{pipeline}{vault}{verify})}
            BOSH_NON_INTERACTIVE: true
EOF
		# don't supply bosh creds if we're create-env, because no one to talk to
		unless (is_create_env($env)) {
			print $OUT <<EOF;
            BOSH_ENVIRONMENT:     $pipeline->{pipeline}{boshes}{$env}{url}
            BOSH_CA_CERT: |
EOF
			for (split /\n/, $pipeline->{pipeline}{boshes}{$env}{ca_cert}) {
				print $OUT <<EOF;
              $_
EOF
			}
			print $OUT <<EOF;
            BOSH_CLIENT:        $pipeline->{pipeline}{boshes}{$env}{username}
            BOSH_CLIENT_SECRET: $pipeline->{pipeline}{boshes}{$env}{password}
EOF
		}
		print $OUT <<EOF if $pipeline->{pipeline}{debug};
            DEBUG:              $pipeline->{pipeline}{debug}
EOF
		print $OUT <<EOF;
            WORKING_DIR:        $alias-changes # work out of latest changes for this environment
            OUT_DIR:            out/git


          run:
            # run from inside the environment changes to get latest cache + regular data
            # but use the executable from genesis
            path: $genesis_bindir/.genesis/bin/genesis
            args: [ci-pipeline-deploy]
          inputs:
            - { name: $alias-changes } # deploy from latest changes
EOF
		print $OUT <<EOF if $passed;
            - { name: $alias-cache }
EOF
		print $OUT <<EOF;
          outputs:
            - { name: out }

        # push the deployment changes up to git, even if the deploy fails, to save
        # files for create-env + reflect "live" state
        ensure:
          put: git
          params:
            repository: out/git
EOF

		# CONCOURSE: run optional errands as tasks - non-create-env only (otherwise no bosh to run the errand) {{{
		unless (is_create_env($env)) {
			for my $errand_name (@{$pipeline->{pipeline}{errands}}) {
				print $OUT <<EOF;
        # run errands against the deployment
      - task: $errand_name-errand
        $tag_yaml
        config:
          platform: linux
          image_resource:
            type: docker-image
            source:
              repository: $pipeline->{pipeline}{task}{image}
              tag:        $pipeline->{pipeline}{task}{version}
          params:
            CURRENT_ENV:        $env
            ERRAND_NAME:        $errand_name

            BOSH_ENVIRONMENT:   $pipeline->{pipeline}{boshes}{$env}{url}
            BOSH_CA_CERT: |
EOF
			for (split /\n/, $pipeline->{pipeline}{boshes}{$env}{ca_cert}) {
				print $OUT <<EOF;
              $_
EOF
			}
			print $OUT <<EOF;
            BOSH_CLIENT:        $pipeline->{pipeline}{boshes}{$env}{username}
            BOSH_CLIENT:        $pipeline->{pipeline}{boshes}{$env}{username}
            BOSH_CLIENT_SECRET: $pipeline->{pipeline}{boshes}{$env}{password}
EOF
			print $OUT <<EOF if $pipeline->{pipeline}{debug};
            DEBUG:              $pipeline->{pipeline}{debug}
EOF
			print $OUT <<EOF;

          run:
            path: ../../$genesis_bindir/.genesis/bin/genesis
            dir:  out/git
            args: [ci-pipeline-run-errand]
          inputs:
            - name: out
            - name: $genesis_bindir
EOF
			}
		}
		# }}}
		print $OUT <<EOF;
      - task: generate-cache
        $tag_yaml
        config:
          inputs:
          - { name: out }
          - { name: $genesis_bindir }
          outputs:
          - { name: cache-out }
          run:
            path: $genesis_bindir/.genesis/bin/genesis
            args: [ci-generate-cache]
          params:
            CURRENT_ENV:     $env
            WORKING_DIR:     out/git
            OUT_DIR:         cache-out/git
            GIT_BRANCH:      (( grab pipeline.git.branch ))
            GIT_PRIVATE_KEY: (( grab pipeline.git.private_key ))
EOF

		print $OUT <<EOF if $pipeline->{pipeline}{debug};
            DEBUG:       $pipeline->{pipeline}{debug}
EOF
		print $OUT <<EOF;
          platform: linux
          image_resource:
            type: docker-image
            source:
              repository: $pipeline->{pipeline}{task}{image}
              tag:        $pipeline->{pipeline}{task}{version}
      - put: git
        params:
          repository: cache-out/git
EOF

		for my $push_env (@{$pipeline->{will_trigger}{$env}}) {
			print $OUT <<EOF;
      - put: $pipeline->{aliases}{$push_env}-cache
        params:
          repository: cache-out/git
EOF
		}
	# }}}
	}
	close $OUT;

	return spruce_merge({ prune => [qw(meta pipeline)] },
		"$dir/guts.yml", $pipeline->{file});
}

sub generate_pipeline_graphviz_source {
	my ($pipeline) = @_;
	my $out = "";
	open my $fh, ">", \$out;
	print $fh "digraph {\n";
	print $fh "  rankdir = LR; node [shape=none]; edge [color=\"#777777\",fontcolor=\"red\"];\n";

	my %auto = map { $_ => 1 } @{$pipeline->{auto}};
	for my $b (keys %{$pipeline->{triggers}}) {
		my $a = $pipeline->{triggers}{$b};
		(my $b1 = $b) =~ s/-/_/g;
		(my $a1 = $a) =~ s/-/_/g;
		print $fh "  $a1 [label=\"$a\"];\n";
		print $fh "  $b1 [label=\"$b\"];\n";
		if ($auto{$b}) {
			print $fh "  $a1 -> $b1;\n";
		} else {
			print $fh "  $a1 -> $b1 [label=\"manual\"];\n";
		}
	}


	print $fh "}\n";
	close $fh;
	return $out;
}

sub pipeline_tree {
	my ($prefix, $env, $trees) = @_;
	#
	# sandbox
	#  |--> preprod
	#  |     |--> prod
	#  |     |--> prod-2
	#  |     `--> some-prod
	#  |
	#  `--> other-preprod
	#        `--> other-prod
	#

	print "$env\n";
	my $n = @{$trees->{$env} || []};
	for my $kid (sort @{$trees->{$env} || []}) {
		$n--;
		if ($n) {
			print "$prefix  |--> ";
			pipeline_tree("$prefix  |   ", $kid, $trees);
		} else {
			print "$prefix  `--> ";
			pipeline_tree("$prefix      ", $kid, $trees);
		}
	}
}

sub generate_pipeline_human_description {
	my ($pipeline) = @_;

	my %auto = map { $_ => 1 } @{$pipeline->{auto}};

	my %trees;
	my %envs = map { $_ => 1 } @{$pipeline->{envs}};
	for my $b (keys %{$pipeline->{triggers}}) {
		my $a = $pipeline->{triggers}{$b};
		push @{$trees{$a}}, $b;
		delete $envs{$b};
	}
	for (sort keys %envs) {
		pipeline_tree("", $_, \%trees);
		print "\n";
	}
}

sub semver {
	my ($name, $v) = @_;
	if ($v =~  m/^(\d+)(?:\.(\d+)(?:\.(\d+)(?:[.-]rc[.-]?(\d+))?)?)?$/) {
		return ($1, $2 || 0, $3 || 0, $4 || 0);
	}
	die "Unrecognized version string '$v' for $name\n";
}

sub new_enough {
	my ($name, $v, $min) = @_;
	my @v = semver($name, $v);
	my @min = semver($name, $min);
	while (@v) {
		return 1 if $v[0] > $min[0];
		return 0 if $v[0] < $min[0];
		shift @v;
		shift @min;
	}
	return 1;
}

sub check_prereqs {

	my %conditions = @_;

	my $SPRUCE_MIN_VERSION = "1.12.0";
	my $SAFE_MIN_VERSION   = "0.1.8";
	my $VAULT_MIN_VERSION  = "0.6.0";
	my $GIT_MIN_VERSION    = "1.8.0";
	my $BOSH2_MIN_VERSION  = "2.0.1";

	my @errors;
	my $version;

	# check that we has a spruce
	$version = qx(spruce -v 2>/dev/null);
	if (!$version || $version =~ s/not found//) {
		push @errors, "Missing `spruce' - install Spruce from #B{https://github.com/geofffranks/spruce/releases}";
	} else {
		unless(envset('GENESIS_DEV_MODE') && $version =~ /development/) {
			chomp($version); $version =~ s/.*version\s+(\S+).*/$1/i;
			if (!new_enough("spruce", $version, $SPRUCE_MIN_VERSION)) {
				push @errors, "Spruce v${version} is installed, but Genesis requires #R{at least $SPRUCE_MIN_VERSION} - upgrade your Spruce, via #B{https://github.com/geofffranks/spruce/releases}";
			}
		}
	}

	# check that we has a safe
	$version = qx(safe -v 2>&1 >/dev/null);
	if (!$version || $version =~ s/not found//) {
		push @errors, "Missing `safe' - install Safe from #B{https://github.com/starkandwayne/safe/releases}";
	} else {
		unless (envset('GENESIS_DEV_MODE') && $version =~ /development build/) {
			chomp($version); $version =~ s/^safe v(\S+)/$1/i;
			if (!new_enough("safe", $version, $SAFE_MIN_VERSION)) {
				push @errors, "Safe v${version} is installed, but Genesis requires #R{at least $SAFE_MIN_VERSION} - upgrade your Safe, via #B{https://github.com/starkandwayne/safe/releases}";
			}
		}
	}

	# check that we has a vault
	$version = qx(vault -v 2>/dev/null);
	if (!$version) {
		push @errors, "Missing `vault' - install Vault from #B{https://www.vaultproject.io/downloads.html}";
	} else {
		chomp($version); $version =~ s/^vault v(\S+).*/$1/i;
		if (!new_enough("vault", $version, $VAULT_MIN_VERSION)) {
			push @errors, "Vault v${version} is installed, but Genesis requires #R{at least $VAULT_MIN_VERSION} - upgrade your Vault, via #B{https://www.vaultproject.io/downloads.html}";
		}
	}

	# check that we has a bosh (v2)
	detect_bosh_version($BOSH2_MIN_VERSION);

	# check that we has a git
	$version = qx(git --version 2>/dev/null);
	if (!$version || $version =~ s/not found//) {
		push @errors, "Missing `git' - install git via your platform package manager";
	} else {
		chomp($version); $version =~ s/.*version\s+(\S+).*/$1/i;
		if (!new_enough("git", $version, $GIT_MIN_VERSION)) {
			push @errors, "Git v${version} is installed, but Genesis requires #R{at least $GIT_MIN_VERSION}";
		}
	}

	unless ($conditions{no_repo_needed}) {
		push @errors, "This command needs to be run from a Genesis v2 deployment repo, or specify one using -C <dir> option"
			unless in_repo_dir;
	}

	if (@errors) {
		error "#R{GENESIS PRE-REQUISITES CHECKS FAILED!!}";
		error;
		error "Encountered the following errors:";
		error "  - $_" for @errors;
		exit 2;
	}
}

sub extract_kit_name_and_version {
	my ($combined) = @_;
	return ($1, $2) if $combined =~ m{(.*)/(.*)};
	return $combined, "latest";
}

sub kit_release_url {
	my ($name, $version) = @_;

	my $creds = "";
	if ($ENV{GITHUB_USER} && $ENV{GITHUB_AUTH_TOKEN}) {
		$creds = "$ENV{GITHUB_USER}:$ENV{GITHUB_AUTH_TOKEN}";
	}
	my ($code, $msg, $data) = curl "GET", "https://api.github.com/repos/genesis-community/$name-genesis-kit/releases", undef, undef, 0, $creds;
	if ($code == 404) {
		die "Could not find Genesis Kit $name on Github; does https://github.com/genesis-community/$name-genesis-kit/releases exist?\n";
	}
	if ($code != 200) {
		die "Could not find Genesis Kit $name release information; Github returned a ".$msg."\n";
	}

	my $releases;
	eval { $releases = decode_json($data); 1 }
		or die "Failed to read releases information from Github: $@\n";

	if (!@$releases) {
		die "No released versions of Genesis Kit $name found at https://github.com/genesis-community/$name-genesis-kit/releases.\n";
	}

	for (map { @{$_->{assets} || []} } @$releases) {
		if ($version eq 'latest') {
			next unless $_->{name} =~ m/^\Q$name\E-(.*)\.(tar\.gz|tgz)$/;
			$version = $1;
		} else {
			next unless $_->{name} eq "$name-$version.tar.gz"
			         or $_->{name} eq "$name-$version.tgz";
		}
		return ($_->{browser_download_url}, $version);
	}

	die "$name/$version tarball asset not found on Github.  Oops.\n";
}

sub kit_file {
	my ($kit, $version, $relpath, $required) = @_;

	if (!$kit || $kit eq "dev") {
		-d "dev/"                       or die "dev/ kit directory not found. Please contact your kit author for a fix.\n";
		!$required || -f "dev/$relpath" or die "dev/$relpath not found. Please contact your kit author for a fix.\n";
		return "dev/$relpath";
	}
	-f ".genesis/kits/$kit-$version.tar.gz"
		or die "Kit $kit/$version not found in .genesis/kits!\n";

	my $tmp = workdir();
	qx(tar -C $tmp -xzf .genesis/kits/$kit-$version.tar.gz $kit-$version/$relpath 2>/dev/null);
	!$required || -f "$tmp/$kit-$version/$relpath"
		or die "$relpath not found in $kit-$version kit. Please contact your kit author for a fix.\n";
	return "$tmp/$kit-$version/$relpath";
}

sub download_kit_tarball
{
	my ($name, $want) = @_;

	if ($want eq 'latest') {
		explain "Downloading Genesis kit #M{$name} (#Y{latest} version)\n";
	} else {
		explain "Downloading Genesis kit #M{$name}, version #C{$want}\n";
	}
	my ($url, $version) = kit_release_url($name, $want);
	mkdir_or_fail ".genesis";
	mkdir_or_fail ".genesis/kits";
	open my $kit, ">", ".genesis/kits/$name-$version.tar.gz"
		or die "Failed to open .genesis/kits/$name-$version.tar.gz for writing: $!\n";
	my ($code, $msg, $data) = curl "GET", $url;
	if ($code != 200) {
		die "Failed to download $name/$version from $url: Github returned an HTTP ".$msg."\n";
	}
	print $kit $data;
	close $kit;
	debug "downloaded kit #M{$name}/#C{$version}\n";
}
sub validate_kit_files {

	my $dir = shift;
	my @errors = ();
	my @warnings = ();
	if (-d $dir) {
		for (qw(subkits hooks)) {
			push @warnings, "$dir/$_ directory does not exist" unless -d "$dir/$_";
		}
		for (qw(base)) {
			push @errors, "$dir/$_ directory does not exist" unless -d "$dir/$_";
		}
		for (qw(kit.yml README.md base/params.yml)) {
			push @errors, "$dir/$_ does not exist" unless -f "$dir/$_";
		}
		if (-d "$dir/subkits/") {
			for (glob "$dir/subkits/*") {
				push @errors, "$_/params.yml does not exist" unless -f "$_/params.yml";
			}
		}
	} else {
		push @errors, "$dir does not exist";
	}
	die("$dir does not look like a valid kit directory:\n".
		"  * ".join("\n  * ", @errors).
		"\n\nCannot continue.\n")
		if @errors;
	warn("Warning: $dir has abnormal contents (non-fatal):\n".
		"  * ".join("\n  * ", @warnings).
		"\n\n")
		if @warnings;
}

sub validate_kit_metadata {
	my ($kit, $version, $meta,$is_author) = @_;
	$kit ||= "dev";
	$version = "latest" unless defined $version;
	my @errors;

	# validate params
	for my $subkit (sort keys %{$meta->{params}}) {
		my $i = 0;
		debug ("Validating params for subkit '$subkit' (#$i)");
		if (ref($meta->{params}{$subkit}) ne "ARRAY") {
			push @errors, "$subkit subkit parameters not a list (found ".(ref($meta->{params}{$subkit}) || "a string").")";
		} else {
			for my $param (@{$meta->{params}{$subkit}}) {
				my $name = ($param->{param} && !ref($param->{param})) ? ':'.$param->{param} : "";
				my $parameter = "params.$subkit\[$i$name\]";
				my (@extras, @bad);
				for my $key (sort keys %$param) {
					push @extras, $key if $key !~ m/^(params?|ask|vault|description|example|type|echo)$/;
				}
				if (defined($param->{ask})) {
					my $type = exists($param->{type}) ? $param->{type} : "string";
					if (defined($param->{validate})) {
						if ($type =~ m/^(string|list)$/) {
							@extras = grep {$_ !~ /^(validate|err_msg)$/ } @extras;
							if ($param->{validate} !~ m/^!?\/.*\/i?m?s?$/              && # regex validation
								$param->{validate} !~ m/^((^|,)[^,]+){2,}$/            && # comma-separated list
								$param->{validate} !~ m/^!?\[([^,]+(,[^,]+)*)]$/       && # new invertable comma-separated list
								$param->{validate} !~ m/^((^|,)[^,]+){2,}$/            && # comma-separated list
								$param->{validate} !~ m/^-?\d+(\.\d+)?--?\d+(\.\d+)?$/ && # range
								$param->{validate} !~ m/^(vault_path|url|port)$/       ){ # key-words
								push @errors, "$parameter has an invalid validation formula";
							}

						} elsif ($type =~ m/^(multi-)?choice$/) {
							@extras = grep {$_ !~ /^(validate|err_msg)$/ } @extras;
							if (ref($param->{validate}) eq 'ARRAY') {
								# All array elements must be simple strings
								push @errors, "$parameter validation array can only contain strings or 2-string arrays"
									if (grep {ref($_) && !(ref($_) eq 'ARRAY' && $#$_ == 1 && !ref($_->[0]) && !ref($_->[1]))} @{$param->{validate}});
								my $min = 2;
								$min = $param->{min_count} if ($type eq 'multi-choice' && defined($param->{min_count}) && $param->{min_count} > $min);
								push(@errors, "$parameter requires at least 2 choices") if scalar(@{$param->{validate}}) < $min;
							} else {
								push @errors, "$parameter validation must be an array of strings or 2-string arrays";
							}
						}
					} else {
						if ($type =~ m/^(multi-)?choice$/) {
							push @errors, "$parameter requires validation to provide choices";
						}
					}
					if ( $type =~ m/^(string|block|multi-?line|choice)$/) {
						push @bad, grep {$_ !~ m/^(label|default)$/} @extras;
					} elsif ($type eq 'boolean') {
						push @bad, grep {$_ !~ m/^(label|default)$/} @extras;
						push @errors, "$parameter has invalid default value '$param->{default}'"
						  if (defined($param->{default}) && $param->{default} !~ /^(1|0|y(es)?|no?|true|false)$/i);
					} elsif ($type =~ m/^((block|multi-?line)-)?list$/) {
						push @bad, grep {$_ !~ m/^(label|(max|min)_count)$/} @extras;
						push @errors, "$parameter requires max_count to be equal to or greater than min_count"
							if (defined($param->{min_count}) && defined($param->{max_count}) && $param->{max_count} < $param->{min_count});
						foreach (qw/min_count max_count/) {
							push @errors, "$parameter requires $_ to be non-negative"
								if (defined($param->{$_}) && $param->{$_} < 0);
						}
					} elsif ($type eq 'multi-choice') {
						push @bad, grep {$_ !~ m/^((max|min)_count)$/} @extras;
						push @errors, "$parameter requires max_count to be equal to or greater than min_count"
							if (defined($param->{min_count}) && defined($param->{max_count}) && $param->{max_count} < $param->{min_count});
						foreach (qw/min_count max_count/) {
							push @errors, "$parameter requires $_ to be non-negative"
								if (defined($param->{$_}) && $param->{$_} < 0);
						}
					} else {
						push @errors, "$parameter has unsupported type '$type'";
						@bad = @extras;
					}
				} else {
					@bad = @extras;
				}
				push @errors, "$parameter has an invalid attribute: '$_'" foreach @bad;
				push @errors, "$parameter does not specify 'vault', 'param', or 'params'"
					unless ($param->{param} || $param->{params} || $param->{vault});
				push @errors, "$parameter specifies both 'param' and 'params'"
					if ($param->{param} && $param->{params});
				push @errors, "$parameter specifies both 'param' and 'vault'"
					if ($param->{param} && $param->{vault});
				push @errors, "$parameter specifies both 'params' and 'vault'"
					if ($param->{vault} && $param->{params});
				push @errors, "$parameter specifies 'param', but it is not a string"
					if $param->{param} && ref $param->{param};
				push @errors, "$parameter specifies 'params', but it is not an array"
					if $param->{params} && ref $param->{params} ne "ARRAY";
				push @errors, "$parameter specifies both 'params' and 'ask'"
					if $param->{params} && $param->{ask};
				push @errors, "$parameter does not have a 'description'"
					if ! $param->{description};
				push @errors, "$parameter specifies 'ask', but does not have a corresponding 'vault' or 'param'"
					if ($param->{ask} && ! $param->{vault} && ! $param->{param});
				push @errors, "$parameter specifies 'vault' but does not have a corresponding 'ask'"
					if $param->{vault} && ! $param->{ask};

				$i++;
			}
		}
	}

	if (@errors) {
		print STDERR "The following errors have been encountered validating the $kit/$version kit:\n";
		for my $err (@errors) {
			print STDERR " - $err\n";
		}
		die ($is_author ? "Cannot continue.\n" : "Please contact your kit author for a fix.\n");
	}
}

# read the metadata for the given kit (and version)
# if no kit/version is given, assume 'dev'
sub read_kit_metadata {
	my ($kit, $version) = @_;
	my $metadata = LoadFile(kit_file($kit, $version, "kit.yml", 1));
	validate_kit_metadata($kit, $version, $metadata);
	return $metadata;
}

sub latest_kit_name_and_version {
	# use dev/, if we have it
	return (undef, undef) if -d "dev";

	# use latest available:
	my ($kit, @versions);
	for (glob(".genesis/kits/*.tar.gz")) {
		next unless m{^\.genesis/kits/(.*?)-(\d+(\.\d+(\.\d+([.-]rc[.-]?\d+)?)?)?).tar.gz$};
		my ($n, $v) = ($1, $2);
		if ($kit && $kit ne $n) {
			die "Found multiple different kits!\n";
		}
		$kit = $n;

		push @versions, [$v, semver($kit, $v)];
	}
	@versions > 0
		or die "No kits have been downloaded for use in this set of deployment environments.\nPlease download a kit via `genesis download kit-name[/version]`\n";
	my @sorted = reverse sort { $a->[1] <=> $b->[1] } @versions;
	return ($kit, $sorted[0][0]);
}

sub kit_name_and_version_for {
	my ($env) = @_;
	my $name = get_key($env, 'kit.name');
	my $vers = get_key($env, 'kit.version');
	return (undef, undef) if $name && $name eq 'dev';
	return ($name, $vers) if $name && $vers;
	return latest_kit_name_and_version();
}

sub check_kit_prereqs {
	my ($kit, $version) = @_;
	my $script = kit_file($kit, $version, "prereqs", 0);
	return unless -e $script;
	-x $script or die "Prereqs script $script was found, but is not executable...\n";
	qx(./dev/prereqs);
	$? == 0 or die "Some prerequisites for this Genesis Kit have not been met.\n";
}

sub prompt_for_subkits_alternates {
	my ($prompt) = @_;
	my $attempt;
	print "\n";

reprompt:
	$attempt = 0;
	print "$prompt->{prompt}\n\n";

	my $n = 0;
	for my $choice (@{ $prompt->{choices} }) {
		$n++;
		if ($choice->{default}) {
			print "  *${n}) $choice->{label} (default)\n";
		} else {
			print "   ${n}) $choice->{label}\n";
		}
	}
	print "\n";

again:
	$attempt++;
	print " choice? [1-$n]: ";
	my $answer = <STDIN>; defined $answer or die "unexpected EOF on standard input...\n";
	$answer =~ s/^\s+|\s+$//g;
	if ($answer && $answer >= 1 && $answer <= $n) {
		return $prompt->{choices}[$answer - 1]{subkit};
	}
	if ($answer) {
		print "'$answer' is an invalid choice...\n";
	}
	if ($attempt < 3) {
		goto again;
	}
	print "You can <CTRL-C> to exit setup...\n";
	goto reprompt;
}

sub resolve_params_ref {
	my ($key,$references) = @_;
	die("\$\{$key\} referenced but not found -- perhaps it hasn't been defined yet.  Contact your Kit author for a bugfix.\n")
		unless exists($references->{$key});
	return $references->{$key};
}

sub process_kit_params {
	my %opts = @_;
	my @answers;
	my $resolveable_params = {
		"params.vault_prefix" => $opts{vault_prefix},
		"params.env" => $opts{env}
	};
	for my $subkit ("base", @{$opts{subkits}}) {
		next unless defined $opts{params}{$subkit} && @{$opts{params}{$subkit}};
		my $kit_params_file = $subkit eq "base" ? "base/params.yml" : "subkits/$subkit/params.yml";
		my $defaults = LoadFile(kit_file($opts{kit}, $opts{version}, $kit_params_file, 1));
		for my $q (@{$opts{params}{$subkit}}) {
			my $answer;
			my $vault_path;
			next if ($q->{vault} && ! $opts{should_vault});
			# Expand any values from default and examples for vault prefix
			foreach (qw(description ask default example validate err_msg)) {
				$q->{$_} =~ s/\$\{([^}]*)\}/resolve_params_ref($1,$resolveable_params)/ge if defined($q->{$_});
			}
			if (defined($q->{validate}) && $q->{validate} eq 'vault_path') {
				if (defined($q->{default})) {
					while ($q->{default} =~ s#/[^/]+/\.\./#/#) {};
				}
				if (defined($q->{example})) {
					while ($q->{example} =~ s#/[^/]+/\.\./#/#) {};
				}
			}
			if ($q->{ask}) {
				$q->{type} ||= "string";
				print "\n";
				if ($q->{param}) {
					print csprintf("#y{Required parameter:} #W{$q->{param}}\n\n");
				} else {
					$vault_path = "secret/$opts{vault_prefix}/$q->{vault}";
					print csprintf("#y{Secret data required} -- will be stored in Vault under #W{$vault_path}\n\n");
				}
				chomp $q->{description};
				print "$q->{description}\n";
				print "(e.g. $q->{example})\n" if defined $q->{example};
				if ($q->{param}) {
					my $type = $q->{type};
					if (defined($q->{validate}) && $q->{validate} eq "vault_path" && ! $opts{should_vault}) {
						print csprintf("#y{Warning:} Cannot validate vault path when --no-secrets option specified");
						$q->{validate}=undef;
					}
					if ($type eq 'boolean') {
						$answer = prompt_for_boolean($q->{ask},$q->{default});
					} elsif ($type eq 'string') {
						$answer = prompt_for_line($q->{ask},$q->{label},$q->{default},$q->{validate},$q->{err_msg});
					} elsif ($type =~ m/^(block|multi-?line)$/) {
						$answer = prompt_for_block($q->{ask},$q->{label},$q->{default});
					} elsif ($type eq 'list') {
						$answer = prompt_for_list('line',$q->{ask},$q->{label},$q->{min_count},$q->{max_count},$q->{validate},$q->{err_msg});
					} elsif ($type =~ m/^(block|multi-?line)-list$/) {
						$answer = prompt_for_list('block',$q->{ask},$q->{label},$q->{min_count},$q->{max_count});
					} elsif ($type =~ m/^(multi-)?choice$/) {
						my ($choices,$labels)=([],[]);
						if (ref($q->{validate}) eq 'ARRAY') {
							foreach (@{$q->{validate}}) {
								if (ref($_) eq 'ARRAY') {
									push @$choices, $_->[0];
									push @$labels, $_->[1];
								} else {
									push @$choices, $_;
									push @$labels, undef;
								}
							}
						}
						if ($type eq 'choice') {
							$answer = prompt_for_choice($q->{ask},$choices,$q->{default},$labels,$q->{err_msg});
						} else {
							$answer = prompt_for_choices($q->{ask},$choices,$q->{min_count},$q->{max_count},$labels,$q->{err_msg});
						}
					} else {
						die "Unsupported type '$type' for parameter '$q->{param}'. Please contact your kit author for a fix.\n";
					}
					print "\n";
				} else {
					my ($path, $key) = split /:/, $vault_path;
					if ($q->{type} =~ /^(boolean|string)$/) {
						system "safe", "prompt", $q->{ask}, "--", ($q->{echo} ? "ask" : "set"), $path, $key;
						die "Failed to save data to $vault_path in Vault\n" if ($? >> 8);
					} elsif ($q->{type} eq "multi-line") {
						$answer = prompt_for_block($q->{ask});
						my $tmpdir = workdir;
						open my $fh, ">", "$tmpdir/param" or die "Could not write to $tmpdir/param: $!\n";
						print $fh $answer;
						close $fh;
						my $err = qx(safe set "$path" "$key\@$tmpdir/param" 2>&1);
						die "$err\n\nFailed to save data to $vault_path in Vault\n" if ($? >> 8);
					} else {
						die "Unsupported parameter type '$q->{type}' for $q->{vault}. Please contact your kit author for a fix.\n";
					}
					print "\n";
					next;
				}
			}
			my @values;
			my $is_default = 0;
			if (! $q->{ask}) {
				$is_default = 1;
				if (defined $q->{param}) {
					$q->{params} = [$q->{param}];
				}
				for my $p (@{$q->{params}}) {
					# Should we throw an error here if the default value is
					# a spruce operator like (( param ))?
					push @values, { $p => $defaults->{params}{$p} };
					$resolveable_params->{"params.$p"} = $defaults->{params}{$p};
				}
			} else {
				push @values, { $q->{param} => $answer };
				$resolveable_params->{"params.$q->{param}"} = $answer;
			}

			push @answers, {
				comment => $q->{description},
				example => $q->{example},
				values  => \@values,
				default => $is_default,
			};
		}
	}
	return \@answers;
}

sub prompt_for_subkits_optional {
	my ($prompt) = @_;
	my $attempt = 0;
	print "\n";

again:
	$attempt++;
	print "$prompt->{prompt}\n";
	print $prompt->{default} ? "[Y/n]: " : "[y/n]: ";
	my $answer = <STDIN>; defined $answer or die "unexpected EOF on standard input...\n";
	$answer =~ s/^\s+|\s+$//g;

	return $prompt->{subkit} if !$answer && $prompt->{default};
	return $prompt->{subkit} if $answer =~ m{(y|yes)}i;
	return undef             if $answer =~ m{(n|no)}i;

	if ($answer) {
		print "'$answer' is an invalid choice; try 'yes' or 'no'...\n";
	}
	if ($attempt % 3 == 0) {
		print "You can <CTRL-C> to exit setup...\n";
	}
	goto again;
}

sub prompt_for_subkits {
	my @subkits;
	for my $prompt (@{$_[0]}) {
		my $subkit;

		if (exists $prompt->{choices}) {
			$subkit = prompt_for_subkits_alternates($prompt);
		} else {
			$subkit = prompt_for_subkits_optional($prompt);
		}

		push @subkits, $subkit if $subkit;
	}

	return @subkits;
}

sub active_credentials {
	my ($meta, $subkits) = @_;

	my $active = {};
	for my $sub (('base', @$subkits)) {
		next unless $meta->{credentials}{$sub};
		for my $path (keys %{ $meta->{credentials}{$sub} }) {
			if (exists $active->{$path} && ref $meta->{credentials}{$sub}{$path}) {
				for my $k (keys %{ $meta->{credentials}{$sub}{$path} }) {
					$active->{$path}{$k} = $meta->{credentials}{$sub}{$path}{$k};
				}
			} else {
				$active->{$path} = $meta->{credentials}{$sub}{$path};
			}
		}
	}
	return $active;
}

sub active_certificates {
	my ($meta, $subkits) = @_;

	my $active = {};
	for my $sub (('base', @$subkits)) {
		next unless $meta->{certificates}{$sub};
		for my $path (keys %{ $meta->{certificates}{$sub} }) {
			if (exists $active->{$path} && ref $meta->{certificates}{$sub}{path}) {
				for my $k (keys %{ $meta->{certificates}{$sub}{$path} }) {
					$active->{$path}{$k} = $meta->{certificates}{$sub}{$path}{$k};
				}
			} else {
				$active->{$path} = $meta->{certificates}{$sub}{$path};
			}
		}
	}
	return $active;
}

sub target_vault {
	my ($target) = @_;
	if ($target) {
		system(qw(safe target), $target) == 0 or exit 1;
	} else {
		system(qw(safe target -i)) == 0 or exit 1;
	}
}
# generate (and optionally rotate) credentials.
#
## just rotate credentials
# vaultify_secrets $kit_metadata,
#                  target       => "my-vault",
#                  env          => "us-east-sandbox",
#                  prefix       => "us/east/sandbox",
#                  scope        => 'rotate'; # or scope => '' or undef
#
## generate all credentials (including 'fixed' creds)
# vaultify_secrets $kit_metadata,
#                  target       => "my-vault",
#                  env          => "us-east-sandbox",
#                  prefix       => "us/east/sandbox",
#                  scope        => 'force';
#
## generate only missing credentials
# vaultify_secrets $kit_metadata,
#                  target       => "my-vault",
#                  env          => "us-east-sandbox",
#                  prefix       => "us/east/sandbox",
#                  scope        => 'add';
#
sub vaultify_secrets {
	my ($meta, %options) = @_;
	$options{env} or die "vaultify_secrets() was not given an 'env' option.\n";

	my $creds = active_credentials($meta, $options{subkits} || {});
	if (%$creds) {
		explain " - auto-generating credentials (in secret/$options{prefix})...\n";
		for (safe_commands $creds, %options) {
			system('safe', @$_);
			die "Failure autogenerating credentials.\n" if ($? >> 8);
		}
	} else {
		explain " - no credentials need to be generated.\n";
	}

	my $certs = active_certificates($meta, $options{subkits} || {});
	if (%$certs) {
		explain " - auto-generating certificates (in secret/$options{prefix})...\n";
		for (cert_commands $certs, %options) {
			system('safe', @$_);
			die "Failure autogenerating certificates.\n" if ($? != 0);
		}
	} else {
		explain " - no certificates need to be generated.\n";
	}
}

sub check_secrets {
	my ($meta, %options) = @_;
	$options{env} or die "check_secrets() was not given an 'env' option.\n";

	my @missing = ();
	for (safe_commands(active_credentials($meta, $options{subkits}||{}),%options)) {
		push @missing, check_secret($_, %options);
	}
	for (cert_commands(active_certificates($meta, $options{subkits}||{}),%options)) {
		push @missing, check_secret($_, %options);
	}
	if (@missing) {
		my $suf = scalar(@missing) == 1 ? '' : 's';
		printf "Missing %d credential%s or certificate%s:\n  * %s\n",
			scalar(@missing), $suf, $suf,
			join ("\n  * ", map {join " ", @$_} @missing);
		return 1;
	} else {
		print "All credentials and certificates present.\n";
		return 0;
	}
}

# build a columnar display of tabular data,
# tablify($headers, [$row1,$row2,...])
sub tablify {
	my ($headers_ref, $rows_ref) = @_;
	my @headers = @{$headers_ref};
	my @rows    = @{$rows_ref};
	my @widths  = map { length $_ } @headers;

	for my $row (@rows) {
		next unless $row;
		for (my $i = 0; $i < @$row; $i++) {
			my $l = length($row->[$i] || '');
			$widths[$i] = $l unless defined $widths[$i] and $widths[$i] > $l;
		}
	}
	@widths = map { $_ + 4 } @widths;

	for (my $i = 0; $i < @headers; $i++) {
		printf("%-*s", $widths[$i], $headers[$i]);
	}
	printf("\n");

	for (my $i = 0; $i < @headers; $i++) {
		printf("%-*s", $widths[$i], ("=" x length($headers[$i])));
	}
	printf("\n");

	for my $row (@rows) {
		if ($row) {
			for (my $i = 0; $i < @$row; $i++) {
				printf("%-*s", $widths[$i], $row->[$i]);
			}
		}
		printf("\n");
	}
}

# bosh_target_for $env
sub bosh_target_for {
	my ($env) = @_;
	if (defined($ENV{GENESIS_BOSH_ENVIRONMENT})) {
		`$BOSH "-e" $ENV{GENESIS_BOSH_ENVIRONMENT} "env" &>/dev/null`;
		return $ENV{GENESIS_BOSH_ENVIRONMENT} if ($? == 0);
		die "No such host: $ENV{GENESIS_BOSH_ENVIRONMENT} from GENESIS_BOSH_ENVIRONMENT environment variable for the BOSH Director.\n";
	}
	if (defined($ENV{BOSH_ENVIRONMENT})) {
		`$BOSH "-e" $ENV{BOSH_ENVIRONMENT} "env" &>/dev/null`;
		return $ENV{BOSH_ENVIRONMENT} if ($? == 0);
		die "No such host: $ENV{BOSH_ENVIRONMENT} from BOSH_ENVIRONMENT environment variable for the BOSH Director you are targeting at.\n";
	}
	my $bosh = get_key($env, 'params.bosh');
	if (defined($bosh)) {
		`$BOSH "-e" $bosh "env" &>/dev/null`;
		return $bosh if ($? == 0);
		die "No such host: $bosh for the BOSH Director which you configured in params.bosh.\n";
	 }
	$bosh = get_key($env, 'params.env');
	if (defined($bosh)) {
		`$BOSH "-e" $bosh "env" &>/dev/null`;
		return $bosh if ($? == 0);
		die "No such host: $bosh for the BOSH Director which you configured in params.env. You can specify your BOSH Director alias name in params.bosh.\n";
	}
	die "Could not find the `params.bosh' or `params.env' key in $env!\n";
}


###########################################################################

my ($COMMAND, %COMMAND, %USAGE);

sub usage {
	my ($rc, $msg, $cmd) = @_;
	$cmd = $COMMAND unless $cmd;
	print STDERR "$msg\n\n" if $msg;
	print STDERR $USAGE{$cmd} if $USAGE{$cmd};
	exit $rc;
}

our $GLOBAL_USAGE = <<EOF;
  -h, --help        Show this help screen.
  -D, --debug       Enable debugging, printing helpful message about what
                    Genesis is doing, to standard error.
  -T, --trace       Even more debugging, including debugging inside called
                    tools (like spruce and bosh).
  -C, --cwd         Effective working directory.  Defaults to '.'
  -e, --environment Which BOSH environment (aka director) to use.  If not
                    specified, it will use the value in params.bosh or
                    params.env in that order.  Can also be provided using either
                    \$GENESIS_BOSH_ENVIRONMENT or \$BOSH_ENVIRONMENT env variables.
EOF
sub options {
	my ($args, $options, @spec) = @_;
	$options->{color} = 1 unless exists $options->{color};
	GetOptionsFromArray($args, $options,
		(qw/
			help|h
			debug|D
			trace|T
			quiet|q
			offline
			cwd|C=s
			environment|e=s
			color!
		/,
		@spec))
			or usage(1);

	usage(0) if $options->{help};

	$ENV{QUIET}   = 'y' if  $options->{quiet};
	$ENV{DEBUG}   = 'y' if  $options->{debug};
	$ENV{TRACE}   = 'y' if  $options->{trace};
	$ENV{NOCOLOR} = 'y' if !$options->{color};
	$ENV{OFFLINE} = 'y' if  $options->{offline};

	debug("bosh env: ".($options->{environment} || "-same-as-env-file-"));

	$ENV{GENESIS_BOSH_ENVIRONMENT} = $options->{environment}
		if $options->{environment};
	chdir_or_fail $options->{cwd} if $options->{cwd};
}

sub command {
	my ($name, $usage, $fn) = @_;
	if (ref($name) ne 'ARRAY') {
		$name = [$name];
	}
	for my $cmd (@$name) {
		$USAGE{$cmd}   = $usage;
		$COMMAND{$cmd} = sub {
			$COMMAND = $cmd;
			$fn->(@_);
		};
	}
}


###########################################################################

# genesis help - print the help screen. {{{

command("help", <<EOF,
genesis v$VERSION
USAGE: genesis [OPTIONS] COMMAND [MORE OPTIONS]

OPTIONS
$GLOBAL_USAGE
COMMANDS
  create-kit       Create a new kit with default scaffolding.
  compile-kit      Create a distributable kit archive from dev.
  decompile-kit    Unpack a kit archive to dev.
  deploy           Generate a real manifest using Vault + Cloud Config, and deploy it to BOSH.
  describe         Describe a Concourse pipeline, in words.
  download         Download a Genesis Kit from the Internet.
  graph            Draw a Concourse pipeline.
  init             Initialize a new Genesis deployment.
  lookup           Find a key set in environment manifests.
  manifest         Generate a redacted BOSH deployment manifest for an environment.
  new              Create a new Genesis deployment environment.
  ping             See if the genesis binary is a real thing.
  repipe           Configure a Concourse pipeline for automating deployments.
  secrets          Re-generate / rotate credentials (passwords, keys, etc.).
  summary          Print a summary of defined environments.
  version          Print the version of genesis
  yamls            Print a list of the YAML files used for a single environment.

See `genesis COMMAND -h' for more specific, per-command usage information.
EOF
sub {
	usage(0);
});

# }}}
# genesis ping - see if the genesis binary is a real thing. {{{

command("ping", <<EOF,
genesis v$VERSION
USAGE: genesis ping

OPTIONS
$GLOBAL_USAGE
EOF
sub {
	check_prereqs(no_repo_needed => 1);
	print "PING!\n";
});

# }}}
# genesis version - Print the version of Genesis. {{{

command("version", <<EOF,
genesis v$VERSION
USAGE: genesis version

OPTIONS
$GLOBAL_USAGE
EOF
sub {
	print "Genesis v$VERSION\n";
});

# }}}
# genesis embed - embed Genesis in the repository {{{

command("embed", <<EOF,
genesis v$VERSION
USAGE: genesis embed

OPTIONS
$GLOBAL_USAGE
EOF
sub {
	my %options;
	options(\@_, \%options, qw/
	/);
	usage(1) if @_;
	check_prereqs;

	# FIXME: update .genesis/config with new version info
	mkdir_or_fail ".genesis/bin";
	copy_or_fail $0, ".genesis/bin/genesis";
	chmod_or_fail 0755, ".genesis/bin/genesis";
});
# }}}
#  genesis init - initialize a new Genesis repository {{{

command("init", <<EOF,
genesis v$VERSION
USAGE: genesis init [-k KIT/VERSION] [-d directory] [name]

OPTIONS
$GLOBAL_USAGE
  -k, --kit           Name (and optionally, version) of the Genesis Kit to base
                      these deployments on.  I.e.: shield/6.3.0.  If you do not
                      specify a kit, a dev directory will be created for you to
                      develop a local kit into.
  -L, --link-dev-kit  Instead of using a kit or initializing an empty dev
                      directory, this will link the specified directory to the
                      dev directory.
  -d, --directory     By default, the directory in which the Genesis deployment
                      will be created in will be named ./<name>-deployments.
                      Use this option to change it to something else.

  name                If the name argument is not specified, it will default to
                      the same name as the kit.  You must specify either name
                      or kit.
EOF
sub {
	my %options;
	options(\@_, \%options, qw/
		kit|k=s
		directory|d=s
		link-dev-kit|L=s
	/);
	usage(1) if @_ > 1; # name is now optional if kit specified
	check_prereqs(no_repo_needed => 1);

	my $abs_target;
	if ($options{'link-dev-kit'}) {
		usage(1,"Cannot specify both a kit (-k) and a link to a kit (-L)") if $options{kit};
		$abs_target = abs_path($options{'link-dev-kit'});
		my $pwd = getcwd;
		die "Link target '$options{'link-dev-kit'}' cannot be found from $pwd!\n" unless $abs_target;
	}

	my ($name) = @_;
	unless ($name) {
		if ($options{kit}) {
			($name, $_) = extract_kit_name_and_version($options{kit});
		} elsif ($options{'link-dev-kit'}) {
			$name = basename($options{'link-dev-kit'});
		} else {
			printf STDERR "You must specify a deployment name if you don't specify a kit or a dev link target.\n";
			usage(1);
		}
	}
	$name =~ s/-deployments//;

	validate_repo_name $name or die "Invalid Genesis repo name '$name'\n";

	debug "generating a new Genesis repo, named $name";

	debug "checking git config so can git commit later";
	execute 'git config user.name'
		or die 'Please setup git - git config --global user.name "Your Name" -';
	execute 'git config user.email'
		or die 'Please setup git - git config --global user.email your@email.com -';

	my $root = $options{directory} || "${name}-deployments";
	debug "in directory $root";
	if (-e $root) {
		die "Attempted to create new environment `$root' failed: Path already exists.\n";
	}
	mkdir_or_fail $root;
	mkdir_or_fail "$root/.genesis";
	put_file "$root/.genesis/config", <<EOF;
---
genesis: $VERSION
deployment_type: $name
EOF
	mkdir_or_fail "$root/.genesis/bin";
	copy_or_fail  $0, "$root/.genesis/bin/genesis";
	chmod_or_fail 0755, "$root/.genesis/bin/genesis";
	put_file "$root/README.md", <<EOF;
$name deployments
==============================

This repository contains the YAML templates that make up a series of
$name BOSH deployments, using the format prescribed by the
[Genesis][1] utility. These deployments are based off of the
[$name-genesis-kit][2].

Environment Naming
------------------

Each environment managed by this repository will have its own
deployment file, e.g. `us-east-prod.yml`. However, in many cases,
it can be desirable to share param configurations, or kit configurations
across all of the environments, or specific subsets. Genesis supports
this by splitting environment names based on hypthens (`-`), and finding
files with common prefixes to include in the final manifest.

For example, let's look at a scenario where there are three environments
deployed by genesis: `us-west-prod.yml`, `us-east-prod.yml`, and `us-east-dev.yml`.
If there were configurations that should be shared by all environments,
they should go in `us.yml`. Configurations shared by `us-east-dev` and `us-east-prod`
would go in `us-east.yml`.

To see what files are currently in play for an environment, you can run
`genesis <environment-name>`

Quickstart
----------

To create a new environment (called us-east-prod-$name):

    genesis new us-east-prod

To build the full BOSH manifest for an environment:

    genesis manifest us-east-prod

... and then deploy it:

    genesis deploy us-east-prod

To rotate credentials for an environment:

    genesis secrets us-east-prod
    genesis deploy us-east-prod

To update the Concourse Pipeline for this repo:

    genesis repipe

To download a new version of the kit, and deploy it:

    genesis download $name [version] # omitting version downloads the latest

    # update the environment yaml to use the desired kit version,
    # this might be in a different file if using CI to propagate
    # deployment upgrades (perhaps us.yml)
    vi us-east-prod.yml

    genesis deploy us-east-prod.yml # or commit + git push for CI to run through the upgrades

See the [Deployment Pipeline Documentation][3] for more
information on getting set up with Concourse deployment pipelines.

Helpful Links
-------------

- [$name-genesis-kit][2] - Details on the kit used in this repo,
  its subkits, prerequesites, and params.
- [Deployment Pipeline Documentation][3] - Docs on all the
  configuration options for `ci.yml`, and how the automated
  deployment pipelines behave.

[1]: https://github.com/starkandwayne/genesis
[2]: https://github.com/genesis-community/$name-genesis-kit
[3]: https://github.com/starkandwayne/genesis/blob/master/docs/PIPELINES.md

Repo Structure
--------------

Most of the meat of the deployment repo happens at the base level.
Envirionment YAML files, shared YAML files, and the CI
configuration YAML file will all be here.

The `.genesis/manifests` directory saves redacted copies of the
deployment manifests as they are deployed, for posterity, and to
keep track of any `my-env-name-state.yml` files from `bosh create-env`.

The `.genesis/cached` directory is used by CI to propagate changes
for shared YAML files along the pipelines. To aid in CI deploys, the
`genesis/bin` directory contains an embedded copy of genesis.

`.genesis/kits` contains copies of the kits that have been used in
this deployment. Once a kit is no longer used in any environment,
it can be safely removed (`genesis summary`).

`.genesis/config` is used internally by `genesis` to understand
what is being deployed, and how.
EOF

	chdir_or_fail $root;

	if ($options{'link-dev-kit'}) {
		debug "Kit: linking dev to $abs_target";
		symlink_or_fail $abs_target, "./dev";
	} elsif ($options{kit}) {
		debug "Kit: installing kit $options{kit}";
		my ($kit, $version) = extract_kit_name_and_version($options{kit});
		download_kit_tarball($kit, $version);
	} else {
		debug "Kit: creating empty ./dev kit directory";
		mkdir_or_fail "./dev";
	}

	execute 'git init'
		or die "Failed to initialize a git repository in $root/\n";
	execute 'git add .'
		or die "Failed to stage files to git, for initial commit, in $root/\n";
	execute 'git commit -m "Initial Genesis Repo"'
		or die "Failed to commit initial Genesis repository in $root/\n";

	exit 0;
});

# }}}
# genesis new - create a new Genesis deployment environment (YAML file) {{{

command("new", <<EOF,
genesis v$VERSION
USAGE: genesis new [--vault target] env-name[.yml]

OPTIONS
$GLOBAL_USAGE
      --vault        The name of a `safe' target (a Vault) to store newly
                     generated credentials in.

      --no-secrets   Do not generate secrets in the Vault.  You will have to
                     manually run `genesis secrets` yourself.

  -k, --kit          Name (and optionally, version) of the Genesis Kit to
                     use for this environment.  I.e.: shield/6.3.0
                     Defaults to latest.
EOF
sub {
	my %options = (
		secrets => 1,
	);
	options(\@_, \%options, qw/
		vault=s
		secrets!
		kit|k=s
	/);
	usage(1) if @_ != 1;

	my ($name) = @_;
	$name =~ s/\.ya?ml$//;

	validate_env_name $name or die "Invalid environment name '$name'\n";
	-f "$name.yml" and die "Environment '$name' already exists\n";

	at_exit(sub {
		# remove the env file if either prereqs check or vaultification fails
		unlink "$name.yml" unless $? == 0;
	});

	check_prereqs;
	explain "Generating new environment #C{$name}...\n";

	my ($kit, $version);
	if ($options{kit}) {
		($kit, $version) = extract_kit_name_and_version($options{kit});
	} else {
		($kit, $version) = latest_kit_name_and_version();
	}
	if ($kit && $kit ne "dev") {
		explain "Using $kit/$version kit...\n";
	} else {
		explain "Using dev/ (development version) kit...\n";
	}

	my $meta = read_kit_metadata($kit, $version);

	explain "Checking kit pre-requisites...\n";
	check_kit_prereqs($kit, $version);

	my @subkits = prompt_for_subkits($meta->{subkits} || []);
	@subkits = run_subkit_hook($kit, $version, @subkits);
	validate_subkits($kit, $version, $meta, @subkits);

	my $deployment = $name . "-" . deployment_suffix;
	(my $prefix = $name) =~ s|-|/|g;
	$prefix = "$prefix/".deployment_suffix;

	if ($options{secrets}) {
		target_vault($options{vault});
	}

	my $params = process_kit_params(kit          => $kit,
									version      => $version,
									env          => $name,
									vault_prefix => $prefix,
									should_vault => $options{secrets},
									params       => $meta->{params} || [],
									subkits      => \@subkits);
	$params = run_param_hook($kit, $version, $name, $prefix, $params, @subkits);

	new_environment($meta, $kit, $version, $name, $prefix, $params, @subkits);

	if ($options{secrets}) {
		explain "Generating secrets / credentials (in secret/$prefix)...\n";
		vaultify_secrets($meta, env          => $name,
		                        prefix       => $prefix,
		                        scope        => 'force',
		                        subkits      => [@subkits]);
	} else {
		explain "Skipping generation of secret / credentials.\n";
		explain "Don't forget to run `$0 secrets $name`\n";
	}

	explain "New environment $name provisioned.\n";
});



# }}}
# genesis ci - generate pipeline YAML template file to be used by genesis repipe to generate a pipeline file. {{{

command("ci", <<EOF,
genesis v$VERSION
USAGE: genesis ci [--name ci.yml]

OPTIONS
$GLOBAL_USAGE
        --name          The name of the configuration yaml file to generate, default is `ci.yml'
    -f, --force         Force overwrite the configuraiton yaml file if it already exists.
        --vault-prefix  The prefix for any new vault secrets (default: concourse-ci)

EOF
sub {
	my (%options,%pipeline, $prompt, $default);

	options(\@_, \%options, qw/
		name=s
		vault=s
		vault-prefix=s
		force|f
	/);
	usage(1) if @_ != 0;
	check_prereqs;

	$ENV{GENESIS_CI_VAULT_PREFIX} = $options{'vault-prefix'}
		if $options{'vault-prefix'};
	$ENV{GENESIS_CI_VAULT_PREFIX} ||= "concourse-ci";

	my $name = $options{name} || "ci.yml";
	die "Pipeline configuration file '$name' already exists\n"
		if -f $name && ! $options{force};

	at_exit(sub {
		unlink "$name" unless $? == 0;
	});

	# Detect envs
	my %envs = valid_envs();
	die "\nERROR: No environments found -- cannot continue.\n\n"
		unless %envs;

	explain "\nGenerating new CI YAML Template #C{$name}...";

	target_vault($options{vault});

	explain "#Y{Setting Common Configuration}\n#Y{----------------------------}";

	$pipeline{name} = prompt_for_line(clean_heredoc(<<"	|EOF"), undef, basename(getcwd));
	|Please provide the name of you pipeline as you'd like it to appear in Concourse
	|EOF

	$pipeline{public} = prompt_for_boolean(clean_heredoc(<<"	|EOF"),0);
	|Would you like to make the Concourse pipeline (and all logs related to deployments) public?
	|EOF

	$pipeline{tagged} = prompt_for_boolean(clean_heredoc(<<"	|EOF"),0);
	|Would you like to use tags on each job (If unsure, choose no)?
	|EOF

	$pipeline{debug} = prompt_for_boolean(clean_heredoc(<<"	|EOF"),0);
	|Would you like to have debug output on BOSH jobs?
	|EOF

	$pipeline{skip_upkeep} = prompt_for_boolean(clean_heredoc(<<"	|EOF"), 0, "invert");
	|Would you like to automatically keep your stemcells up to date?
	|EOF

	my %chosen_envs;
	($pipeline{boshes},$pipeline{stemcells},%chosen_envs) = prompt_for_boshes_and_stemcells_for(!$pipeline{skip_upkeep}, %envs);

	$pipeline{layouts} = prompt_for_layouts_for(%chosen_envs);

	$pipeline{errands} = prompt_for_list("line",clean_heredoc(<<"	|EOF"), 'errand');
	|Enter any errands you'd like to use to test your deployments
	|e.g.: smoke-tests
	|EOF

	$pipeline{locker} = prompt_for_locker();

	$pipeline{vault} = prompt_for_vault($pipeline{name},%chosen_envs);

	$pipeline{git} = prompt_for_git($pipeline{name});

	do {
		$pipeline{notifications} = prompt_for_notifications();
		explain "\n#r{ERROR: You must have at least one notification system!}"
			unless %{$pipeline{notifications}};
	} until (%{$pipeline{notifications}});

	generate_ci_template_file(\%pipeline, $name);

	explain "\n#g{Generated CI template file:} #C{$name}\n";
});

sub prompt_for_git {
	explain "\n#Y{Git Repository Details}";
	my $pipeline_name = shift;
	my %git;
	my ($user,$host,$org,$repo) = ("git","github.com",undef,$pipeline_name);
	my $gitremote = qx(git config --get remote.origin.url);
	if ($gitremote) {
		chomp($gitremote);
		($user,$host,$org,$repo) = $gitremote =~ qr/^(?:ssh:\/\/([^@]+)@)?([^\/:]*)[\/:](?:(.*)\/)?([^\/]+)$/
		  if $gitremote =~ qr/^ssh:.*/;
	  ($host,$org,$repo) = $gitremote =~ qr/^https:\/\/([^\/:]*)[\/:](?:(.*)\/)?([^\/]+)$/
		if $gitremote =~ qr/^https:.*/;

		$repo =~ s/\.git$// if $repo;
	}

	$git{host} = prompt_for_line("What is the Git host?", undef, $host);
	$git{user} = prompt_for_line("What is the Git user on $git{host}?", undef, $user);
	$git{repo} = prompt_for_line("What is the name of the Git repository?", undef, $repo);
	$git{owner} = prompt_for_line("What organization owns the '$git{repo}' repository?", undef, $org);

	my $key_choice = prompt_for_choice(clean_heredoc(<<"	|EOF"),[qw|reuse add new|],'reuse',["Use existing key in Vault","Add an existing key in Vault", "Generate a new key"]);
	|How would you like to provide a SSH private key that has write access for $git{user}\@$git{host}.
	|EOF

	my $path = "secret/$ENV{GENESIS_CI_VAULT_PREFIX}/git-ssh/$git{user}\@$git{host}/$git{owner}/$git{repo}";
	if ($key_choice eq 'reuse') {
		$git{private_key} = prompt_for_line(clean_heredoc(<<"		|EOF"),undef,"$path:private", "vault_path");
		|What is the vault path for your git private key?
		|EOF
	} elsif ($key_choice eq 'new') {
		my $result = qx(safe ssh 4096 $path);
		die "Failed to generate Git SSH key: $result\n" if $? > 0;
		my $fingerprint = qx(safe get $path:fingerprint);
		die "Failed to get SSH key fingerprint from $path:fingerprint\n$fingerprint\n" if $? > 0;
		my $pubkey = qx(safe get $path:public);
		die "Failed to get public SSH key from $path:public\n$pubkey\n" if $? > 0;
		chomp($pubkey,$fingerprint);
		explain "\nGenerated 4096-bit SSH key (fingerprint: $fingerprint) in Vault under #W{$path}\n\n#R{IMPORTANT:} Add this PUBLIC key to your Git provider ($git{host}) to grant access for this pipeline:\n\n$pubkey";
		$git{private_key} = "$path:private";

	} else {
		my $key =  "private";
		my $vault_path = "$path:$key";
		my $answer = prompt_for_block("Enter your SSH private key for $git{user}\@$git{host}:$git{owner}/$git{repo}");
		my $tmpdir = workdir;
		open my $fh, ">", "$tmpdir/sshkeyforgit" or die "Could not write to $tmpdir/param: $!\n";
		print $fh $answer;
		close $fh;
		my $err = qx(safe set "$path" "$key\@$tmpdir/sshkeyforgit" 2>&1);
		die "$err\n\nFailed to save data to $vault_path in Vault\n" if ($? >> 8);
		explain "Stored SSH private key in Vault under #W{$vault_path}";
		$git{private_key} = $vault_path;
	}
	return \%git;
}

sub prompt_for_notifications {
	my (%notifications,$have_key);

	explain "\n#Y{Notification Details}";

	if (prompt_for_boolean("Would you like to configure Slack notification?", 1)) {
		$notifications{slack}{webhook} = prompt_for_line(clean_heredoc(<<"		|EOF"), undef, undef, "url");
		|What is your Slack Integration WebHook URL?
		|EOF
		$notifications{slack}{channel} = prompt_for_line("\nWhich slack channel which will receive notifications?");
	}

	if (prompt_for_boolean("Would you like to configure email notification via SMTP?", 0)) {
		$notifications{email}{smtp}{host} = prompt_for_line("\nWhat is the SMTP host?");
		$notifications{email}{smtp}{port} = prompt_for_line("\nWhat is the SMTP port?", undef, undef, "0-65535");
		$notifications{email}{smtp}{username} = prompt_for_line("\nWhat is the SMTP username?");

		$have_key = prompt_for_boolean(clean_heredoc(<<"		|EOF"));
		|You will need to provide the password for your SMTP user.  Do you already have this
		|available in your vault?
		|EOF

		if ($have_key) {
			$notifications{email}{smtp}{password} = prompt_for_line(clean_heredoc(<<"			|EOF"),undef,undef, "vault_path");
			|What is the vault path for your email SMTP password?
			|ex: secret/notifications/email/smtp:password
			|EOF
		} else {
			my $path = "secret/$ENV{GENESIS_CI_VAULT_PREFIX}/notifications/smtp/$notifications{email}{smtp}{host}/$notifications{email}{smtp}{username}";
			my $key =  "password";
			my $vault_path = "$path:$key";
			system "safe", "prompt", "What is your email SMTP password?", "--", "set", $path, $key;
			die "Failed to save data to $vault_path in Vault\n" if ($? >> 8);
			explain "Stored SMTP password in Vault under #W{$vault_path}";
			$notifications{email}{smtp}{password} = $vault_path;
		}
		$notifications{email}{to} = prompt_for_line("What email address will the notifications be sent to?");
		$notifications{email}{from} = prompt_for_line("What email address will the notifictions will be sent from?");
	}

	if (prompt_for_boolean("Would you like to configure HipChat notification?", 0)) {
		$have_key = prompt_for_boolean(clean_heredoc(<<"		|EOF"));
		|You will need to provide the HipChat notification token.  Do you already have this
		|available in your vault?
		|EOF

		if ($have_key) {
			$notifications{hipchat}{token} = prompt_for_line(clean_heredoc(<<"			|EOF"),undef,undef, "vault_path");
			|What is the vault path for your HipChat token?
			|ex: secret/notifications/hipchat:token
			|EOF
		} else {
			my $path = "secret/$ENV{GENESIS_CI_VAULT_PREFIX}/notifications/smtp/$notifications{email}{smtp}{host}/$notifications{email}{smtp}{username}";
			my $key =  "token";
			my $vault_path = "$path:$key";
			system "safe", "prompt", "What is your HipChat token?", "--", "set", $path, $key;
			die "Failed to save data to $vault_path in Vault\n" if ($? >> 8);
			explain "Stored HipChat token in Vault under #W{$vault_path}";
			$notifications{hipchat}{token} = $vault_path;
		}
		$notifications{hipchat}{room_id} = prompt_for_line("What is the ID of the room you want the notifications posted to?");
	}
	return \%notifications;
}

sub prompt_for_locker {
	my (%locker);

	explain "\n#Y{Workflow Details}";
	my $use_locker = prompt_for_boolean(clean_heredoc(<<"	|EOF"),1);
	|Locker is simple web app for managing locks.  Genesis pipelines can use it to prevent
	|multiple pipelines utilizing the same BOSH targets at the same time.  It is deployed
	|to the Concourse database node if you use the Concourse Genesis Kit to deploy Concourse.
	|
	|Would you like to use Locker?
	|EOF
	if ($use_locker) {
		$locker{url} = prompt_for_line("What is the URL to the locker API?", undef, undef, "url");
		$locker{username} = prompt_for_line("What is the locker API username?");
		my $have_key = prompt_for_boolean(clean_heredoc(<<"		|EOF"));
		|You will need to provide the Locker API password.  Do you already have this
		|available in your vault?
		|EOF

		if ($have_key) {
			$locker{password} = prompt_for_line(clean_heredoc(<<"			|EOF"),undef,undef, "vault_path");
			|What is the vault path for the Locker API password?
			|ex: secret/bosh/lite/concourse/locker/api:password
			|EOF
		} else {
			my $slug = $locker{url};
			$slug =~ s#^https?://##;
			$slug =~ s#[^a-zA-Z0-9\._-]+#_#g;
			my $path = "secret/$ENV{GENESIS_CI_VAULT_PREFIX}/locker/$slug";
			my $key =  "password";
			my $vault_path = "$path:$key";
			system "safe", "prompt", "What is your Locker API password?", "--", "set", $path, $key;
			die "Failed to save data to $vault_path in Vault\n" if ($? >> 8);
			explain "Stored Locker API password in Vault under #W{$vault_path}";
			$locker{password} = $vault_path;
		}
	}
	return \%locker;
}

sub prompt_for_vault {
	my ($name, %envs) = @_;
	explain "\n#Y{Vault Connection Details}";
	my (%vault,$safe_json);
	if (-f "$ENV{HOME}/.saferc") {
		eval {
			$safe_json = decode_json(qx(spruce json \$HOME/.saferc));
		};
	}
	if ($@ || ! $safe_json) {
		$vault{url} = prompt_for_line("\nWhat is the Vault URL?", undef, undef,"url");
		$vault{verify} = prompt_for_boolean("\nDo you want to skip SSL verification?\n\nDefault is no.\n", 0, 'invert');
	} elsif ($safe_json->{version} && $safe_json->{version}==1) {
		$vault{url} = $safe_json->{vaults}{$safe_json->{current}}{url};
		$vault{verify} = ! $safe_json->{vaults}{$safe_json->{current}}{skip_verify};
	} else {
		$vault{url} = $safe_json->{Aliases}{$safe_json->{Current}};
		$vault{verify} = ! $safe_json->{SkipVerify}{$vault{url}};
	}

	my $default_approle_path = "secret/$ENV{GENESIS_CI_VAULT_PREFIX}/$name/vault";
	my ($regenerate, $c);

	if (safe_path_exists $default_approle_path) {
		my $choices = ["use","regen","alt"];
		my $labels = [
			"Use this path for role_id and secret_id",
			"Regenerate new credentials to this path",
			"Specify alternate paths for role_id and secret_id",
		];
		$c = prompt_for_choice(clean_heredoc(<<"		|EOF"),$choices,"use",$labels);
		|Discovered Concourse AppRole credentials at $default_approle_path.
		|Do you want to:
		|EOF
	} else {
		my $choices = ["regen","alt"];
		my $labels = [
			"Generate credentials to this path",
			"Specify alternate paths for role_id and secret_id",
		];
		$c = prompt_for_choice(clean_heredoc(<<"		|EOF"),$choices,"use",$labels);
		|Could not find Concourse AppRole credentials at $default_approle_path.
		|Do you want to:
		|EOF
	}
	if ($c eq "use" || $c eq "regen") {
		$regenerate = ($c eq "regen");
		$vault{role}   = $default_approle_path . ":role_id";
		$vault{secret} = $default_approle_path . ":secret_id";
	} else {
		$vault{role} = prompt_for_line(clean_heredoc(<<"		|EOF"),undef,"$default_approle_path:role_id","/secret\/.*[^\/]:.+", "Expecting secret/<path>:<key>");
		|Please specify the path in Vault that contains the vault Role ID for Concourse
		|EOF
		$vault{secret} = prompt_for_line(clean_heredoc(<<"		|EOF"),undef,"$default_approle_path:secret_id",,"/secret\/.*[^\/]:.+", "Expecting secret/<path>:<key>");
		|Please specify the path in Vault that contains the vault Secret ID for Concourse
		|EOF

		if (safe_path_exists $vault{role} && safe_path_exists $vault{secret}) {

		} else {
			explain "#R{WARNING: $vault{role} doesn't exist!" unless safe_path_exists $vault{role};
			explain "#R{WARNING: $vault{secret} doesn't exist!" unless safe_path_exists $vault{secret};
			die "Exiting.\n" unless prompt_for_boolean(clean_heredoc(<<"			|EOF"));
			|To use these paths, the Concourse AppRole credentials will have to be (re-)generated.
			|Continue [y|n]?
			|EOF
			$regenerate = 1;
		}
	}

	if ($regenerate) {
		my @paths;
		foreach (keys %envs) {
			my $env = $envs{$_}{env};
			explain "#Y{Determining Vault paths needed for $env ...}\n";

			my $dir = workdir;
			if (is_create_env($env)) {
				write_stemcell_data("$dir/cloud.yml"); # Why write stemcell to cloud.yml??!!
			} else {
				bosh_download_cloud_config(bosh_target_for($env), "$dir/cloud.yml");
			}
			my %options = ('cloud-config' => "$dir/cloud.yml");
			my $vault_prefix = $envs{$_}{vault};
			push @paths, "secret/$vault_prefix/*";
			my @merge_files = @{merge_files($envs{$_}{file}, \%options)};
			for my $extra_path (sort grep {chomp; $_ !~ m/^secret\/$vault_prefix\// } spruce_vault_paths(@merge_files)) {
				push @paths, $extra_path;
			}
		}
		push @paths, "secret/handshake";
		generate_ci_approle_policies(
			$name,
			$vault{role},
			$vault{secret},
			@paths
		)
	};

	return \%vault;
}

sub prompt_for_boshes_and_stemcells_for {
	my ($ask_stemcells, %envs) = @_;

	# Get the current boshes
	my (%boshes, %chosen_envs);
	if (-f $ENV{HOME}."/.bosh/config") {
		my $bosh_json = decode_json(qx{spruce json \$HOME/.bosh/config});
		$boshes{$_->{alias}} = {
			#url => (($_->{url} =~ /:\d+$/) ? $_->{url} : $_->{url}.":25555"),
			url => $_->{url},
			username => $_->{username},
			password => $_->{password},
			ca_cert => $_->{ca_cert},
		} foreach (@{$bosh_json->{environments}});
		$boshes{$boshes{$_}{url}} = $boshes{$_} foreach (keys %boshes);
	}

	explain "\n#Y{Processing Detected Environments}\n#Y{--------------------------------}";

	my (%boshenvs,%used_stemcells);
	foreach my $e (sort keys(%envs)) {
		my $env = $envs{$e}{env};
		explain "\n#W{==> Environment:} #C{$env} (./$envs{$e}{file})";
		next unless prompt_for_boolean("Do you want to use this environment [y|n]?", 1);
		$chosen_envs{$e} = $envs{$e};

		$boshenvs{$env} = {};
		my %bosh_info = %{$boshes{$envs{$e}{bosh}}};
		# Get display name (defaults to environment)
		$boshenvs{$env}{alias} = prompt_for_line("Display name", undef, $env);

		if (is_valid_uri($envs{$e}{bosh})) {
			$boshenvs{$env}{url} = $envs{$e}{bosh};
		} else {
			$boshenvs{$env}{url} = $bosh_info{url};
			$boshenvs{$env}{url} .= ":25555" unless $boshenvs{$env}{url} =~ m/:\d+$/;
		}
		if ($boshenvs{$env}{url}) {
			explain "\nUsing BOSH director at #C{$boshenvs{$env}{url}}";
		} else {
			$boshenvs{$env}{url} = prompt_for_line("Could not determine BOSH url -- please specify fully\ne.g.: https://10.0.1.44:25555");
			$boshenvs{$env}{url} .= ":25555" unless $boshenvs{$env}{url} =~ m/:\d+$/;
		}

		if ($bosh_info{username}) {
			$boshenvs{$env}{username} = $bosh_info{username};
			explain "\nUsing BOSH admin username #C{'$boshenvs{$env}{username}'}";
		} else {
			$boshenvs{$env}{username} = prompt_for_line(
				undef,
				"Admin Username",
				"admin"
			);
		}

		(my $safe_slug = "secret/$envs{$e}{bosh}") =~ s/-/\//g;
		if (safe_path_exists("$safe_slug/bosh/users/admin:password")) {
			$boshenvs{$env}{password} = "$safe_slug/bosh/users/admin:password";
			explain "\nUsing BOSH admin password in Vault under #C{'$boshenvs{$env}{password}'}";
		} else {
			$boshenvs{$env}{password} = prompt_for_line(clean_heredoc(<<"			|EOF"),"Specify vault path", undef, "vault_path");
			|Could not locate the password for admin user in Vault under:
			|$safe_slug/bosh/users/admin:password.
			|EOF
		}
		if (safe_path_exists("$safe_slug/bosh/ssl/ca:certificate")) {
			$boshenvs{$env}{ca_cert} = "$safe_slug/bosh/ssl/ca:certificate";
			explain "\nUsing BOSH CA Certificate in Vault under #C{'$boshenvs{$env}{ca_cert}'}";
		} else {
			$boshenvs{$env}{ca_cert} = prompt_for_line(clean_heredoc(<<"			|EOF"),"Specify vault path", undef, "vault_path");
			|Could not locate the BOSH SSL CA certificate in Vault under:
			|$safe_slug/bosh/ssl/ca:certificate.
			|EOF
		}

		
		my ($stemcells, %candidates) = ([]);
		if ($ask_stemcells) {
			explain "\nFetching stemcells from BOSH...";
			my $sc_info = qx($BOSH -e $boshenvs{$env}{url} ss);
			if ($? > 0) {
				# Couldn't get stemcells - ask for them manually (just die for now)
				die "Could not retrieve stemcell\n";
			} else {
				my (@choices, @labels);
				foreach (split("\n", $sc_info)) {
					my ($stemcell, undef, $os) = split(' ',  $_);
					next unless $stemcell;
					
					my ($alias) = split("-$os-",$stemcell);
					$alias =~ s/^bosh-//;
					$alias .= '-$os' if $candidates{$alias} &&($candidates{$alias} ne $stemcell);
					next if $candidates{$alias};
					$candidates{$alias} = $stemcell;
					push @choices, $alias;
					push @labels, $stemcell;
				}
				$stemcells = prompt_for_choices("Select one or more stemcells to watch for updates",\@choices,1,undef,\@labels);
			}
		}
		$boshenvs{$env}{stemcells} = $stemcells;
		$used_stemcells{$_} = $candidates{$_} foreach (@$stemcells);

		print "\n";
	}

	die "NO REMAINING ENVIRONMENTS - Cannot continue!\n" unless %chosen_envs;

	return (\%boshenvs, \%used_stemcells, %chosen_envs);
}

sub prompt_for_layouts_for {
	my %envs = @_;

	explain "\n#Y{Buliding Pipeline Layouts}\n#Y{-------------------------}";
	my %layouts = ();
	my $default_layout = "default";
	my $validate = undef;
	do {
		my $name = prompt_for_line("Name of ".ordify(keys(%layouts) + 1)."layout", undef, $default_layout, $validate);
		$default_layout = undef if $default_layout && $name eq $default_layout;

		explain "\n#G{Valid deployment environments:} ".join(", ", sort keys(%envs))."";
		my $validate_pathway = sub() {
			my @valid_envs = grep {defined($envs{$_})} split(" -> ",$_[0]);
			my @invalid_envs = grep {!defined($envs{$_})} split(" -> ",$_[0]);
			return "Unknown environment specified: ${\join(', ', map {qq('$_')} @invalid_envs)}" if @invalid_envs;
			return "No environments specified" unless @valid_envs;
			# TODO: also check for duplicates and cycles
			return "";
		};

		$layouts{$name}{deployments_chains} = prompt_for_list("line", clean_heredoc(<<"		|EOF"),"deployment pathway",1,undef,$validate_pathway,undef,"\n\nSpecify one or more deployment pathways (leave empty to end)\n" );
		|Deployment pathways describe the flow of the pipeline from one passing deployment
		|to the next.  You can specify multiple pathways, and reuse environments across
		|pathways, as long as no cycles are created.
		|e.g.:  ${\join(" -> ", sort keys(%envs))}
		|EOF

		my $auto_triggers = prompt_for_choices(clean_heredoc(<<"		|EOF"), [(sort keys(%envs))]);
		|
		|What deployments do you want to automaticlly trigger when there are corresponding
		|deployment or stemcell changes?
		|EOF

		$layouts{$name}{auto} = join(" ",@$auto_triggers);
		$validate = "![".join(",",keys(%layouts))."]";

	} while (prompt_for_boolean("Would you like to enter another layout for your pipeline?"));
	return \%layouts;
}

sub boolean_to_yaml {
	return $_[0] ? "true" : "false";
}

sub generate_ci_template_file() {
	my ($pipeline, $name) = @_;

	open my $OUT, ">", $name or die "Unable to open $name for writing: $!\n";
	print $OUT <<"EOF";
pipeline:
  name: $pipeline->{name}

  public:      ${\boolean_to_yaml($pipeline->{public})}
  tagged:      ${\boolean_to_yaml($pipeline->{tagged})}
  debug:       ${\boolean_to_yaml($pipeline->{debug})}
  skip_upkeep: ${\boolean_to_yaml($pipeline->{skip_upkeep})}

  git:
EOF

	my @components = ("owner","repo");
	unshift(@components, "host") unless $pipeline->{git}{host} eq "github.com";
	unshift(@components, "user") unless $pipeline->{git}{user} eq "git";
	foreach (@components) {
		my $label = sprintf("%-13s", "$_:");
		print $OUT <<"EOF";
    $label$pipeline->{git}{$_}
EOF
	}
	print $OUT <<"EOF";
    private_key: (( vault "$pipeline->{git}{private_key}" ))

  vault:
    role:   (( vault "$pipeline->{vault}{role}" ))
    secret: (( vault "$pipeline->{vault}{secret}" ))
    url:    $pipeline->{vault}{url}
    verify: ${\boolean_to_yaml($pipeline->{vault}{verify})}
EOF

	if ($pipeline->{notifications}{slack}{webhook}) {
		print $OUT <<"EOF";

  slack:
    webhook: $pipeline->{notifications}{slack}{webhook}
    channel: $pipeline->{notifications}{slack}{channel}
EOF
	}

	if ($pipeline->{notifications}{hipchat}{token}) {
		print $OUT <<"EOF";

  hipchat:
    token:   (( vault "$pipeline->{notifications}{hipchat}{token}" ))
    room_id: $pipeline->{notifications}{hipchat}{room_id}
EOF
	}

	if ($pipeline->{notifications}{email}{to}) {
		print $OUT <<"EOF";

  email:
    to:   $pipeline->{notifications}{email}{to}
    from: $pipeline->{notifications}{email}{from}
    smtp:
      username: $pipeline->{notifications}{email}{smtp}{username}
      password: (( vault "$pipeline->{notifications}{email}{smtp}{password}" ))
      host:     $pipeline->{notifications}{email}{smtp}{host}
      port:     $pipeline->{notifications}{email}{smtp}{port}
EOF
	}

	if ($pipeline->{locker}{url}) {
		print $OUT <<"EOF";

  locker:
    url:      $pipeline->{locker}{url}
    username: $pipeline->{locker}{username}
    password: (( vault "$pipeline->{locker}{password}" ))
EOF
	}

	my @stemcells = split("\n",$pipeline->{stemcells});
	print $OUT <<"EOF";

  stemcells:${\(scalar(keys %{$pipeline->{stemcells}}) ? "" : " {}")}
EOF
	foreach my $alias (keys %{$pipeline->{stemcells}}) {
		print $OUT <<"EOF"
    $alias: $pipeline->{stemcells}{$alias}
EOF
	}

	print $OUT <<"EOF";

  boshes:
EOF
	foreach my $env (keys %{$pipeline->{boshes}}) {
		print $OUT <<"EOF";
    $env:
      alias:     $pipeline->{boshes}{$env}{alias}
      url:       $pipeline->{boshes}{$env}{url}
      ca_cert:   (( vault "$pipeline->{boshes}{$env}{ca_cert}" ))
      username:  $pipeline->{boshes}{$env}{username}
      password:  (( vault "$pipeline->{boshes}{$env}{password}" ))
      stemcells: ${\(scalar(@{$pipeline->{boshes}{$env}{stemcells}}) ? "" : " []")}
EOF
		foreach my $i ( 0 .. $#{ $pipeline->{boshes}{$env}{stemcells} } ) {
			print $OUT <<"EOF";
      - $pipeline->{boshes}{$env}{stemcells}[$i]
EOF
		}
		print $OUT "\n";
	}

	print $OUT <<"EOF";
  layouts:
EOF
	foreach my $layout (keys %{$pipeline->{layouts}}) {
		print $OUT <<"EOF";
    $layout: |+
      auto $pipeline->{layouts}{$layout}{auto}
EOF
		print $OUT "      $_\n" foreach (@{$pipeline->{layouts}{$layout}{deployments_chains}});
		print $OUT "\n";
	}

	if ($pipeline->{errands}) {
		my @errands;
		for my $i ( 0 .. $#{ $pipeline->{errands} } ) {
			push (@errands, $pipeline->{errands}[$i]);
		}
		my $errands = "[".join(",", @errands)."]";

		print $OUT <<"EOF";
  errands: $errands
EOF
	}

	close $OUT;
}
# }}}
# genesis deploy - Pull in Cloud Config, Generate a manifest, deploy {{{

command("deploy", <<EOF,
genesis v$VERSION
USAGE: genesis deploy [-n|--non-interactive] [--fix|--recreate] [--no-redact] env-name[.yml]

OPTIONS
$GLOBAL_USAGE
EOF
sub {
	my %options;
	options(\@_, \%options, qw/
		non-interactive|n
		no-redact
		fix
		recreate
	/);
	usage(1) if @_ != 1;
	check_prereqs;

	if ($options{fix} && $options{recreate}) {
		usage(1,"Cannot specify --fix and --recreate together");
	}

	if ($options{'non-interactive'}) {
		$ENV{BOSH_NON_INTERACTIVE}='true';
		delete $options{'non-interactive'};
	}

	my $rc = deploy_manifest($_[0], \%options);
	exit $rc;
});
# }}}
# genesis secrets - Generate / Rotate required credentials for an environment. {{{

command("secrets", <<EOF,
genesis v$VERSION
USAGE: genesis secrets [check|add|rotate [--force]][--vault target] deployment-env.yml

Checks, adds or rotates secrets for your deployment.

  * check:  Checks that all required secrets are present.  Returns a exit code
            of 1 if any are missing, and lists them, otherwise states all
            secrets are present and exits with 0.

  * add:    Generates any missing secrets required by the deployment.  Useful
            to generate credentials after upgrading kits or if `genesis new
            --no-secrets` was used to create the deployment.

  * rotate: Generates new secrets for your deployment. If any credentials were
            marked by the kit as `fixed', they are not updated unless the
            `--force` option was also specified.

OPTIONS
$GLOBAL_USAGE
  -f, --force        Rotate *ALL* credentials, including any credentials that
                     the kit defined as `fixed'. This is very dangerous.  Only
                     applies to `rotate`

      --vault        The name of a `safe' target (a Vault) to store newly
                     generated credentials in.

EOF
sub {
	my %options;
	options(\@_, \%options, qw/
		force|force-rotate-all|f
		vault=s
	/);

	my ($action,$name) = @_;
	if (@_ == 1) {
		$name = $action;
		$action = 'check';
	}
	usage(1) if @_ < 1 or @_ > 2;
    usage(1, "Must specify check, add or rotate, not $action")
		unless (grep {$_ eq $action} qw(check add rotate));
	if ($options{force}) {
		usage(1, "Can only specify --force with rotate") if $action ne 'rotate';
		$action = 'force';
	}

	check_prereqs;

	$name =~ s/\.ya?ml$//;
	my $deployment = $name . "-" . deployment_suffix;
	(my $prefix = $deployment) =~ s|-|/|g;

	my ($kit, $version) = kit_name_and_version_for($name);
	my $meta = read_kit_metadata($kit, $version);
	target_vault($options{vault});

	if ($action eq "check") {
		exit check_secrets(   $meta,
			env       => $name,
			prefix    => $prefix,
			subkits   => get_key($name, 'kit.subkits', [])
		);
	} else {
		vaultify_secrets($meta,
			env       => $name,
			prefix    => $prefix,
			subkits   => get_key($name, 'kit.subkits', []),
			scope     => $action
		);
	}
});

# }}}
# genesis yamls - Print a list of the YAML files used for a single environment. {{{

command("yamls", <<EOF,
genesis v$VERSION
USAGE: genesis yamls deployment-env.yml

OPTIONS
$GLOBAL_USAGE
EOF
sub {
	my %options;
	options(\@_, \%options, qw/
		rotate
	/);
	usage(1) if @_ != 1;
	check_prereqs;

	print "$_\n" for mergeable_yaml_files($_[0]);
});

# }}}
# genesis create-kit - Create the structure for a new kit {{{
#
command("create-kit", <<EOF,
genesis v$VERSION
USAGE: genesis create-kit -d|--dev -n NAME [SUBKIT1 ...]

OPTIONS
$GLOBAL_USAGE
  -d, --dev       create kit in ./dev directory instead of <name>-genesis-kit
  -n, --name      Name of the kit archive.
EOF
sub {
	my %options;
	options(\@_, \%options, qw/
		name|n=s
		dev|d
	/);
	usage(2) unless $options{name};
	check_prereqs(no_repo_needed => ! $options{dev}); # only require repo if in dev mode

	my $dir = ($options{cwd} || ".") . "/". ($options{dev} ? "dev" : "$options{name}-genesis-kit");

	die "$dir already exists, cowardly refusing to overwrite it\n"
	  if -d $dir;

	mkdir_or_fail $dir;
	mkdir_or_fail "$dir/base";

	mkfile_or_fail "$dir/base/params.yml", <<EOF;
---
# Contains the defaults for the parameters needed for the base $options{name} kit.
params: {}
EOF
	mkfile_or_fail "$dir/base/$options{name}.yml", <<EOF;
---
# Contains the configuration for base $options{name} kit.
instance_groups: {}
properties: {}

releases:
- name: $options{name}
  version:
  sha1:
  url:

EOF
	mkfile_or_fail "$dir/base/0-deployment.yml", <<EOF;
---
# Contains the instance_groups in install order, as well as the stemcells and
# update stanzas for the base $options{name} kit.
instance_groups:
- name: *jobname*
  instances: 1
  azs: (( grab params.availability_zones ))
  stemcell: default
  persistent_disk_pool: (( grab params.disk_pool ))
  networks:
  - name: (( grab params.network ))
    static_ips: (( static_ips(0) ))
  vm_type: (( grab params.vm_type ))
  update:
    max_in_flight: 1

stemcells:
- alias: default
  os: (( grab params.stemcell_os ))
  version: (( grab params.stemcell_version ))

meta:
  vault: (( concat "secret/" params.vault ))

update:
  serial: false
  canaries: 1
  canary_watch_time: 30000-600000
  update_watch_time: 5000-600000
  max_in_flight: 1
  max_errors: 1
EOF

	# Subkits
	mkdir_or_fail "$dir/subkits";
	my $subkit_groups="";
	my $subkit_param_groups="";
	my $subkit_prompts="";
	foreach my $subkit_req (@_) {
		my ($subkit,$prompt) = split("=",$subkit_req, 2);
		mkdir_or_fail "$dir/subkits/$subkit";
		$subkit_groups .= "  $subkit: {}\n";
		$subkit_param_groups .= "  $subkit: []\n";
		next if defined($prompt) && $prompt eq '-';
		$prompt ||= "Do you want to use subkit '$subkit'?";
		$subkit_prompts .= "- prompt: $prompt\n  subkit: $subkit\n";

		mkfile_or_fail "$dir/subkits/$subkit/params.yml", "---\nparams: {}\n";
		mkfile_or_fail "$dir/subkits/$subkit/$subkit.yml", "--- {}\n";
	}

	my $subkits = "";
	if ($subkit_prompts) {
		$subkits = "subkits:\n$subkit_prompts";
	} else {
		$subkits = "subkits: []\n";
	}

	chomp(my $user = qx'git config user.name');
	chomp(my $email = qx'git config user.email');
	mkfile_or_fail "$dir/kit.yml", <<EOF;
---
name: $options{name}
author: $user <$email>
homepage: https://github.com/cloudfoundry-community/$options{name}-boshrelease
github: https://github.com/genesis-community/$options{name}-genesis-kit

$subkits
params:
  base: []
$subkit_param_groups
credentials:
  base: {}
$subkit_groups
certificates:
  base: {}
$subkit_groups
EOF

	mkfile_or_fail "$dir/README.md", <<EOF;
$options{name} Genesis Kit
=================

FIXME: The kit author should have filled this in with details about
what this is, and what it provides. But they have not, and that is sad.
Perhaps a GitHub issue should be opened to remind them of this?

Quick Start
-----------

To use it, you don't even need to clone this repository! Just run
the following (using Genesis v2):

```
# create a $options{name}-deployments repo using the latest version of the $options{name} kit
genesis init --kit $options{name}

# create a $options{name}-deployments repo using v1.0.0 of the $options{name} kit
genesis init --kit $options{name}/1.0.0

# create a my-$options{name}-configs repo using the latest version of the $options{name} kit
genesis init --kit $options{name} -d my-$options{name}-configs
```

Once created, refer to the deployment repo's README for information on creating

Subkits
-------

FIXME: The kit author should have filled this in with details
about what subkits are defined, and how they affect the deployment. But they
have not, and that is sad. Perhaps a GitHub issue should be opened to remind
them of this?

Params
------

FIXME: The kit author should have filled this in with details about the params
present in the base kit, as well as each subkit defined. These should likely
be in different sections (one for base, one per subkit). Unfortunately,
the author has not done this, and that is sad. Perhaps a GitHub issue
should be opened to remind them of this?

Cloud Config
------------

FIXME: The kit author should have filled in this section with details about
what cloud config definitions this kit expects to see in play and how to
override them. Also useful are hints at default values for disk + vm sizing,
scaling considerations, and other miscellaneous IaaS components that the deployment
might require, like load balancers.

EOF

});

# }}}
# genesis compile-kit - Create a distributable kit archive from dev/. {{{

command("compile-kit", <<EOF,
genesis v$VERSION
USAGE: genesis compile-kit -v VERSION [-n NAME] [-d|--dev]

OPTIONS
$GLOBAL_USAGE

  -v, --version Version to package.

  -n, --name    Name of the kit archive.  If not provided, will take the name
                of the current (or specified with -C) directory before the
                suffix of -genesis-kit (standalone mode) or -deployments
                (dev mode).

  -d, --dev     Compile based off of a dev-kit (./dev). If not specified,
                genesis will compile based off of ./<name>-genesis-kit.
                Automatically set if run from inside a genesis deployments directory.
EOF
sub {
	my %options;
	options(\@_, \%options, qw/
		dev|d
		name|n=s
		version|v=s
	/);
	usage(1) if @_ != 0;

	my $dir;
	unless ($options{name}) {
		my $pwd = abs_path($options{cwd} || getcwd);
		if ($pwd =~ /\/([^\/]*)-deployments(\/)?$/) {
		# Building from a dev inside a deployment repo - gleen the name
			$options{name} = $1;
			$dir = "$pwd/dev";
			$options{dev} = 1;
		} elsif ($pwd =~ /\/([^\/]*)-genesis-kit(\/)?$/) {
			$options{name} = $1;
			$dir = $pwd;
			die "Current directory is a kit -- cannot specify dev mode\n"
				if $options{dev};
		}
	}
	usage(1, "Missing name option, cannot determine from `pwd`") unless $options{name};
	usage(1) unless $options{version};
	check_prereqs(no_repo_needed => 1);

	unless ($dir) {
		if ($options{dev}) {
			$dir = ($options{cwd} || ".") . "/dev";
			die "$dir does not exist -- cannot continue compiling dev kit.\n" unless -d $dir;
		} else {
			$dir = ($options{cwd} || ".");
			$dir .= "/$options{name}-genesis-kit"
				if (! -f "$dir/kit.yml" && -d "/$options{name}-genesis-kit");
		}
	}

	validate_kit_files($dir);
	validate_kit_metadata($options{name},$options{version},LoadFile("$dir/kit.yml"),1);

	my $temp = tempdir(CLEANUP => 1);
	my $stem = "$options{name}-$options{version}";
	mkdir_or_fail "$temp/$stem";
	qx(cp -aH $dir/* $temp/$stem);

	qx(rm -rf $temp/.git $temp/.gitignore);

	qx(tar -czf $stem.tar.gz -C $temp $stem/);

	printf "Created $stem.tar.gz\n\n";
});

# }}}
# genesis decompile-kit - Unpack a kit archive to dev/. {{{

command("decompile-kit", <<EOF,
genesis v$VERSION
USAGE: genesis decompile-kit [NAME/VERSION | path/to/kit.tar.gz]

OPTIONS
$GLOBAL_USAGE
  -f, --force  Overwrite dev/, if it exists.
EOF
sub {
	my %options;
	options(\@_, \%options, qw/
		force|f
	/);
	usage(1) if @_ != 1;
	check_prereqs;

	if (-d "dev" && !$options{force}) {
		die "dev/ directory already exists (and --force not specified).  Bailing out.\n";
	}

	my $temp = tempdir(CLEANUP => 1);
	my $file = $_[0];
	if (! -f $file) {
		(my $stem = $file) =~ s|/|-|;
		$file = ".genesis/kits/$stem.tar.gz";
	}
	-f $file or die "Unable to find Kit archive $_[0]\n";

	qx(tar -xzf $file -C $temp && rm -rf dev && mv $temp/*/ dev/);
});

# }}}
# genesis manifest - Compile a deployment manifest. {{{

command("manifest", <<EOF,
genesis v$VERSION
USAGE: genesis manifest [--no-redact] [--cloud-config path.yml] deployment-env.yml

OPTIONS
$GLOBAL_USAGE

  -c, --cloud-config PATH    Path to your downloaded BOSH cloud-config

      --no-redact            Do not redact credentials in the manifest.
                             USE THIS OPTION WITH GREAT CARE AND CAUTION.
EOF
sub {
	my %options;
	options(\@_, \%options, qw/
		cloud-config|c=s
		no-redact
	/);
	usage(1) if @_ != 1;
	my ($env) = @_;
	check_prereqs;

	$ENV{REDACT} = 'true';
	$ENV{REDACT} = '' if $options{'no-redact'};

	my $create_env = is_create_env($env);

	# set offline since there's no director to talk to
	$ENV{OFFLINE} = 1 if ($create_env);

	if (!$options{'cloud-config'} && !$create_env) {
		if (!online) {
			error "You requested #B{offline} mode, but did not provide a #C{--cloud-config} to use.\n";
			error "In offline mode, Genesis is not allowed to talk to the BOSH director,\n";
			error "so you must provide a cloud config explicitly.\n";
			exit 1;
		}
		my $dir = workdir;
		bosh_download_cloud_config(bosh_target_for($env), "$dir/cloud.yml");
		$options{'cloud-config'} = "$dir/cloud.yml";
	}
	print merge_manifest($env, {
		'cloud-config' => $options{'cloud-config'},
		'create-env'   => $create_env,
	});
});

# }}}
# genesis repipe - Deploy a Concourse CI/CD deployment pipeline. {{{

command(["repipe", "push"], <<EOF,
genesis v$VERSION
USAGE genesis repipe [pipeline-layout]

OPTIONS
$GLOBAL_USAGE
  -t, --target     The name of your Concourse target (per `fly targets'),
                   if it differs from the pipeline layout name.

  -n, --dry-run    Generate the Concourse Pipeline configuration, but
                   refrain from actually deploying it to Concourse.
                   Instead, just print the YAML.

  -c, --config     Path to the pipeline configuration file, which specifies
                   Git parameters, notification settings, pipeline layouts,
                   etc.  Defaults to 'ci.yml'
EOF
sub {
	my %options;
	options(\@_, \%options, qw/
		dry-run|n
		target|t=s
		config|c=s
	/);
	check_prereqs;

	my $layout = $_[0] || "default";
	$options{target} ||= $layout;
	$options{config} ||= 'ci.yml';

	my $pipeline = parse_pipeline($options{config}, $layout);
	my $yaml = generate_pipeline_concourse_yaml($pipeline);
	if ($options{'dry-run'}) {
		print $yaml;
		exit 0;
	}

	my $dir = workdir;
	put_file("${dir}/pipeline.yml", $yaml);
	system_execute("fly -t $options{target} set-pipeline -p $pipeline->{pipeline}{name} -c ${dir}/pipeline.yml") or exit 1;
	system_execute("fly -t $options{target} unpause-pipeline -p $pipeline->{pipeline}{name}") or exit 1;
	if ($pipeline->{pipeline}{public}) {
		system_execute("fly -t $options{target} expose-pipeline -p $pipeline->{pipeline}{name}") or exit 1;
	} else {
		system_execute("fly -t $options{target} hide-pipeline -p $pipeline->{pipeline}{name}") or exit 1;
	}
	exit 0;
});
# }}}
# genesis graph - Draw a Concourse CI/CD deployment pipeline. {{{

command("graph", <<EOF,
genesis v$VERSION
USAGE genesis graph [pipeline-layout] | dot -Tpng > pipe.png

Note: This command outputs a directed, acyclic graph (a DAG) in the
      Graphviz language (http://www.graphviz.org/).  If you want a
      picture of the pipeline, you will need to pipe the output through
      one of the many Graphviz formatters, like `dot -Tpng > out.png`

OPTIONS
$GLOBAL_USAGE
  -c, --config     Path to the pipeline configuration file, which specifies
                   Git parameters, notification settings, pipeline layouts,
                   etc.  Defaults to 'ci.yml'
EOF
sub {
	my %options;
	options(\@_, \%options, qw/
		config|c=s
	/);
	check_prereqs;

	my $layout = $_[0] || "default";
	$options{config} ||= 'ci.yml';

	my $pipeline = parse_pipeline($options{config}, $layout);
	my $dot = generate_pipeline_graphviz_source($pipeline);
	print "$dot\n";
	exit 0;
});
# }}}
# genesis describe - Describe a Concourse CI/CD deployment pipeline. {{{

command("describe", <<EOF,
genesis v$VERSION
USAGE genesis describe [pipeline-layout]

OPTIONS
$GLOBAL_USAGE
  -c, --config     Path to the pipeline configuration file, which specifies
                   Git parameters, notification settings, pipeline layouts,
                   etc.  Defaults to 'ci.yml'
EOF
sub {
	my %options;
	options(\@_, \%options, qw/
		config|c=s
	/);
	check_prereqs;

	my $layout = $_[0] || "default";
	$options{config} ||= 'ci.yml';

	my $pipeline = parse_pipeline($options{config}, $layout);
	generate_pipeline_human_description($pipeline);
	exit 0;
});
# }}}
# genesis lookup - Find a key set in environment manifests. {{{

command("lookup", <<EOF,
genesis v$VERSION
USAGE genesis lookup key env-name default-value

OPTIONS
$GLOBAL_USAGE
EOF
sub {
	my %options;
	options(\@_, \%options, qw/
	/);
	usage(1) if @_ != 3;
	check_prereqs;

	my ($key, $env, $default) = @_;
	my $v = get_key($env, $key);
	$v = defined $v ? $v : $default;
	if (ref($v)) {
		print encode_json($v)."\n";
	} else {
		print "$v\n";
	}
	exit 0;
});
# }}}
# genesis download - Download a Genesis Kit from the Internet. {{{

command("download", <<EOF,
genesis v$VERSION
USAGE genesis download NAME[/VERSION] [...]

OPTIONS
$GLOBAL_USAGE
EOF
sub {
	my %options;
	options(\@_, \%options, qw/
	/);
	usage(1) if @_ < 1;
	check_prereqs;

	for (@_) {
		my ($name, $version) = extract_kit_name_and_version($_);
		download_kit_tarball($name, $version)
			or exit 1;
	}
	exit 0;
});
# }}}
# genesis summary - Print a summary of each environment. {{{

command("summary", <<EOF,
genesis v$VERSION
USAGE genesis summary

OPTIONS
$GLOBAL_USAGE
EOF
sub {
	my %options;
	options(\@_, \%options, qw/
	/);
	check_prereqs;

	my @rows;
	my $stem = undef;
	for my $env (standalone_environment_yaml_files(glob("*.yml"))) {
		$env =~ s/\.yml$//;
		my $kit = get_key($env, "kit.name");
		my $ver = get_key($env, "kit.version");

		# FIXME: look at last  time i deployed the manifest instead of this cache file
		# FIXME: show what is out of date, if anything
		my $last = "never";
		if (-f ".genesis/cached/$env/last") {
			my $ts = get_file(".genesis/cached/$env/last") + 0;
			if ($ts) { # in case `last' is corrupt (i.e. not a timestamp)
				$last = strftime(envdefault("GENESIS_TIME_FORMAT", "%Y-%m-%d %H:%M:%S%P (@@)"), localtime($ts));

				$last =~ s/@@/ago($ts)/ge;
			}
		}

		(my $tmp = $env) =~ s/-[^-]*$//;
		push @rows, undef if defined $stem && $stem ne $tmp;
		$stem = $tmp;

		push @rows, [$env, "$kit/$ver", $last];

	}
	tablify(['Environment', 'Kit/Version', 'Last Deployed'], \@rows);
	exit 0;
});
# }}}
# genesis vault-policies - Generate Vault policies for an environment {{{
command("vault-policies", <<EOF,
genesis v$VERSION
USAGE genesis vault-policies [pipeline-layout]

OPTIONS
$GLOBAL_USAGE
  -c, --config     Path to the pipeline configuration file, which specifies
                   Git parameters, notification settings, pipeline layouts,
                   etc.  Defaults to 'ci.yml'
EOF
sub {
	my %options;
	options(\@_, \%options, qw/
	/);
	check_prereqs;

	my $layout = $_[0] || "default";
	$options{config} ||= "ci.yml";
	my @paths;

	$ENV{REDACT} = "true"; # we don't need vault creds for this, just pipeline layout
	my $pipeline = parse_pipeline($options{config}, $layout);
	for my $env (sort @{$pipeline->{envs}}) {
		# Always grab cloud config, since we're probably up and running if using this command
		# Posible issues we could run into are that the jumpbox doesn't have access to all
		# BOSH directors, or that someone is trying to build their vault policies before
		# anything is running. If we run into these cases, this can be changed, either by
		# somehow providing cloud configs for *all* boshes, or by making `spruce vaultinfo`
		# ignore static_ips?
		my $dir = workdir;
		if (is_create_env($env)) {
			write_stemcell_data("$dir/cloud.yml"); # Why write stemcell to cloud.yml??!!
		} else {
			bosh_download_cloud_config(bosh_target_for($env), "$dir/cloud.yml");
		}
		$options{'cloud-config'} = "$dir/cloud.yml";

		# get all files for a deployment
		my $vault_prefix = get_key($env, "params.vault", "");
		chomp $vault_prefix;
		die "Unable to find `params.vault' for environment `$env'. Cannot continue\n" unless $vault_prefix;

		push @paths, "secret/$vault_prefix/*";
		for my $extra_path (sort grep {chomp; $_ !~ m/^secret\/$vault_prefix\// } spruce_vault_paths(@{merge_files($env, \%options)})) {
			push @paths, $extra_path;
		}
	}
	push @paths, "secret/handshake";
	generate_ci_hcl_file('-', @paths);
});

sub generate_ci_approle_policies {
	my (
		$role_name,
		$role_path,
		$secret_path,
		@access_paths
	) = @_;

	my $dir = workdir;
	my $hcl_file = "$dir/concourse.hcl";
	my $r;

	explain "#Y{Determining vault paths needed for Concourse pipelines...}\n";
	generate_ci_hcl_file($hcl_file, @access_paths);

	explain "#Y{Creating Concourse AppRole for $role_name}\n";
	$r = system("safe", "vault", "policy-write", $role_name, $hcl_file);
	die "Could not set policy for $role_name:\n$r\n" unless ($? >> 8) == 0;
	$r = system("safe", "vault", "write", "auth/approle/role/$role_name",
		"secret_id_ttl=0",
		"token_num_uses=0",
		"token_ttl=1m",
		"token_max_ttl=1m",
		"secret_id_num_uses=0",
		"policies=$role_name"
	);
	die "Could not create approle for $role_name:\n$r\n" unless ($? >> 8) == 0;

	explain "#Y{Getting role and secret credentials from AppRole}\n";
	my ($role_p, $role_k) = $role_path =~/^(.*):([^:]*)$/;
	die "Invalid vault path '$role_path': expecting <path>:<key>\n" unless defined($role_p) && defined($role_k);

	my ($secret_p, $secret_k) = $secret_path =~/^(.*):([^:]*)$/;
	die "Invalid vault path '$secret_path': expecting <path>:<key>\n" unless defined($secret_p) && defined($secret_k);

	$r = qx(safe read auth/approle/role/$role_name/role-id | spruce json | jq -r .role_id | safe paste $role_p $role_k);
	die "Could not store role_id to $role_path:\n$r\n" unless ($? >> 8) == 0;
	$r = qx(safe vault write -f -format=json auth/approle/role/$role_name/secret-id | jq -r '.data.secret_id' | safe paste $secret_p $secret_k);
	die "Could not store secret_id to $secret_path:\n$r\n" unless ($? >> 8) == 0;

	explain "#G{Completed AppRole creation for $role_name.}";
}

sub generate_ci_hcl_file {
	my (
		$hclfile,           # SET TO '-' to print to screen
		@vault_paths
	) = @_;

	my $fh;
	if ($hclfile eq '-') {
		$fh = *STDOUT;
	} else {
		open($fh, ">$hclfile") or die "can't open $hclfile: $!\n";
	}

	my %done;
	foreach (@vault_paths) {
		next if $done{$_};
		$done{$_} = 1;
		print $fh clean_heredoc(<<"		|EOF");
		|path "$_" {
		|    capabilities = [ "read", "list" ]
		|}
		|EOF
	}
	close $fh unless ($hclfile eq '-');
}

# }}}
# genesis ci-pipeline-deploy - Deploy via the CI/CD Pipeline {{{

command("ci-pipeline-deploy", <<EOF,
genesis v$VERSION
USAGE genesis ci-pipeline-deploy

OPTIONS
$GLOBAL_USAGE
EOF
sub {
	my %options;
	options(\@_, \%options, qw/
	/);
	usage(1) if @_;
	check_prereqs(no_repo_needed => 1);

	# environment variables we should have
	#   CURRENT_ENV                - Name of the current environment
	#   PREVIOUS_ENV               - Name of previous environment (if applicable, for finding
	#
	#   VAULT_ROLE_ID              - Vault RoleID to authenticate to Vault with
	#   VAULT_SECRET_ID            - Vault SecretID to authenticate to Vault with
	#   VAULT_ADDR                 - URL of the Vault to use for credentials retrieval
	#   VAULT_SKIP_VERIFY          - Whether or not to enforce SSL/TLS validation
	#
	#   GIT_BRANCH                 - Name of the git branch to push commits to. post-deploy
	#   GIT_PRIVATE_KEY            - Private Key to use for pushing commits, post-deploy
	#
	#   WORKING_DIR - Path to the directory to deploy/work from
	#   OUT_DIR     - Path to the directory to output to
	#   CACHE_DIR   - Path to the directory our cache is in (required if PREVIOUS_ENV is present
	#
	# and unless we're a create-env based deploy, we should also have:
	#   BOSH_ENVIRONMENT           - URL of the BOSH director to deploy on
	#   BOSH_CA_CERT               - CA Certificate for the BOSH director
	#   BOSH_CLIENT                - Username or client ID (UAA-auth) to authenticate with
	#   BOSH_CLIENT_SECRET         - Password/Client-Secret to authenticate with

	my @undefined = grep { !$ENV{$_} }
		qw/CURRENT_ENV GIT_BRANCH GIT_PRIVATE_KEY
		   OUT_DIR WORKING_DIR
		   VAULT_ROLE_ID VAULT_SECRET_ID VAULT_ADDR/;
	push @undefined, "CACHE_DIR" if ($ENV{PREVIOUS_ENV} && ! $ENV{CACHE_DIR});

	# move to working dir prior to seeing if current env is bosh-init
	pushd $ENV{WORKING_DIR};
	push(@undefined, grep { !$ENV{$_} }
		qw/BOSH_ENVIRONMENT BOSH_CA_CERT
		   BOSH_CLIENT BOSH_CLIENT_SECRET/) unless is_create_env($ENV{CURRENT_ENV});

	if (@undefined) {
		error "The following #R{required} environment variables have not been defined:";
		error " - \$#Y{$_}" for @undefined;
		error;
		error;
		error "Please check your CI Pipeline configuration.";
		exit 1;
	}

	if ($ENV{PREVIOUS_ENV}) {
		system("rm -rf .genesis/config .genesis/kits .genesis/cached") == 0 or exit 1;
		system("cp -R ../$ENV{CACHE_DIR}/.genesis/cached .genesis/cached") == 0 or exit 1;
		system("cp -R ../$ENV{CACHE_DIR}/.genesis/config .genesis/config") == 0 or exit 1;
		system("cp -R ../$ENV{CACHE_DIR}/.genesis/kits .genesis/kits") == 0 or exit 1;
	}

	# don't set up a bosh alias if we're a create-env based deploy, no need, no data
	unless (is_create_env($ENV{CURRENT_ENV})) {
		my $target = bosh_target_for($ENV{CURRENT_ENV});
		bosh_alias($target); # exits on failure
	}

	vault_auth(vault       => $ENV{VAULT_ADDR},
	           skip_verify => envset("VAULT_SKIP_VERIFY"),
	           role_id     => $ENV{VAULT_ROLE_ID},
	           secret_id   => $ENV{VAULT_SECRET_ID});

	my $rc = deploy_manifest($ENV{CURRENT_ENV}); # exits if it fails
	if ($ENV{PREVIOUS_ENV}) {
		## rm cache dir
		## copy previous env cache dir
		system("rm -rf .genesis/config .genesis/kits .genesis/cached") == 0 or exit 1;
		system("git checkout .genesis/config"); # ignore failure for git checkout so that
		system("git checkout .genesis/kits");   # we don't cause problems if these files dont
		system("git checkout .genesis/cached"); # yet exist in the working tree (but did in the cache tree)
	}
	popd;
	commit_changes($ENV{WORKING_DIR}, $ENV{OUT_DIR}, $ENV{GIT_BRANCH}, $ENV{GIT_PRIVATE_KEY},
		"deployed to $ENV{CURRENT_ENV}");
	exit $rc;
});
# }}}
# genesis ci-stemcells - Upload stemcells to an environment via the CI/CD Pipeline {{{
command("ci-stemcells", <<EOF,
genesis v$VERSION
USAGE genesis ci-stemcells

OPTIONS
$GLOBAL_USAGE
EOF
sub {
	my %options;
	options(\@_, \%options, qw/
	/);
	usage(1) if @_;
	check_prereqs(no_repo_needed => 1);

	# environment variables we should have
	#   STEMCELLS - Path to the directory containing stemcells to upload
	#   BOSH_ENVIRONMENT           - URL of the BOSH director to deploy on
	#   BOSH_CA_CERT               - CA Certificate for the BOSH director
	#   BOSH_CLIENT                - Username or client ID (UAA-auth) to authenticate with
	#   BOSH_CLIENT_SECRET         - Password/Client-Secret to authenticate with
	#
	my @undefined = grep { !$ENV{$_} }
		qw/STEMCELLS BOSH_ENVIRONMENT BOSH_CA_CERT BOSH_CLIENT BOSH_CLIENT_SECRET/;
	if (@undefined) {
		error "The following #R{required} environment variables have not been defined:";
		error " - \$#Y{$_}" for @undefined;
		error;
		error;
		error "Please check your CI Pipeline configuration.";
		exit 1;
	}

	opendir(my $dh, $ENV{STEMCELLS})
		or die "Could not open `$ENV{STEMCELLS}' directory to find stemcells.\n";
	while (my $stemcell = readdir($dh)) {
		if ($stemcell !~ /^\./ && -d "$ENV{STEMCELLS}/$stemcell") {
			my $version = get_file "$ENV{STEMCELLS}/$stemcell/version";
			my $sha1    = get_file "$ENV{STEMCELLS}/$stemcell/sha1";
			my $url     = get_file "$ENV{STEMCELLS}/$stemcell/url";
			bosh_upload_stemcell($stemcell, $version, $sha1, $url);
		}
	}
	closedir $dh
});
# }}}
# genesis ci-generate-cache - Generate cache for an environment via the CI/CD Pipeline {{{
command("ci-generate-cache", <<EOF,
genesis v$VERSION
USAGE genesis ci-generate-cache

OPTIONS
$GLOBAL_USAGE
EOF
sub {
	my %options;
	options(\@_, \%options, qw/
	/);
	usage(1) if @_;
	check_prereqs(no_repo_needed => 1);

	# environment variables we should have
	#   CURRENT_ENV - Name of the current environment
	#   GIT_BRANCH                 - Name of the git branch to push commits to. post-deploy
	#   GIT_PRIVATE_KEY            - Private Key to use for pushing commits, post-deploy
	#   WORKING_DIR - Path to the directory to deploy/work from
	#   OUT_DIR     - Path to the directory to output to
	#
	my @undefined = grep { !$ENV{$_} }
		qw/CURRENT_ENV GIT_BRANCH GIT_PRIVATE_KEY
		   WORKING_DIR OUT_DIR/;
	if (@undefined) {
		error "The following #R{required} environment variables have not been defined:";
		error " - \$#Y{$_}" for @undefined;
		error;
		error;
		error "Please check your CI Pipeline configuration.";
		exit 1;
	}

	pushd $ENV{WORKING_DIR};
	mkdir_or_fail ".genesis/cached/$ENV{CURRENT_ENV}";
	for my $file (expand_tokens(split /\-/, $ENV{CURRENT_ENV})) {
		copy_or_fail "$file.yml", ".genesis/cached/$ENV{CURRENT_ENV}/$file.yml" if -f "$file.yml";
	}
	popd;
	commit_changes($ENV{WORKING_DIR}, $ENV{OUT_DIR}, $ENV{GIT_BRANCH}, $ENV{GIT_PRIVATE_KEY}, "generated cache for $ENV{CURRENT_ENV}");
});
# }}}
# genesis ci-pipeline-run-errand - Run arbitrary errands via the CI/CD Pipeline {{{

command("ci-pipeline-run-errand", <<EOF,
genesis v$VERSION
USAGE genesis ci-pipeline-run-errand

OPTIONS
$GLOBAL_USAGE
EOF
sub {
	my %options;
	options(\@_, \%options, qw/
	/);
	usage(1) if @_;
	check_prereqs(no_repo_needed => 1);

	# environment variables we should have
	#   CURRENT_ENV - Name of the current environment
	#   BOSH_ENVIRONMENT   - URL of the BOSH director to deploy on
	#   BOSH_CA_CERT       - CA Certificate for the BOSH director
	#   BOSH_CLIENT        - Username or client ID (UAA-auth) to authenticate with
	#   BOSH_CLIENT_SECRET - Password/Client-Secret to authenticate with
	#   ERRAND_NAME - Name of the Smoke Test errand to run

	my @undefined = grep { !$ENV{$_} }
		qw/CURRENT_ENV ERRAND_NAME
		   BOSH_ENVIRONMENT BOSH_CA_CERT
		   BOSH_CLIENT BOSH_CLIENT_SECRET/;
	if (@undefined) {
		error "The following #R{required} environment variables have not been defined:";
		error " - \$#Y{$_}" for @undefined;
		error;
		error;
		error "Please check your CI Pipeline configuration.";
		exit 1;
	}

	my $target = bosh_target_for($ENV{CURRENT_ENV});
	bosh_alias($target); # exits on failure

	my $deployment = "$ENV{CURRENT_ENV}-" . deployment_suffix;
	bosh_run_errand($target, $deployment, $ENV{ERRAND_NAME}); # exits on failure

	exit 0;
});
# }}}

###########################################################################

sub main {
	debug "genesis starting up...";

	$ENV{GENESIS} = $FindBin::Script;
	$ENV{GENESIS_INDEX} = "https://genesis.starkandwayne.com" unless $ENV{GENESIS_INDEX};

	# Check if we're in a v1 repo
	my $path = abs_path(getcwd);
	my $in_version = 0;
	if (in_repo_dir) {
		$in_version = 2;
	} else {
		while ($path ne "") {
			if (-d "$path/global" && -e "$path/global/deployment.yml") {
				$in_version = 1;
				last;
			}
			$path =~ s/\/[^\/]*$//;
		}
	}

	if ($in_version == 1) {
		# Make temp file for the script.
		die "Missing bin directory in the genesis deployment root -- required to run genesis v1\n"
			unless -d "$path/bin";
		my ($g1file,$g1filename) = tempfile("genesis-v1-XXXXXX",DIR =>"$path/bin/", UNLINK => 1);

		# Copy __DATA__ to tmpdir as "genesis-v1"
		my $g1script = do { local $/; <DATA> };

		# If this isn't the packaged version of genesis, bail
		die "ERROR: Attempting to use an unpackaged version of Genesis v2 in a v1 repository.\n"
		  unless $g1script;

		print $g1file $g1script;
		close $g1file;
		chmod 0755, $g1filename;

		# Set GENESIS_V1_PATH env var to shadow the obscure location
		($ENV{GENESIS_V2_VERSION} = $VERSION) =~ s/^\((.*)\)$/$1/;
		$ENV{GENESIS_V1_PATH_OVERRIDE} = $0;

		# Run v1 bash script
		$SIG{TERM} = sub {exit 3};
		$SIG{INT} = sub {exit 3};
		system($g1filename, @_);
		exit $? >> 8;
	}
	my ($cmd, @args);
	while (@_ > 0) {
		my $arg = shift @_;
		if ($cmd || $arg =~ m/^-+/) {
			push @args, $arg;
			push @args, shift @_ if $arg eq '-C';
		} else {
			$cmd = $arg;
		}
	}

	if ($cmd) {
		debug "running command '$cmd'";
		debug "arguments are [".join(', ', @args)."]";
		if (exists $COMMAND{$cmd}) {
			$COMMAND{$cmd}(@args);
			exit 0;
		}
		error "unrecognized command '$cmd'";
		usage(2, "", "help");
	}
	if (@args and $args[0] =~ m/^(-h|--help)$/) {
		$COMMAND{help}();
		exit 0;
	}
	if (@args and scalar(@args) == 1 && $args[0] =~ m/^(-v|--version)$/) {
		$COMMAND{version}();
		exit 0;
	}
	$COMMAND{help}();
	exit 2;
}

main(@ARGV);

__DATA__
